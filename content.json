{"pages":[{"title":"블로그 소개","text":"안녕하세요. 코딩소년의 블로그입니다. 저는 이제 소년이란 단어에 어울리는 나이는 아니지만 소년이란 단어가 주는 느낌이 좋습니다. 무언가를 시작하는 설레임과 순수함, 그리고 마치 깨끗한 도화지 같은 느낌이 들어서요. 이제 프로그래밍을 한지는 꽤 많은 시간이 흘렀지만 저는 지금도 항상 소년처럼 열린 마음으로 새로운 것들을 배우고, 프로그래밍을 하는 것 자체에서 설레임을 느끼고 있습니다. 이 정도면 코딩소년의 블로그란 말을 써도 될까요? 🤗 이 블로그에는 제가 프로그래밍을 하면서 배운 지식과 생각들을 정리하기 위해 만든 공간입니다. 여기에 작성하는 글은 최대한 한글로, 이해하기 쉽게 쓰는게 목표입니다. 의외로 스트릿 댄스를 좋아하고 꾸준히 춤을 추고 있습니다. 요즘들어 가장 행복한 시간은 아내와 반려견과 함께 산책을 하는 시간입니다. 개발자로서의 커리어 저는 대학원에서 시스템보안을 전공하였고, 보안회사인 AhnLab의 V3 Mobile 제품 개발팀에서 첫 커리어를 시작하였습니다. 이런 시작은 감사하게도 제가 컴퓨터 공학에 대한 기본기를 탄탄히 다지는데 많은 도움을 주었던것 같습니다. 이후 네이버에서 안드로이드 앱 개발자로서 네이버 앱, 그라폴리오, 폴라, V Live, WAV와 같은 서비스를 개발하였습니다. 네이버는 제가 모바일 개발자로서 성장하는데 정말 좋은 경험이었습니다. 다양한 서비스를 개발해보면서 포털, 이미지 기반 SNS, 라이브 스트리밍 서비스까지, 모바일 분야에서 해볼 수 있는 거의 모든 경험을 해볼 수 있었습니다. 비바리퍼블리카에서는 카드맞춤추천, 토스카드, 만보기와 같은 서비스를 개발하였습니다. AB테스트와 애자일을 무기로 서비스를 빠르게 성장 시키는 방법을 제대로 배울 수 있었던 소중한 기회였다고 생각합니다. 현재 저는 쿠팡의 광고 서비스를 팀에서 안드로이드 앱 개발자로 일하고 있습니다. 안드로이드 앱 개발이 여전히 주업무 이지만 최근에는 백엔드와 프론트엔드(웹) 분야로도 조금씩 업무를 진행하며 제가 할 수 있는 개발자로서의 역량을 넓혀가는 중입니다. 저는 제가 프로그래머라는 것이 너무 행복하고 감사합니다. 어릴 때 영화를 보면 천재 해커가 나와서 한방에 모든 문제를 해결하고, 마이크로소프트나, 구글같이 소프웨어를 통해 세상의 많은 문제를 해결하고 거대한 성공을 거둔 사람들을 보면서 프로그래머가 정말 멋있다고 생각했던 것 같습니다. 언젠가는 저도 세상을 좀 더 좋게 만드는 개발자가 되는 것이 꿈입니다.","link":"/about/index.html"}],"posts":[{"title":"홈스크린에 뷰 띄우기","text":"안드로이드를 쓰다보면 홈화면에 뷰를 띄우는걸 종종 볼 수 있습니다. 대표적으로 네이버앱의 퀵메뉴나 페이스북 메신저의 챗헤드가 있죠. 퀵메뉴는 네이버앱의 각 메뉴로 바로갈 수 있는 런처 역할을, 챗헤드는 앱으로 진입하지 않고 홈화면에서 바로 대화를 이어갈 수 있도록 해줍니다. 이처럼 홈화면은 사용자가 홈버튼을 누르거나 단말을 켰을때 가장 먼저 보는 기본 화면이기에 접근성이 높아 이를 잘 이용하는 것은 매우 중요합니다. 오늘은 이렇게 홈스크린에 직접 뷰를 띄우는 방법에 대해 공유하려고 합니다. 이 방식은 __윈도우(Window)__를 직접 생성하고 여기에 뷰를 넣는 방식입니다. 안드로이드에서는 홈 화면을 이용할 수 있도록 위젯을 제공하지만 기본으로 제공하는 위젯은 크기와 위치가 제한됩니다. 하지만 이 방법은 위젯과는 달리 위치와 크기를 자유롭게 조절할 수 있기 때문에 활용도가 매우 높습니다. 윈도우란 아까 잠시 언급했듯이 이 방법은 직접 윈도우를 생성하고 뷰를 넣는 방식입니다. 그래서 자세한 방법을 설명하기 전에 윈도우에 대해 간단히 알고 넘어가야합니다. 윈도우는 화면에 UI를 그리기 위한 Surface를 갖습니다. 즉 화면에 뭔가 그려지고 있다는 것은 윈도우가 있는 것입니다. 또한 윈도우는 사용자와의 인터렉션을 위한 키, 터치 이벤트 등을 처리할 수 있는 컴포넌트입니다. 기본적으로 액티비티를 생성하면 액티비티는 윈도우를 갖습니다. 또한 아래 그림과 같이 토스트, 스테이터스 바, 다이얼로그등도 개별적인 윈도우를 가집니다. 토스트, 스테이터스바 다이얼로그 액티비티 윈도우 타입과 이벤트 처리 윈도우의 목적과 종류에 따라 윈도우는 서로 다른 타입을 가집니다. 예를들어 액티비티에 주로 사용되는 타입(TYPE_BASE_APPLICATION)의 윈도우는 키, 터치 이벤트를 받지만 토스트에 사용되는 타입(TYPE_TOAST)의 윈도우는 키, 터치 이벤트를 받지 못합니다. 이러한 이벤트는 윈도우의 타입에 따라 다르고 윈도우 생성 시 플래그를 통해 어느정도 제어가 가능합니다. 우선순위 윈도우의 타입에 따라 우선순위가 달라집니다. 우선순위는 화면에 그려지는 순서를 결정하는데 우선순위가 높을수록 나중에 그려져서 우선순위가 낮은 윈도우를 덮을 수 있습니다. 가령 토스트의 윈도우 타입인 TYPE_TOAST는 액티비티가 사용하는 TYPE_BASE_APPLICATION보다 우선순위가 높기때문에 액티비티에서 토스트를 띄우면 토스트가 액티비티 위에 그려지게 됩니다. 우선순위는 안드로이드 버전에 따라 조금씩 다릅니다. 구현하기 홈스크린에 뷰를 넣는 방법은 아래와 같습니다. 원하는 뷰를 생성한다. 적절한 타입과 속성을 갖는 윈도우 레이아웃 파라미터(WindowManager.LayoutParam)을 생성한다. 윈도우 매니저의 addView(View, ViewGroup.LayoutParams params)을 이용하여 윈도우를 생성한다. 12345678910111213// 1. 뷰 생성ImageView floatingView = new ImageView(this);floatingView.setImageResource(R.drawable.ic_pholar);// 2. 윈도우 레이아웃 파라미터 생성 및 설정mWindowLp = new WindowManager.LayoutParams(WindowManager.LayoutParams.TYPE_PHONE);mWindowLp.width = WindowManager.LayoutParams.WRAP_CONTENT;mWindowLp.height = WindowManager.LayoutParams.WRAP_CONTENT;mWindowLp.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;// 3. 윈도우 생성mWindowManager = (WindowManager) getSystemService(Context.WINDOW_SERVICE);mWindowManager.addView(floatingView, mWindowLp); 홈화면과 일반 액티비티는 윈도우 타입이 TYPE_BASE_APPLICATION 입니다. 반면 위 코드에서 사용한 TYPE_PHONE은 TYPE_BASE_APPLICATION이기 때문에 홈화면이나 액티비티 보다 우선순위가 높아 홈 또는 액티비티 위에 그려집니다. 또한 TYPE_PHONE는 status_bar위로 올라갈 수는 없으며 터치 이벤트를 받을 수 있습니다. TYPE_PHONE은 아래 권한이 필요합니다. android.permission.SYSTEM_ALERT_WINDOW WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE는 현재 윈도우보다 하위 윈도우가 터치 이벤트를 받을 수 있도록 하는 플래그 입니다. 이걸 세팅하지 않으면 생성한 윈도우보다 낮은 순위를 갖는 홈이나 액티비티가 터치 이벤트를 받을 수 없습니다. 마지막에 보면 윈도우 매니저를 통해 윈도우를 생성하고 있습니다. 윈도우는 안드로이드의 윈도우매니저를 통해서 접근이 가능합니다. addView()를 통해 윈도우를 추가하였지만 삭제할때는 removeView()를 하면됩니다. 윈도우의 크기나 위치가 변경 되었다면 updateViewLayout()를 통해 변경사항을 적용해줍니다. 윈도우의 라이프사이클이 생성한 곳에 따라 달라집니다. 액티비티에서 생성하면 액티비티가 종료될때 사라지므로 서비스에서 생성하도록 합니다. 또한 서비스가 종료될때는 윈도우를 제거하도록 처리해주는 것도 중요합니다. 아래 이미지는 위의 코드로 생성한 홈 위젯입니다. 드래깅 구현하기 여기에 퀵메뉴나 챗헤드 처럼 자유롭게 움직일 수 있도록 하고 싶다면 아래와 같이 터치 이벤트를 처리해줍니다. 12345678910111213141516171819202122floatingView.setOnTouchListener(new OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent ev) { switch (ev.getAction()) { case MotionEvent.ACTION_DOWN: mStartingX = ev.getRawX(); mStartingY = ev.getRawY(); mWidgetStartingX = mWindowLp.x; mWidgetStartingY = mWindowLp.y; return false; case MotionEvent.ACTION_MOVE: float deltaX = mStartingX - ev.getRawX(); float deltaY = mStartingY - ev.getRawY(); mWindowLp.x = (int) (mWidgetStartingX - deltaX); mWindowLp.y = (int) (mWidgetStartingY - deltaY); mWindowManager.updateViewLayout(floatingView, mWindowLp); return true; } return false; }}); 이벤트 처리시에 ev.getRawX(), ev.getRawY()를 사용했는데 이렇게 하면 스크린에서의 터치 위치를 가져올 수 있습니다. 이 뷰는 스크린내에서 움직여야 하기때문에 getRawX, getRawY를 사용합니다. 생성 및 제거 애니메이션 처리하기 윈도우가 생성되고 제거될때의 애니메이션은 시스템에서 제공하는 애니메이션만 적용이 가능합니다. 적용하는 방법은 아래와 같이 WindowManager.LayoutParam을 이용합니다. mWindowLp.windowAnimations = android.R.style.Animation_Toast; 생성 및 제거 시 애니메이션만 위와 같은 제약이 있고 뷰나 레이아웃 자체에 주는 애니메이션은 자유롭게 적용이 가능합니다. 그 외 재미있는 것들 스테이터스바 높이 구하기 안드로이드 개발자 페이지에 가면 다른 튜토리얼이나 가이드는 굉장히 잘 되어있는데 이상하게 윈도우에 대한 설명은 매우 적습니다. 그래서 윈도우에 대해 제대로 이해하기가 어려웠는데요. 윈도우에 대해 앞서 설명한 정도의 배경만 알아도 많은 도움이 되는 것 같습니다. 가령 개발을 하다보면 스테이터스 바의 높이를 구하고 싶을때가 있는데요. 스택 오버플로우에서 찾아보면 아래와 같은 코드가 나옵니다. 1234Rect rectangle= new Rect();Window window= getWindow();window.getDecorView().getWindowVisibleDisplayFrame(rectangle);int statusBarHeight= rectangle.top; 처음에는 이 코드를 이해를 못하고 그냥 가져다 썼는데요. 위에 정리한 내용을 보고 다시 보면…먼저 현재 액티비티의 윈도우를 가져오고 윈도우의 Rect를 가져옵니다. 일반적인 윈도우는 스테이터스 바 아래 위치하기 때문에 액티비티 윈도우의 top이 바로 스테이터스바의 높이가 됩니다. 키보드가 올라왔는지 체크하기 또 아래 코드는 키보드가 현재 올라와 있는지를 체크하는 코드입니다. 안드로이드는 키보드가 올라와 있는지 내려가 있는지 알 수 있는 API를 제공해주지 않기 때문에 여러가지 꼼수를 써서 이를 체크해야하는데요. 가장 많이 사용되는 것이 아래의 코드입니다. 12345678910111213141516171819202122contentView.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() { @Override public void onGlobalLayout() { Rect r = new Rect(); contentView.getWindowVisibleDisplayFrame(r); int screenHeight = contentView.getRootView().getHeight(); // r.bottom is the position above soft keypad or device button. // if keypad is shown, the r.bottom is smaller than that before. int keypadHeight = screenHeight - r.bottom; Log.d(TAG, \"keypadHeight = \" + keypadHeight); if (keypadHeight &gt; screenHeight * 0.15) { // 0.15 ratio is perhaps enough to determine keypad height. // keyboard is opened } else { // keyboard is closed } }}); 이것도 앞서 윈도우에 대해 정리한걸 바탕으로 보면 아주 간단합니다. 현재 액티비티 윈도우의 높이를 구하고, 이 높이와 스크린의 높이를 대강 비교해서 액티비티의 높이가 키보드가 올라왔다고 판단할 수 있을만큼 작아졌다면 키보드가 올라왔다고 판단하는 것입니다.(키보드가 올라오면 액티비티의 윈도우는 그만큼 줄어듭니다) 마무리 사실 예전에 네이버 퀵메뉴를 만들때는 온전히 이해하지 못하고 적용을 했었는데 핑퐁을 하면서 정리하다보니 이제서야 오히려 더 이해를 깊게 하게 된것 같습니다. 정리하는 내내 재미있었네요. 윈도우 타입과 속성을 잘 조합하면 재미있는 것들을 많이 해볼 수 있을 것 같습니다.","link":"/2016/04/11/android/android-floating_widget/"},{"title":"안드로이드 ENUM과 Typedef 어노테이션(Annotation)","text":"이 글은 ENUM 사용 시 주의할 점과 어노테이션을 통해 이를 보완할 수 있는 방법에 대해 정리한 글입니다. 주로 참고한 자료는 유튜브 perfmatter 시리즈 중 The price of ENUMs (100 Days of Google Dev) 영상과 Improve Code Inspection with Annotations 문서입니다. 안드로이드 앱 실행 시 메모리 할당 ENUM 사용 시 주의점을 알기 전에 먼저 안드로이드 앱 실행 시 메모리가 어떻게 할당되는지 간단히 짚고 넘어가겠습니다. 앱을 실행시키면 안드로이드는 시스템 메모리 곁에 앱을 위한 메모리를 할당합니다. 이렇게 할당된 메모리는 앱의 코드와 실행중에 동적으로 할당하는 메모리를 위해 사용됩니다. 여기서 앱의 코드는 안드로이드 앱을 빌드할 때 생성되는 DEX 파일입니다. 아래는 The price of ENUMs 영상에서 캡쳐한 이미지입니다. ENUM 사용 시 주의점 ENUM은 앱의 코드(DEX) 크기와 런타임 메모리 사용량을 증가시킵니다. 앱의 DEX 크기가 증가된다는건 APK 파일도 커지고 앱이 실행됐을 때 사용하는 메모리의 양도 그만큼 늘어난다는걸 의미합니다. 또한 ENUM은 Integer나 String에 비해 더 많은 메모리를 런타임에 사용합니다. ENUM은 얼마나 DEX 크기를 더 증가 시킬까? The price of ENUMs (100 Days of Google Dev) 영상을 보면 그 차이를 분명히 알 수 있습니다. 먼저 상수를 아래와 같이 Integer로 선언한 경우, DEX의 크기는 124 bytes가 늘어납니다. 123456789101112131415public static final int VALUE1 = 1;public static final int VALUE2 = 2;public static final int VALUE3 = 3;int func(int value) { switch(value) { case VALUE1: return -1; case VALUE2: return -2; case VALUE3: return -3; } return 0;} 반면에 이를 ENUM으로 선언하면 DEX의 크기는 1,632 bytes가 증가합니다. 무려 13배나 차이가 납니다. 1234567891011121314151617public static enum Value { VALUE1, VALUE2, VALUE3}int func(Value value) { switch(value) { case VALUE1: return -1; case VALUE2: return -2; case VALUE3: return -3; } return 0;} 여기서 바로 ENUM을 사용할 때 왜 주의해야 하는지를 알 수 있습니다. ENUM 사용으로 인한 DEX의 크기가 커지면 앱과 시스템이 사용하는 메모리는 줄어들게 됩니다. ENUM을 사용함으로써 증가하는 메모리의 양은 어찌보면 그리 크지 않다 여길 수 있습니다. 하지만 ENUM을 무심코 사용하다보면 그 크기는 결코 무시할 수 없게 됩니다. 해결방법 첫 번째, Proguard 사용 프로가드를 사용하면 빌드 시 enum을 Integer로 바꾸는 최적화를 수행해 줍니다. 해결방법 두 번째, Typedef 어노테이션 사용 위의 예제처럼 ENUM의 대안으로 간단히 Integer를 사용함으로써 위의 이슈를 피해갈 수 있습니다. 하지만 ENUM이 괜히 있는게 아닙니다. ENUM을 사용하면 컴파일 및 런타임에 타입 및 값을 체크할 수 있습니다. API의 인자나 반환 값에 제약을 줌으로써 API가 오동작을 일으킬 여지를 최대한 줄이는 것은 좋은 코드 작성하는 원칙중에 하나입니다. 하지만 단순히 Integer로 상수를 만들어 사용하는 것 만으로는 이런 제약을 줄 수 없습니다. 하지만 Typedef 어노테이션을 사용하면 컴파일 시에 warning을 통해 이를 미리 확인할 수 있게됩니다. Typedef 어노테이션이란? Typedef 어노테이션은 어노테이션을 통해 특정 값의 유효성을 컴파일 시 확인할 수 있는 기능입니다. 자세한 사용법은 Improve Code Inspection with Annotations 이 곳에서 확인 할 수 있습니다. 여기서는 간단한 예제를 가지고 사용법을 확인해보도록 하겠습니다. 먼저 어노테이션을 사용하기 위해 build.gradle 파일에 서포트 라이브러리를 추가해줍니다. 1dependencies { compile 'com.android.support:support-annotations:24.2.0' } 그리고 아래와 같이 Typedef 어노테이션을 사용합니다. 아래의 예제는 실제 안드로이드 ActionBar 코드 중 일부입니다. 1234567891011121314151617181920import android.support.annotation.IntDef;...public abstract class ActionBar { ... // Define the list of accepted constants and declare the NavigationMode annotation @Retention(RetentionPolicy.SOURCE) @IntDef({NAVIGATION_MODE_STANDARD, NAVIGATION_MODE_LIST, NAVIGATION_MODE_TABS}) public @interface NavigationMode {} // Declare the constants public static final int NAVIGATION_MODE_STANDARD = 0; public static final int NAVIGATION_MODE_LIST = 1; public static final int NAVIGATION_MODE_TABS = 2; // Decorate the target methods with the annotation @NavigationMode public abstract int getNavigationMode(); // Attach the annotation public abstract void setNavigationMode(@NavigationMode int mode); NavigationMode라는 Typedef 어노테이션을 생성합니다. NavigationMode에는 @IntDef를 통해 NAVIGATION_MODE_STANDARD, NAVIGATION_MODE_LIST, NAVIGATION_MODE_TABS 세 가지 값만 들어올 수 있음을 명시하고 있고, 각 상수는 아래 public static final int로 선언이 되어 있습니다. **@Retention(RetentionPolicy.SOURCE)**는 컴파일러가 .clss에 @NavigationMode의 데이터를 저장하지 않도록 합니다. 이제 NavigationMode는 함수의 반환값이나 인자, 객체의 필드에 사용될 수 있습니다. 코드에서 보면 getNavigationMode() 함수의 반환값과 setNavigationMode() 함수의 인자에 @NavigationMode 어노테이션이 붙어있습니다. 이를 통해 getNavigationMode()의 반환값이나 setNavigationMode()의 mode 인자에 NAVIGATION_MODE_STANDARD, NAVIGATION_MODE_LIST, NAVIGATION_MODE_TABS 외의 값이 들어가면 warning이 발생합니다. 이렇게 생성한 Typedef 어노테이션은 안드로이드 스튜디오의 코드 완성에도 적용되어 간편하게 사용할 수 있습니다. @StringDef를 통해 문자열도 동일하게 사용이 가능합니다. Typedef 어노테이션 사용 시 주의점 Typedef 어노테이션을 사용한다 해도 빌드는 정상적으로 수행됩니다. 따라서 반드시 IDE 자체에서 실시간으로 보여주는 warning을 확인하거나, 안드로이드 스튜디오의 Analyze -&gt; Code Infection을 통해 warning을 확인 하는 것이 중요합니다. 마무리 이 글은 ENUM 사용 시 주의할 점을 정리한 글이지만 ENUM을 사용하지 말라는 글은 절대 아닙니다. ENUM이 DEX의 크기를 증가시키는 문제는 있지만 ENUM을 사용하면 코드의 가독성과 타입의 값에 대한 유효성(Type safety)이 좀 더 보장됩니다. 이는 굉장한 장점입니다. 따라서 가독성이나 안정성이 중요시 되는 코드에는 ENUM을 사용하는게 맞습니다. 비슷한 예로 C언어의 매크로 함수가 있습니다. 매크로 함수는 함수처럼 사용할 수 있지만 컴파일 시에 직접 코드로 치환되어 실행파일에 삽입됩니다. 따라서 매크로 함수를 사용하면 함수 호출의 부하를 줄일 수 있습니다. 하지만 매크로 함수도 잘 못 사용하면 오히려 성능을 저하시킵니다. 가령 코드의 너무 많은 곳에서 매크로 함수를 호출하게되면 호출 부에 모두 코드로 치환되기 때문에 코드 영역의 크기가 매우 커질 수 있습니다. 즉 경우에 따라 오히려 성능을 떨어뜨릴 수 있습니다. ENUM과 Typedef 어노테이션 역시 비슷합니다. 각각의 장단점을 보고 필요한 곳에 잘 사용하는 것이 중요합니다. 또한 Proguard를 사용하면 위의 최적화를 대부분 알아서 수행해 줍니다. 어찌보면 굳이 Typedef 어노테이션을 사용할 필요가 없을지도 모릅니다. 이런 관점에서보면 안드로이드 플랫폼 코드에 Typedef 어노테이션을 권장하는 이유를 알 수 있습니다. 안드로이드 플랫폼 코드는 프로가드를 적용하지 않고, 전체 코드의 크기가 굉장히 크기 때문에 ENUM의 사용을 제한하지 않으면 플랫폼 코드가 대책없이 커질 수 있으니 딱 Typedef 어노테이션을 사용하기 좋은 곳이겠죠. 참고 자료 The price of ENUMs (100 Days of Google Dev) Perfmatter 시리즈 영상 중 ENUM 사용 시 주의점에 대해 설명하는 영상입니다. Improve Code Inspection with Annotations 구글 개발자 페이지 문서입니다. 어노테이션을 이용해서 빌드 시 코드의 잠재적인 이슈를 미리 확인하는 방법을 다룹니다.","link":"/2017/10/08/android/android-enum-intdef/"},{"title":"rememberUpdatedState 이해하기","text":"Jetpack Compose를 사용하다 보면 상태(State)와 재구성(Recomposition)에 대해 자주 마주하게 됩니다. rememberUpdatedState는 이러한 상태 관리에서 중요한 역할을 합니다. 공식 문서에 나와 있는 설명을 보면 다음과 같습니다. reference a value in an effect that shouldn’t restart if the value changes 저는 이 설명이 처음에 잘 이해되지 않았습니다. 그래서 rememberUpdatedState를 이해하기 위해 정리 겸 이 글을 쓰게 되었습니다. 이 글이 다른 사람에게 도움이 되기를 바랍니다. 예시 코드 다음은 rememberUpdatedState를 설명하기 위해 공식 문서에서 사용된 샘플 코드입니다. LandingScreen 컴포저블은 최초 생성 후 일정 시간(SplashWaitTimeMillis)이 지나면 onTimeout 함수를 호출하는 역할을 합니다. 중요한 요구사항은 LandingScreen이 재구성 되더라도 딜레이는 늘어나면 안 된다는 점입니다. 12345678910111213141516@Composablefun LandingScreen(onTimeout: () -&gt; Unit) { // This will always refer to the latest onTimeout function that // LandingScreen was recomposed with val currentOnTimeout by rememberUpdatedState(onTimeout) // Create an effect that matches the lifecycle of LandingScreen. // If LandingScreen recomposes, the delay shouldn't start again. LaunchedEffect(true) { delay(SplashWaitTimeMillis) currentOnTimeout() } /* Landing screen content */} 위 코드에서 rememberUpdatedState의 역할은 무엇일까요? rememberUpdatedState를 사용하지 않고 onTimeout을 LaunchedEffect에서 사용하면 어떻게 될까요? rememberUpdatedState 없이 사용하는 경우 LaunchedEffect는 키가 true 로 설정되어 한번만 실행됩니다. 하지만 LandingScreen은 onTimeout 이 변경될 때마다 재구성됩니다. 이때 LaunchedEffect는 처음 실행될 때 캡쳐한 onTimeout을 사용하기 때문에, LandingScreen의 onTimeout이 변경되어 재구성된 후에도 처음 받은 onTimeout을 호출하게 됩니다. 123456789@Composablefun LandingScreen(onTimeout: () -&gt; Unit) { LaunchedEffect(true) { delay(SplashWaitTimeMillis) onTimeout() // 변경된 onTimeout이 아니라 처음 캡처된 onTimeout이 호출됨 } /* Landing screen content */} LaunchedEffect의 키로 onTimeout을 사용하는 경우 LaunchedEffect의 키로 onTimeout을 사용하면, onTimeout이 변경될 때마다 LaunchedEffect가 재실행됩니다. 이렇게 하면 항상 최신의 onTimeout이 호출되지만, LaunchedEffect가 재실행될 때마다 delay(SplashWaitTimeMillis)도 다시 시작되므로 딜레이 시간이 길어질 수 있습니다. 123456789@Composablefun LandingScreen(onTimeout: () -&gt; Unit) { LaunchedEffect(onTimeout) { delay(SplashWaitTimeMillis) onTimeout() // 항상 최신 onTimeout이 호출됨 } /* Landing screen content */} rememberUpdatedState의 역할 rememberUpdatedState를 사용하면 LaunchedEffect가 재실행되지 않으면서도 항상 최신의 onTimeout을 참조할 수 있습니다. 이는 LaunchedEffect가 재실행되지 않아 딜레이 시간이 유지되면서도, 최신 상태를 유지할 수 있게 합니다. 이제 아래의 rememberUpdatedState에 대한 공식 문서의 한줄 설명이 이해가 되시나요? reference a value in an effect that shouldn’t restart if the value changes 혹시 이 글이 다소 이해가 되지 않는다면 람다와 클로저, 그리고 이펙트에 대해 다시 학습해보면 도움이 되리라 생각합니다. 구현 보기 마지막으로 rememberUpdatedState의 구현을 코드로 살펴봅시다. rememberUpdatedState는 아래와 같이 구현되어 있습니다. remember에서 mutableStateOf(newValue)를 통해 newValue를 값으로 갖는 State를 반환 합니다. 따라서 이렇게 반환된 State는 리컴포지션이 발생하더라도 변경되지 않고 캐싱됩니다. 123fun &lt;T&gt; rememberUpdatedState(newValue: T): State&lt;T&gt; = remember { mutableStateOf(newValue)}.apply { value = newValue } 그리고 바로 apply { value = newValue }를 통해 상태를 최신 값인 newValue로 업데이트 합니다. 즉 이 구현은 상태 객체 자체는 유지하면서 값만 최신으로 업데이트하는 역할을 합니다. 이를 통해 최신 값을 항상 참조할 수 있습니다.","link":"/2024/06/19/android/rememberUpdatedState/"},{"title":"뷰페이저(ViewPager)","text":"ViewPager는 좌우 스와이핑 제스처를 통해 뷰를 전환하는 레이아웃관리자로 볼 수 있다. 뷰페이저의 페이지는 전환될 레이아웃을 말하기 때문에 당연히 뷰도 될 수 있고 뷰그룹도 될 수 있다. 보통 가장많이 쓰이는건 프래그먼트와 함께 많이 쓰이게 된다. 특징 뷰페이저는 항상 현재 위치의 좌우 아이템을 미리 로드한다. 즉 현재 3번 페이지를 보여주고 있다면 이미 2, 4번 페이지에 대한 getItem이 호출된다. 0번에 있다면 우측의 1번 페이지까지 해서 2개가 로드된다. 그리고 현재 위치를 기준으로 좌우에 있는 페이지까지만 유지하고 그 밖에 있는 것들은 버린다. 뷰페이저의 현재 아이템 가져오기 뷰페이저는 페이지들의 전환을 쉽게 해준다. 당연히 뷰페이저를 통해 UX를 구성할때는 현재 페이지를 가져와서 원하는 작업을 하고 싶은 경우가 많다. 그래서 당연히 뷰페이저나 뷰페이저어댑터를 통해 현재 페이지를 가져올 수 있는 API가 있을 것 같다. 그…그런데…없다…그런거…-_-; 만들어야한다. 참고자료 stackOverFlow… 어떻게 할까 한 10초 고민하다가 바로 android viewpager get current fragment로 구글링을 해보니 바로 어떤 똘똘한 아저씨가 친절하게 해결책을 올려주셨다. 요새는 검색하면 어지간한 문제는 다 해결이 되는데 그만큼 내 머리를 쓸일은 적어지는 것 같다. 쩝… 아이디어는 간단하다. 프래그먼트가 생성되면 리스트에 담는다 프래그먼트가 소멸되면 리스트에서 버린다 필요할때마다 리스트에서 꺼낸다 주의점은 아까 특징에서 언급했듯이 뷰페이저는 현재 위치를 기준으로 좌우의 페이지까지만 가지고 있는다. 즉 현재 위치나 내 좌우 페이지가 아닌 위치의 페이지를 가져오려고 하면 오류가 발생한다. 이정도 개념을 머리에 두고 아래 코드를 보면 바로 이해가 갈 것 같다. 12345678910111213141516171819202122232425262728293031323334public class MyPagerAdapter extends FragmentStatePagerAdapter { SparseArray&lt;Fragment&gt; registeredFragments = new SparseArray&lt;Fragment&gt;(); public MyPagerAdapter(FragmentManager fm) { super(fm); } @Override public int getCount() { return ...; } @Override public Fragment getItem(int position) { return MyFragment.newInstance(...); } @Override public Object instantiateItem(ViewGroup container, int position) { Fragment fragment = (Fragment) super.instantiateItem(container, position); registeredFragments.put(position, fragment); return fragment; } @Override public void destroyItem(ViewGroup container, int position, Object object) { registeredFragments.remove(position); super.destroyItem(container, position, object); } public Fragment getRegisteredFragment(int position) { return registeredFragments.get(position); }} 위 코드는 아까 위에서 링크를 걸어뒀던 스택오버플로우에 있는 코드이다. 코드를 보면 아래와 같다. 프래그먼트가 생성되면 리스트에 담는다 instantiateItem() 프래그먼트가 소멸되면 리스트에서 버린다 destroyItem() 필요할때마다 리스트에서 꺼낸다 getRegisteredFragment() 실제 사용할때는 아래와 같이 사용하게 될 것 같다. 12345678910111213141516171819202122232425262728293031323334353637public class Example { int mCurrentPosition; ViewPager mViewPager; MyPagerAdapter mAdapter; ...... private void initViewPager() { mViewPager = ...; mAdapter = new MyPagerAdapter(......); mViewPager.setAdapter(mAdapter); mViewPager.setOnPageChangeListener(new ViewPager.OnPageChangeListener() { @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) { } @Override public void onPageSelected(int position) { mCurrentPosition = position; } @Override public void onPageScrollStateChanged(int state) { } }); } private void doSomethingWithCurrentFragment() { Fragment fragment = mAdapter.getRegisteredFragment(mCurrentPosition); if (fragment == null) { return; } // do something with current fragment.. }} 먼저 뷰페이저의 현재 위치를 알기 위해 onPageChangeListener를 뷰페이저에 달아준다. 이 리스너의 onPageSelected는 뷰페이저의 페이지가 바뀔때마다 호출된다. 이걸 통해 현재 뷰패이저의 위치를 가지고 있다가 필요할 때 뷰페이저어댑터를 통해 현재 프래그먼트를 가져온다. 끝!!!","link":"/2015/12/30/android/android-get-current-fragment/"},{"title":"안드로이드의 프로세스, 쓰레드 이해하기","text":"안드로이드 앱을 사용해봤거나 개발해봤다면 누구나 한번씩은 ANR 다이얼로그나 버벅거림, 혹은 크래시로 앱이 비정상 종료되는 상황을 겪어봤을 겁니다. 이런 현상들은 사용자에게 안좋은 경험을 주고 심한 경우 앱을 지워버리게 만드는 요인이 되기도 합니다. 반대로 빠르고 부드러운 앱은 사용자에게 좋은 인상을 줍니다. 그렇다면 빠르고 크래시 없는 앱을 개발하기 위해서는 어떻게 해야할까요? 여러가지가 있겠지만 가장 중요한 것 중 하나는 안드로이드의 프로세스와 쓰레드를 잘 이해하고, 올바르게 다루는 것일 겁니다. 이번 글에서는 안드로이드의 프로세스와 쓰레드의 개념에 대해 정리하고 이를 다룰 때 주의할 점에 대해 다루도록 하겠습니다. 1. 안드로이드 앱의 실행과 프로세스 안드로이드는 리눅스 기반의 OS입니다. 리눅스 커널위에 라이브러리와 런타임이 있고 그 위에 어플리케이션 프레임워크가 존재합니다. 안드로이드 앱 개발자는 어플리케이션 프레임워크에서 제공하는 컴포넌트와 이를 사용하기 위한 API를 이용해서 안드로이드 앱을 개발합니다. 안드로이드 앱은 앱 컴포넌트를 통해 실행됩니다. 앱 컴포넌트는 액티비티, 서비스, 컨텐츠 프로바이더, 브로드캐스트 리시버 이렇게 네 가지입니다. 앱 컴포넌트 중 하나를 실행 시켰는데 이미 실행 중인 컴포넌트가 있으면 안드로이드 시스템은 해당 컴포넌트를 기존 프로세스 내에서 실행 시키고, 없는 경우 새 리눅스 프로세스를 생성하고 여기서 컴포넌트를 실행 시킵니다. 1.1. 앱의 실행 경로 가장 기본적인 실행 경로는 안드로이드 런쳐, 즉 홈 화면이나 앱 메뉴에서 앱 아이콘을 클릭해서 실행 시키는 방법이 있습니다. 이 경우 앱은 AndroidManifest.xml에 정의한 런쳐 액티비티를 실행합니다. 이 방식은 앱 컴포넌트 중 액티비티를 통해 앱이 실행되는 경우입니다. 두 번째로 앱에서 알람을 등록했다고 합시다. 지정한 시간이 되면 알람을 받는 앱의 브로드캐스트 리시버가 호출이 됩니다. 이 경우는 브로트캐스트 리시버를 통해 앱이 실행되는 케이스입니다. 같은 방식으로 서비스, 컨텐츠 프로바이더를 통해 동일하게 앱이 실행되는 시나리오가 있을 수 있습니다. 1.2. 프로세스와 메인 쓰레드 위에 설명한 실행 경로를 통해 앱이 실행되면 하나의 리눅스 프로세스가 생성되고 프로세스 안에는 하나의 쓰레드가 기본으로 생성됩니다. 이 쓰레드가 바로 메인 쓰레드입니다. 메인 쓰레드는 아주 중요하기 때문에 어떤 일을 하고 어떻게 동작하는지 잘 이해해야 좋은 앱을 만들 수 있습니다. 먼저 앱의 네 가지 컴포넌트는 메인 쓰레드에서 실행됩니다. 따라서 앱 컴포넌트 중 하나인 액티비티의 라이프사이클 관련 콜백이나, 브로드캐스트 리시버의 onReceive()등도 모두 메인 쓰레드에서 실행됩니다. 두 번째로 UI 위젯을 통한 사용자 이벤트와 드로잉 이벤트가 메인 쓰레드에서 실행됩니다. 즉 안드로이드 UI toolkit에 있는 android.widget, android.view의 사용자 이벤트 처리나 드로잉 관련 메소드가 여기 해당됩니다. 조금 이해가 가지 않는 다면, onClick, onKeyDown, onDraw 같은 콜백들을 생각하면 됩니다. 이렇게 사용자 이벤트와 드로잉 이벤트가 메인 쓰레드에서 처리되기 때문에 메인 쓰레드를 UI 쓰레드라고도 합니다. 하지만 엄밀히 말하면 둘은 서로 같은게 아닙니다. 메인 쓰레드가 UI 쓰레드를 포함 하는 개념으로 보시는게 좋습니다. 1.3. 부드러운 UI 개발을 위해 알아야 하는 것 앱개발을 좀 해봤다면 메인쓰레드 내에서 16ms 이상 걸리는 작업을 하면 안된다는 얘기를 많이 들어보셨을 겁니다. 우리가 보는 화면의 움직임은 결국 프레임의 연속입니다. 조금씩 변하는 프레임이 연속으로 빠르게 이어지면 사람의 뇌는 이걸 움직임으로 인식합니다. 이 프레임이 너무 낮거나 불규칙하게 이어지면 사용자는 UI가 부드럽지 않다고 느끼게 됩니다. 안드로이드는 초당 60 프레임, 즉 60fps을 유지하도록 권장합니다. 60fps가 사람이 인지할 수 있는 선에서 가장 부드러운 수치이기 때문입니다. 1초는 1000ms 이기 때문에 60fps를 달성하려면 1000/60, 즉 프레임이 16ms당 한번씩 새로 그려질 수 있어야 60fps가 유지됩니다. 이에 대한 이야기는 아래 유튜브 영상에서 보실 수 있습니다. PerfMatter Why 60fps 여기서 이제 가장 중요한 개념이 등장합니다. 앞서 메인 쓰레드는 UI 업데이트 즉 드로잉 작업도 처리한다고 언급하였습니다. 그래서 메인 쓰레드를 UI 쓰레드라고 부르기도 한다고 했죠. 즉 이 메인 쓰레드에서 16ms 이상 걸리는 작업을 하면 메인 쓰레드는 16ms 간격으로 프레임을 업데이트 할 수 없게 됩니다. 즉 프레임 드랍이 일어납니다. 우리가 리사이클러뷰에서 스크롤을 하거나 화면에 애니메이션이 그려지고 있는 도중에 이런 프레임 드랍이 생기면 화면이 뚝뚝 끊기겠죠? 이러한 화면 끊김을 안드로이드에서는 Jank 라고도 부릅니다. 결국 부드러운 UI 개발을 위해 가장 중요한 것은 메인쓰레드에서는 16ms 이상 걸리는 작업은 하지 않는 것이라고도 볼 수 있습니다. 1.4. 워커 쓰레드(백그라운드 쓰레드) 앞에서 설명한 대로 메인쓰레드는 사용자 이벤트와 드로잉 이벤트를 처리하기 위해 사용되기 때문에 메인 쓰레드에서 시간이 오래걸리는 작업을 하는것은 금물입니다. 좀 더 엄밀히 말하면 16ms을 넘기지 않는게 좋습니다. 그럼 시간이 오래 걸리는 작업들은 어떻게 처리해야 할까요? 답은 간단합니다. 다른 쓰레드를 만들어서 메인 쓰레드가 아닌 곳에서 작업을 처리하면 됩니다. 이렇게 시간이 오래 걸리는 작업을 처리하기 위해 생성한 쓰레드를 워커 쓰레드 또는 백그라운드 쓰레드라고 부릅니다. 자바에서는 쓰레드를 생성하기 위해 Runnable과 Thread, Executors 클래스를 제공합니다. 이것들을 이용해서 시간이 오래 걸리는 작업을 처리해도 되고 안드로이드에서 편의를 위해 제공하는 AsyncTask, AsyncTaskLoader, ThreadHandler, ThreadPoolExecutor 등을 사용할 수도 있습니다. 1.5. 워커 쓰레드의 기본적인 사용 패턴 기본적으로 16ms 이상 걸릴 수 있는 무거운 일들은 메인 쓰레드에서 처리하면 안됩니다. 따라서 이러한 작업들은 보통 위에서 언급한 다양한 클래스를 이용해 워커 쓰레드를 생성하고 여기서 처리합니다. 또한 메인 쓰레드는 쓰레드 세이프 하지 않습니다. 따라서 메인 쓰레드가 아닌 워커 쓰레드에서 UI를 조작하면 정상적으로 반영이 되지 않을 수 있고 비정상적인 동작을 초래할 수 있습니다. 그런데 워커 쓰레드에서 작업을 하고 이를 UI에 업데이트 하려면 어떻게 해야할까요? 워커 쓰레드에서 시간이 오래걸리는 작업을 하고 그 결과를 UI에 반영해서 사용자에게 결과를 보여주는 것은 앱 개발에서 가장 많이 보이는 패턴중에 하나입니다. 서버에 데이터를 요청하고 이를 화면에 보여주거나 이미지를 가공해서 이를 사용자에게 보여주는 경우 등, 사실 대부분의 경우 워커 쓰레드는 UI 업데이트를 동반하는 경우가 많습니다. 이를 위해 워커 쓰레드와 메인 쓰레드 간에 통신하는 가장 기본적인 방법은 핸들러(Handler)를 이용하는 방법입니다. 두 번째로, 안드로이드는 이를 좀 더 간편하게 할 수 있도록 AsyncTask라는 유틸 클래스를 제공합니다. AsysncTask는 워커 쓰레드에서 처리할 일을 doInBackground()에 작성하고 진행 사항이나 결과를 UI에 반영 하는 코드는 onProgressUpdate(), onPostExecute()에 작성하여 메인 쓰레드에서 이를 간편히 실행 시킬 수 있습니다. 이 외에도 액티비티의 runOnUiThread(), 뷰의 post(), postDelayed()를 이용할 수도 있습니다. 2. 메인 쓰레드와 워커 쓰레드를 잘못 다루었을 때 생길 수 있는 일들 2.1. ANR(Application Not Responding) 메인 쓰레드는 이름처럼 아주 중요합니다. 앞서 말했던 것처럼 사용자 이벤트와 드로잉 이벤트를 처리하기 때문이죠. 때문에 메인 쓰레드에서 시간이 오래 걸리는 작업을 하면 그만큼 메인 쓰레드는 사용자 이벤트와 드로잉 이벤트를 처리할 수 없게 됩니다. 즉 메인 쓰레드 내에서 시간이 오래 걸리는 작업을 하게 되면 사용자가 앱의 버튼을 클릭하거나 키보드 입력도 할 수 없고, 앱의 UI도 업데이트가 되지 않아 멈춘 것처럼 보이게 됩니다. 이것이 바로 ANR입니다. 그럼 ANR을 한번 직접 만들어볼까요? 아주 간단합니다. onClick()과 같은 사용자 인풋 이벤트는 메인 쓰레드에서 실행된다고 언급하였습니다. 그럼 여기서 5초 이상 걸리는 작업을 하도록 하면 바로 ANR을 발생 시킬수 있겠죠? 1234567891011class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) button.setOnClickListener { Thread.sleep(10000) } }} 안드로이드 시스템은 안드로이드 버전에 따라 다르지만 약 5초 이상 UI 쓰레드가 차단되면 ANR 대화 상자를 띄움으로써 사용자가 앱을 강제로 종료할 수 있게합니다. 2.2 워커 쓰레드와 UI 처리 앱 개발을 하다보면 워커 쓰레드의 작업 결과를 메인 쓰레드에서 UI에 반영하는 경우가 많은데 이 때 자주 하는 실수가 있습니다. 하나는 워커 쓰레드에서 작업을 끝내고 이를 UI에 반영할 때 해당하는 View가 View hierachy에서 제거 되었거나 객체 자체가 삭제 되었을 수 있습니다. 안드로이드에선 네트워크 호출은 워커 쓰레드에서 호출하도록 하고 있는데 서버로 API 호출을 한 후 이 응답값을 이용해서 UI를 수정하는 경우 흔히 발생 할 수 있는 경우입니다. 좀 더 구체적인 예를 들면 액티비티 위에 프레그먼트가 있고 여기서 네트워크 콜을 합니다. 이후 네트워크 응답이 오기 전에 사용자가 백키를 눌러서 프레그먼트를 프레그먼트 스택에서 제거합니다. 이렇게 되면 프레그먼트는 액티비티의 View hierachy에서 제거 됩니다. 이제 네트워크 응답이 오고 액티비티의 View hierachy에서 제거된 프레그먼트의 UI를 수정합니다. 생각해보면 특별한 경우가 아니고 앱 개발 시 굉장히 자주 있는 시나리오입니다. 두 번째는 워커 쓰레드에서 액티비티의 레퍼런스를 갖고 있는 경우 입니다. 이렇게 되면 해당 액티비티는 워커 쓰레드가 종료될 때까지 가비지 컬렉터에 의해 제거 될 수 없습니다. 워커 쓰레드가 종료되기 전에 configuration change 이벤트가 발생하거나 하면 동일한 액티비티가 여러개 생길 수도 있는 상황이 발생합니다. 워커 쓰레드에서 액티비티의 레퍼런스를 직접 갖고 있지 않은 경우에도 문제가 생길 수 있습니다. 액티비티에 내부 클래스로 AsyncTask를 선언하고 사용하는 경우입니다. 내부 클래스는 외부 클래스에 대한 암시적 참조를 갖기 때문에 위의 상황처럼 AsyncTask가 종료 될 때가지 액티비티는 가비지 컬렉터에 의해 제거되지 않습니다. 여기서 암시적 참조라는 말이 조금 어렵게 느껴질 수 있는데, 내부 클래스는 외부 클래스의 멤버 변수를 참조 할 수 있습니다. 어떻게 이게 가능할까요? 직접 내부 클래스에 외부 클래스의 레퍼런스를 참조하는 코드를 작성하지 않더라도 자바는 내부 클래스에 대한 참조를 생성하기 때문입니다. 이것을 바로 암시적 참조라고 합니다. 아래 예제 코드는 암시적 참조에 의한 메모리 릭의 예를 보여줍니다. 아래 코드에서, doInBackground()에서 어떤 작업을 하고 있는 동안은 MyActivity는 메모리에 계속 남아있게 됩니다. 또한 화면 방향 전환이나 단말의 언어설정 변경 등에 의해 액티비티가 재시작이 되면 동일한 액티비티가 여러 개 생성될 수도 있으며, 액티비티가 종료된 후에 onPostExecute()에서 유효하지 않은 액티비티내의 객체나 UI 요소에 대한 상태를 변경하면 예기치 못한 동작이 발생할 수 있습니다. 123456789101112131415161718192021222324252627282930313233343536public class MyActivity extends AppCompatActivity { private TextView mText; @Override public void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mText = findViewById(R.id.text); new MyAsyncTask().execute(); } class MyAsyncTask extends AsyncTask&lt;Void, Void, String&gt; { @Override protected void onPreExecute() { mText.setText(\"MyAsyncTask.onPreExecute()\"); } @Override protected String doInBackground(Void... voids) { try { Thread.sleep(50000); } catch (InterruptedException e) { e.printStackTrace(); } return \"MyAsyncTask.doInBackground() is finished\"; } @Override protected void onPostExecute(String s) { mText.setText(s); } }} 마지막으로 안드로이드 개발을 시작한지 얼마 안된 사람들이 쉽게 착각하는 것 중 하나는 액티비티와 쓰레드의 생명주기가 동일하다고 착각하는 것입니다. 하지만 액티비티의 생명주기와 쓰레드의 생명주기는 관계가 없습니다. 쓰레드가 특정 액티비티에서 생성이 되고 해당 액티비티가 종료되어도 이 쓰레드는 이와 상관없이 실행됩니다. 이를 제대로 이해하지 못하면 첫 번째로 언급한 이슈가 발생하기 쉽습니다. 이런 실수를 하게되면 결국 앱은 비정상 종료를 하게 됩니다. 3. 마무리 이번 포스팅에서는 안드로이드의 프로세스와 쓰레드에 대해 개념적인 내용들을 정리해 보았습니다. 이를 정리하자면 아래와 같습니다. 메인 쓰레드는 사용자 이벤트, 드로잉 이벤트 등을 처리하는 매우 중요한 쓰레드이며 여기서 시간이 오래 걸리는 일을 하면 앱이 끊기거나 먹통이 될 수 있다. 1과 같은 이유로 많은 시간이 걸리는 작업은 새로 쓰레드를 만들어서 처리해주어야 하며 이를 워커 쓰레드라 부른다. 사람이 느낄 수 있는 가장 부드러운 수치는 60fps 정도 이기 때문에 안드로이드에서도 앱 개발 시 60fps를 유지하도록 권장한다. 이를 위해 메인 쓰레드에서는 16ms 이상 걸리는 작업을 하지 않는다. 워커 쓰레드에 액티비티나 View의 레퍼런스를 갖는 것은 메모리 릭과 앱의 비정상 종료를 일으킬 수 있기 때문에 매우 위험하다. 개인적으로 안드로이드 앱 개발 시 가장 중요하다고 생각하는 부분이기도 합니다. 다음에는 좀 더 구체적으로 쓰레드에 대해 자세히 알아보고 상황에 따라 어떤 방식으로 쓰레드를 사용해야 하는지 다뤄보도록 하겠습니다. 참고자료 ANRs Crashes Platform architecture App components Process and thread Perfmatter - Understanding Android Threading Slow rendering","link":"/2018/06/28/android/android-process-thread/"},{"title":"안드로이드 그래들 빌드 속도 올리기","text":"이 글은 2017년 5월 구글I/O의 Speeding Up Your Android Gradle Builds (Google I/O '17 세션 중 일부를 정리한 내용입니다. 발표 영상, 슬라이드는 맨 아래 참고 링크에서 확인 할 수 있습니다. 발표자는 안드로이드 스튜디오 팀의 James Lau 입니다. 영상을 보면, 산타트래커란 샘플 프로젝트에 하나씩 최적화를 적용하면서 어느정도 최적화가 되었는지 보여주는 방식으로 진행됩니다. 빌드속도는 당연히 프로젝트의 구성과 환경에 영향을 받습니다. 발표자가 테스트에 사용한 산타트래커는 아래와 같이 구성되었습니다. 안드로이드 웨어를 포함한 9개의 모듈 500개의 자바 파일 1700개의 xml 3500개의 PNG 멀티덱스 60MB 정도의 apk를 크기 어노테이션프로세서는 사용치 않음 벤치마크는 아래 세 가지 경우로 보여줍니다. incremental build는 구글 개발자 페이지에 증분 빌드로 번역하고 있어서 그대로 사용했습니다. 참고 링크 전체 빌드(Full build) Clean, assemble debug 증분 빌드(Incremental build - Java change) 한 메소드 안에 한줄의 자바코드 수정 증분 빌드(Incremental build - resource changing) 스트링 리소스 한 개를 추가하거나 제거 빠른 빌드를 위한 10가지 팁 세션에서 소개된 팁은 총 10개로 아래 목차와 같습니다. 최신 안드로이드 그래들 플러그인을 쓸 것 Use lastest Android Gradle Plugin 레거시 멀티덱스를 피할 것 Avoid legacy multidex 멀티 APK를 사용하지 말 것 Disable multi-APK 최소한의 리소스만 포함 시킬 것 Include minimal resources PNG 최적화 설정을 사용하지 말 것 Disable PNG crunching 인스턴트 런을 사용할 것 User Instant Run 의도치 않은 수정은 피할 것 Avoid inadvertent changes 다이나믹 버전은 사용하지 말 것 Don’t use dynamic version 메모리를 확인할 것 Watch the memory 그래들 캐시를 사용할 것 Use Gradle Cache 1. 최신 안드로이드 그래들 플러그인을 쓸 것 안드로이드 스튜디오 팀에서는 빌드 속도와 버그수정을 위해 그래들 플러그인을 계속 업데이트 하고 있습니다. 그래들 3.0부터는 구글 메이븐 저장소를 통해 그래들이 배포됩니다. 따라서 메이븐 구글 저장소를 추가해주고, dependency에 gradle 3.0.0을 추가해줍니다. 발표 영상에는 alpha1인데 오늘(2017.09.20일) 확인해본 바로는 beta4까지 나왔네요. 123456789buildscript { repository { jcenter() maven { url 'https://maven.google.com' } } dependency { classpath 'com.android.tools.build:gradle:3.0.0-alpha1' }} 결과를 보니 단순히 그래들 버전을 3.x대로 올리는 것만으로 속도가 아래와 같이 엄청나게 향상됩니다. 아래 결과는 발표자 영상에 있는걸 그대로 옮긴거구요, 대강 어느정도 향상되는지 참고 하시면 될 것 같습니다. 빌드 타입 | 속도 차이(초) | 속도 차이(백분율) — | — | 전체 빌드 | -15s | -25% 증분 빌드(자바) | -10s | -38% 증분 빌드(리소스) | -2.5s | -16% 2. 레거시 멀티덱스를 피할 것 멀티덱스 사용 시 minSdkVersion &lt; 21인 경우 레거시 멀티덱스가 적용됩니다. 그리고 이 레거시 멀티덱스는 빌드 속도를 심각하게 다운 시킵니다. 안드로이드 스튜디오 2.3+에서부터는 런 버튼을 클릭해서 앱을 실행하면, 연결된 디바이스나 에물레이터의 API 버전을 감지해서 가능하면 네이티브 멀티덱스를 적용해준다고 합니다. 참고로 커맨드라인으로 빌드하는 경우엔 이렇게 자동으로 버전을 감지해서 최적화 해주는 기능은 동작하지 않습니다. 만약 프로덕트가 api 레벨 21 미만의 단말도 지원해야 한다면 아래와 같이 빌드 변형 구성을 이용해 개발 용 빌드의 minSdkVersion을 21로 설정할 수 있습니다. 1234567productFlavors { development { minSdkVersion 21 ... }} 결과는 아래와 같습니다. 이것도 성능 향상이 꽤 크네요. 빌드 타입 | 속도 차이(초) | 속도 차이(백분율) — | — | 전체 빌드 | -5.5s | -12% 증분 빌드(자바) | -8s | -53% 증분 빌드(리소스) | same | same 3. 멀티 APK를 사용하지 말 것 멀티 APK는 ABI나 density에 따라 apk를 다르게 빌드하는 기능입니다. 한 프로젝트에 대해 여러 APK가 생성되지만, 각 빌드의 결과물로 나오는 APK 크기가 작아지는 장점이 있습니다. 하지만 개발환경에선 필요없는 기능이죠. 따라서 개발 용 빌드인 경우에는 멀티 APK 기능을 아래와 같이 꺼줍니다. 123456android { if (project.hasProperty('devBuild')) { splits.abi.enable = false splits.density.enable = false }} 위의 그래들 빌드 스크립트를 보면 'devBuild’란 속성을 확인하는데 저 속성은 커맨드라인 빌드 시 아래와 같이 넘겨줍니다. 1./gradlew santa-tracker:assembleDevelopmentDebug -PdevBuild 이걸 안드로이드 스튜디오에 적용한다면 preference -&gt; Build, Execution, Deployment -&gt; Compiler -&gt; Command-line Option 에 -PdevBuild을 적어주면 됩니다. 결과는 아래와 같습니다. 리소스에 대한 증분 빌드 시에 많은 속도 향상이 있네요. 빌드 타입 | 속도 차이(초) | 속도 차이(백분율) — | — | 전체 빌드 | -4.8s | -12% 증분 빌드(자바) | -0.5s | -6% 증분 빌드(리소스) | -3s | -26% 4. 최소한의 리소스만 포함시킬 것 앱이 다국어를 지원한다면 여러 스트링 리소스를 포함합니다. 다국어를 지원하지 않더라도 대부분의 앱은 하나 이상의 스크린 density를 지원하는 경우가 많습니다. 안드로이드의 빌드 시 기본 설정은 모든 버전의 리소스를 빌드에 포함시키도록 되어있습니다. 하지만 아래와 같이 특정 버전의 리소스들만 포함시키도록 할 수 있습니다. 아래는 개발용 빌드에 특정 리소스만 포함 시키도록 하는 그래들 설정 예시입니다. 1234567productFlavor { developement { minSdkVersion 21 resConfigs (\"en\", \"xxhdpi\") ... }} 적용 결과입니다. 빌드 타입 | 속도 차이(초) | 속도 차이(백분율) — | — | 전체 빌드 | -6s | -17% 증분 빌드(자바) | -1.5s | -24% 증분 빌드(리소스) | -2s | -21% 5. 개발 빌드에는 PNG 최적화를 끄자 안드로이드 빌드 툴은 PNG 크기 최적화를 기본으로 수행합니다. 최적화라면 PNG 파일들을 압축하는 거겠죠. 당연히 PNG 파일이 많으면 빌드 시 많은 시스템 자원을 사용하게 됩니다. 릴리즈 시에는 APK 크기를 줄여주므로 중요한 기능이지만 개발 시에는 별 필요 없는 기능입니다. 역시나 아래와 같이 그래들 빌드 스크립트를 이용해 설정을 살포시 꺼줍니다. 12345678productFlavor { developement { minSdkVersion 21 resConfigs (\"en\", \"xxhdpi\") aaptOptions.cruncherEnabled = false ... }} 아니면 아예 webP 포맷을 사용하는 것도 좋은 방법입니다. webP는 PNG 파일보다 최대 25% 작은 크기를 갖는 포맷입니다. 안드로이드 스튜디오 2.3+ 부터는 IDE에서 PNG를 webP로 변환하는 기능을 지원합니다. 불투명 이미지는 안드로이드 API 15+, 투명도를 갖는 이미지는 API 18+부터 지원합니다. 또한 애초에 최적화된 PNG를 사용하면 최적화가 수행되어도 실제 APK의 크기는 별 차이가 없습니다. 그냥 시간만 잡아 먹는 거죠. 아래는 위의 PNG 최적화 기능을 끈 결과입니다. 빌드 타입 | 속도 차이(초) | 속도 차이(백분율) — | — | 전체 빌드 | -9s | -33% 증분 빌드(자바) | same | same 증분 빌드(리소스) | same | same 6. 인스턴트 런을 사용할 것 인스턴트 런은 안드로이드 스튜디오 2.0 때 런칭된 기능입니다. 발표자 말로는 런칭 이후 인스턴트 런의 신뢰성(reliability)를 위해 많은 노력을 기울였다고 합니다. 바꿔말하면 그동안에 인스턴트 런은 문제가 많았다는 뜻이겠죠. 저 역시도 인스턴트 런을 사용하지 않는데 이유는 수정한 코드가 실제로 빌드에 적용이 되지 않아 삽질을 한 기억이 많기 때문입니다. 수정한 코드가 빌드에 적용이 안된다면 빌드가 아무리 빨리 된들 무슨 소용이 있을까요. 하지만 안드로이드 스튜디오 3.0에 적용된 인스턴트 런은 2.0과 매우 다르다 합니다. 한번 믿어보는것도 좋을것 같습니다. 참고로 플랫폼의 한계에 따라 적용했던 많은 핵들을 신뢰성을 위해 과감히 제거하고 대신 안드로이드 스튜디오 3.0부터의 인스턴트 런은 API 레벨 21 이상에서만 동작한다고 합니다. (minSdk가 21 이상이여야 한다는게 아니라 연결된 단말의 버전이 21 이상이면 된다는 얘기입니다!) 안드로이스 스튜디오 3.0 이상에서는 인스턴트 런과 일반 빌드를 쉽게 구분하기 위해 런 버튼을 Run과 Apply Changes 두 개로 분리 했습니다. Run 버튼을 클릭하면 콜드 스왑을 시도하고 앱은 재실행 됩니다. 반면 Apply Changes 버튼을 클릭하면 hot or warm swap을 시도합니다. Cold, hot, warm swap에 대한 내용은 이 링크에서 자세히 알 수 있습니다. 인스턴트 런을 실행하면 연결된 디바이스의 API, 스크린 density등을 분석해서 자동으로 필요한 최적화를 수행해 줍니다. 즉 앞서 얘기했던 특정 버전의 리소스만 포함하는 빌드를 생성한다거나 멀티 APK등에 대한 최적화 들을 알아서 해준다는 것 같습니다. 아래는 인스턴트 런을 적용한 결과입니다. 빌드 타입 | 속도 차이(초) | 속도 차이(백분율) — | — | 전체 빌드 | +7s | +37% 증분 빌드(자바) | -3s | -54% 증분 빌드(리소스) | -3s | -42% 특이한게 인스턴트 런을 적용 했을 때, 풀빌드의 경우 오히려 빌드 시간이 증가했습니다. 이는 인스턴트 런이 sharding을 APK에 적용해야하기 때문이라 합니다. 이 sharding은 swap(cold, hot, warm)을 하기 위해 필요한 미리 수행되어야 하는 작업으로 발표자는 풀빌드에서 시간이 더 걸리지만 이후의 증분 빌드에서 시간을 줄일 수 있다고 이야기합니다. 간단히 위의 결과를 가지고 생각해보면 풀빌드 한번 후 증분 빌드를 2번만 하면 거의 동일하고 2번 이상부터는 매번 3초가량 시간을 벌 수 있겠네요. 7. 의도치 않은 수정은 피할 것 12345678def buildDateTime = new Date().format('yyMMddHHmm').toInteger()android { defaultConfig { versionCode buildDateTime ... }} 위의 코드는 매 빌드가 유일한 버전코드를 갖도록 시간을 가지고 버전 코드를 설정하고 있습니다. 별거 아닌것 같은 코드이지만 이 코드는 매번 빌드를 할때마다 AndroidManifest를 변경합니다. 자세히 얘기하면 versionCode같은 값들은 그래들 빌드 스크립트에 기술되어 있지만 실제 빌드가 되는 과정에서 AndroidManifest.xml에 합쳐(merge)집니다.참고. 위의 코드를 보면 매번 빌드 할때마다 versionCode가 변경되는데 이는 곧 매 빌드 마다 AndroidManifest의 uses-sdk 속성이 변경 되는 것이죠.참고. 아무튼 위의 코드가 적용된 후 결과는 아래와 같습니다. 빌드 타입 | 속도 차이(초) | 속도 차이(백분율) — | — | 증분 빌드(자바) | +3s | +130% 증분 빌드(리소스) | +3.6s | +90% 이런 문제를 개선하기 위해서는 앞서 개발 빌드 시에 멀티 APK를 적용하지 않았던 방법을 이용하면 됩니다. 1234567891011def buildDateTime = project.hasProperty('devBuild')? 100: new Date().format('yyMMddHHmm').toInteger()android { ... defaultConfig { ... versionCode buildDateTime ... } ...} 8. 다이나믹 버전은 사용하지 말 것 다이나믹 버전은 아래와 같이 그래들에 외부 라이브러리를 임포트 할 때, 뒤에 +를 붙여서 가장 최근 버전의 라이브러리를 가져올 수 있게하는 기능입니다. 발표자의 설명에 의하면 이 기능이 라이브러리의 새 버전을 추가로 확인하게 만들기 때문에 의존성 결정(dependency resolution) 시간을 증가시킨다고 합니다. 12345android { dependencies { compile 'com.android.support:appcompat-v7:+' }} 또 하나의 문제는 이게 앱을 nondeterministic하게 만든다는 겁니다. 코드의 수정이 전혀 없더라도 라이브러리의 새 버전이 나오면 빌드가 달라진다는 겁니다. 이거는 앱의 형상관리랑도 연관이 있는 부분입니다. 대부분의 프로젝트는 git같은 형상관리 툴을 이용해서 관리합니다. 형상관리 툴의 핵심기능이자 키포인트 중에 하나는, 특정 시점의 빌드를 내가 원할때 빌드해 낼 수 있고 이 빌드는 항상 동일해야 한다는 겁니다. 바이너리 수준에서 완전히 동일하진 않을 수도 있겠지만 적어도 라이브러리가 바뀌면 안되겠죠. 오래 전 내보낸 빌드에 핫픽스가 필요해서 코드의 특정 부분만 고쳐 새로 빌드를 했는데 임포트하는 라이브러리중에 업데이트가 된게 있다면? 최악의 경우 업데이트 된 라이브러리가 하위호환성을 지켜주지 않는다면? 꽤 골치아픈 상황이 되겠죠. 9. 메모리를 확인할 것 그래들에 할당하는 메모리 12#gradle.property 파일org.gradle.jvmargs=-Xmx1536m 덱스 처리 시 사용하는 메모리 1234#build.gradle 파일dexOptions { javaMaxHeapSize = \"4g\"} 그래들에 할당하는 메모리의 적정량은 프로젝트 마다 다르니 메모리를 잘 조절하면서 최적의 값을 찾으라고 합니다. 한가지 주의할 점은 무작정 메모리를 많이 할당하면 오히려 성능이 떨어질 수도 있습니다. 본인 시스템의 메모리 용량에 따라 잘 맞춰서 설정해야합니다. 두번째는 덱스 프로세스의 자바 힙 크기를 설정하는 방법입니다. 덱스 프로세스가 기존에는 out-process로 동작했으나 안드로이드 스튜디오 2.1 부터 기본값이 in-process로 변경되어 저 설정은 이제 의미가 없다고 합니다. 있으면 그냥 지워버리라네요. 근데 여기서 out-process랑 in-process가 뭔지 조금 애매합니다. 기존에는 별도의 프로세스로 처리하다가 2.1부터는 안드로이드 스튜디오 프로세스 내에서 처리한다는 걸로 이해했는데 맞는지 모르겠네요. 안드로이드 스튜디오에서 빌드 한번 돌리면 램을 2기가 넘게 써대던데 이것 때문일지도 모르겠습니다. 10. 그래들 캐시를 사용할 것 그래들의 새 캐싱 메카니즘 설정이라는데 모든 작업 결과를 캐시할 수 있다고 합니다. 안드로이드 스튜디오 2.3에 소개됐던 빌드 캐시랑 다른 점은 빌드 캐시는 pre-dexed external libararies만 캐시하는데 요건 가장 최근 빌드 뿐만 아니라 이전 빌드에 대한 캐시도 있다고 합니다. 또한 브랜치를 오가며 빌드하는 경우에도 캐시가 되고 캐싱된걸 배포할수도 있다고 하는데… 뭔 말인지는 잘 모르겠는데 어쨌든 안드로이드 스튜디오 3.0에 제대로 들어갈거라 하니 안드로이드 스튜디오 3.0이 정식 릴리즈 되면 그때 지켜봐야겠습니다. 12# Set this in gradle.propertiesorg.gradle.caching=true 마무리 위의 최적화를 모두 마친 결과가 아래와 같습니다. 전체 빌드 : 59s -&gt; 19s로 3배 빨라짐 증분 빌드(자바) : 24s -&gt; 2s로 12배 빨라짐 증분 빌드(리소스): 15s -&gt; 4.5s로 3배 빨라짐 팁들을 대강 살펴보면 개발 빌드에 필요 없는 항목들은 빌드를 하지 않는데 초점이 맞쳐져 있는걸 알 수 있습니다. 즉 개발 중에는 위의 팁들을 이용해 빌드 속도가 많이 향상될 수 있지만 릴리즈 빌드 시에는 결국 비슷한 속도로 빌드가 진행되게 됩니다. 또한 위의 팁들은 빌드 툴의 영향을 받는 것들이 대부분입니다. 즉 발표자의 발표 시점과 실제 적용 시에는 차이가 있을 수 있습니다. 따라서 위의 결과들은 앞으로 안드로이드 스튜디오나 빌드 툴이 변해가며 계속 변할 수 있는 것들이라는 점을 유념해야 합니다. 어쨋거나 개발 과정에 빌드 속도는 생산성에 큰 영향을 미치는 요소입니다. 빌드 속도가 빠르면 코드 수정 후 결과를 빠르게 확인 할 수 있고 그만큼 집중력을 유지할 수 있겠죠. 개인적으로는 아주 재미있었던 세션이였습니다. 시간이 되시는 분들은 원래 영상을 꼭 직접 보시면 좋을 것 같습니다. 번외(직접 테스트) 참고로 제가 개발하는 회사 프로젝트에 간단히 적용할 수 있는 최적화를 몇개 해보았는데 전체 빌드 기준 1분41초 -&gt; 56초의 개선이 있었습니다. 적용한 최적화 팁 그래들 버전업(2.2.2 -&gt; 3.0.0-beta6) 레거시 멀티 덱스 우회(개발 빌드 시 minSdk 16 -&gt; 19) PNG Crunch 모드 끄기 필요한 리소스만 빌드(xhdpi만 빌드) 최적화 전 최적화 후 101초 56초 참고 링크 Speeding Up Your Android Gradle Builds (Google I/O '17 구글 I/O의 ‘Speeding Up Your Android Gradle Builds’ 세션 영상입니다. Slide for the speech(Spddeing Up Your Android Gradle Build) 발표자의 발표자료입니다. Optimize Your Build Speed 안드로이드 개발자 사이트의 Optimize Your Build Speed 문서입니다. 발표 영상에 나오는 대부분의 내용들을 볼 수 있습니다. Build and Run Your App 안드로이드 빌드 및 실행에 대한 전반적인 설명이 있는 페이지입니다. Cold, hot, warm swap 콜드, 핫, 웜 스왑에 대한 설명입니다. Version Your App 안드로이드 버전 설정에 대한 내용입니다. AndroidManifest uses-sdk property 그래들에 명시한 sdk 관련 설정들이 빌드 과정에서 AndroidManifest에 병합되어 처리된다는 걸 알 수 있습니다. About Android Plugin for Gradle 3.0.0 그래들 3.0.0 버전에 대한 설명 페이지입니다.","link":"/2017/09/21/android/android-speeding-up-build-speed/"},{"title":"안드로이드 개발 시 유용한 툴 소개(ChromeADB, Vysor)","text":"안녕하세요. 오늘은 안드로이드 개발 시 유용한 툴 두가지를 소개드리려고 합니다. 기술적인 내용이 아니니 가볍게 봐주시면 좋겠습니다. ChromeADB 첫번째로 소개드릴 툴은 ChromeADB입니다. 이 툴은 ADB 주요 기능들에 GUI를 입혀서 만든 크롬앱입니다. 사용해보시면 굳이 설명이 필요없을 정도로 UI도 단순하고 직관적인데요. 그래도 간단히 소개해 드리도록 하겠습니다. 먼저 아래 화면은 패키지 관리 화면입니다. 앱 삭제 및 설치, 데이터 삭제, 강제 종료를 쉽게 할 수 있습니다. 보통은 단말의 설정 -&gt; 앱관리에 들어가 원하는 앱을 찾고 위의 작업들을 하는데요. 제조사나 안드로이드 버전에 따라 메뉴 구성이 달라서 은근히 많은 시간이 들고 자주하게 되면 매우 귀찮은 작업입니다. 하지만 ChromeADB를 사용하면 매우 쉽고 빠르게 이런 작업들을 할 수 있습니다. 두번째로는 컨트롤러 화면입니다. 텍스트 입력, 전원, 볼륨 등의 사용자 입력을 이용한 테스트를 할 수 있습니다. 저는 글쓰기 에디터를 만들때 유용하게 사용했던 기능입니다. 마지막으로 보여드릴 기능은 메모리 관리 기능인데요. 그래프를 통해서 실시간으로 메모리 사용량을 볼 수 있습니다. 사실 이 기능은 안드로이드 스튜디오에서 이제 메모리 사용량을 예쁘게 보여주기 때문에 별로 의미가 없어지긴 했는데요. 예전에 이클립스를 사용할때는 정말 유용했던 기능입니다. 프로세스 탭에 들어간 후 메모리 사용량을 보고 싶은 앱을 선택하면 됩니다. Vysor 두번째로 소개드릴 앱은 바로 Vysor라는 앱으로 ChromeADB와 마찬가지로 크롬앱입니다. 실제 안드로이드 단말의 화면을 컴퓨터 화면으로 미러링해주는 앱으로 정말 강력하게 추천하는 앱입니다. 그 이유는 다음과 같습니다. 일반적으로 테스트를 하다보면 에물레이터를 쓰거나 단말을 직접 연결해서 단말을 통해 테스트를 하는데요. 이 두가지 방법은 모두 장단점이 있습니다. 에뮬레이터를 쓰는 경우엔 보통 네트워크나 카메라, GPS 등의 테스트가 제한적이고 각종 앱들의 계정 관련 설정을 하기가 까다롭습니다. 가령 카카오톡 공유하기 기능 같은 걸 테스트하기 위해서는 카카오톡 계정을 연동하는 등의 작업을 해야하는데 이런 부분이 어렵죠. 실제 단말을 사용하는 경우엔 위의 단점들을 극복할 수 있지만 매번 모니터를 보고 코드를 작성하다가 다시 단말을 확인하는 작업이 여간 불편한게 아닙니다. 하지만 이 앱을 쓰면 이런 단점들은 커버하고 장점만 취할 수가 있습니다. 회의때 프리젠테이션 용도로 사용해도 아주 좋구요. 사용법도 너무 간단합니다. Vysor를 실행하고 PC와 안드로이드 단말을 연결하면 Vysor에 연결된 단말이 나오고 Connect 버튼을 누르면 바로 미러링이 시작됩니다. 아래 화면은 미러링이 시작된 화면입니다. 아래 이미지는 실제 단말에서 카메라를 켠 화면인데요. 미러링된 화면에서도 잘 보이는걸 알 수 있습니다. 개발을 하다보면 키보드에서 마우스로 손 한번 가는것도 귀찮게 느껴질때가 있는데요. 코드를 짜고 빌드 버튼을 누르고 키보드에서 손을 떼고 단말을 손에 쥐고 테스트하는 작업은 말할것도 없죠. 이런것들이 상당히 많이 해소되기 때문에 정말 좋습니다. (살짝 화면상에 딜레이가 있거나 화질이 떨어지기도 하는데요 크게 불편한 정도는 아닌거 같습니다.) 마지막으로 위에 소개드린 두 앱은 모두 크롬앱으로 만들어졌기 때문에 맥이든 윈도우든 리눅스든 다 사용이 가능하고 설치고 크롬 앱스토어에서 쉽게 설치가 가능하구요. 일반 앱처럼 런처를 통해서도 바로 실행 시킬 수 있는것도 큰 장점인것 같습니다. 장인은 연장을 가리지 않는다고 하지만 좋은 툴들을 사용하면 개발이나 테스트 시간을 많이 줄여주기 때문에 이런 툴들을 적절히 잘 사용하면 좋을 것 같습니다!","link":"/2016/03/19/android/android-tools/"},{"title":"이맥스(Emacs) Org 모드","text":"이맥스는 쓰면 쓸수록 매력있는 텍스트 에디터입니다. 이맥스로 할 수 있는게 아주 많습니다. 대부분의 사람들이 이맥스를 프로그래밍 할 때 사용하지만 Org 모드를 이용하면 일정관리, 메모, 문서작성에도 요긴하게 쓸 수 있습니다. 이 글에서는 Org 모드 중 일정관리에 대한 부분을 중점적으로 살펴보도록 하겠습니다. 들어가며 아래는 Org 모드가 어떤 것인지 한눈에 볼 수 있는 이미지입니다. 시작하기 1234(global-set-key \"\\C-c l\" 'org-store-link)(global-set-key \"\\C-c a\" 'org-agenda)(global-set-key \"\\C-c c\" 'org-capture)(global-set-key \"\\C-c b\" 'org-iswitchb) 헤드라인 Org 모드의 시작은 헤드라인과 함께 합니다. 헤드라인은 위의 스크린 샷에서 *로 시작하는 줄입니다. 헤드라인은 단락과도 비슷한데, 들여쓰기와 함께 문서를 __트리 구조__로 작성할 수 있게 합니다. M-RET를 통해 추가할 수 있으며 헤드라인이 있는 줄에서 M-방향키를 입력하면 레벨과 위치를 조절 할 수 있습니다. 12345678* Top level headline ** Second level *** 3rd level some text *** 3rd level more text * Another top level headline 할 일 목록(TODO Items) 헤드라인은 모두 할 일이 될 수 있습니다. 할 일이 되기 위해서는 헤드라인이 _TODO_로 시작하면 됩니다. 헤드라인에서 S-&lt;LEFT&gt; 또는 S-&lt;RIGHT&gt;를 입력하면 헤드라인 -&gt; TODO -&gt; DONE의 세 가지 상태로 쉽게 전환할 수 있습니다. 시간과 날짜(Date and Times) 일정관리에는 시간이 중요합니다. 일정은 특정한 날까지 수행해야 하는 일, 일정한 주기로 반복적으로 일어나는 일, 언제부터 언제까지와 같은 일정 날짜 사이에 해야하는 일 등 시간 엮이는 경우가 많습니다. Org 모드에서 각각의 할 일은 타임스탬프 레이블을 통해 관리 할 수 있습니다. 타임스탬프는 할 일 목록에만 붙는게 아니라 Org 트리에 있는 엔트리에 모두 붙을 수 있습니다. 일반 시간, 이벤트, 일정 특정한 이벤트나 일정이 열시는 시간을 나타냅니다. * Meet Peter at the movies * Discussion on climate change 반복되는 시간 일정한 주기로 반복되는 일을 나타냅니다. * Pick up Sam at school Diary-style sexp entries * The nerd meeting on every 2nd Thursday of the month 시간 범위 시간 범위를 나타냅니다. '–'로 두 타임스탬프를 연결하는 형태로 표현합니다. ** Meeting in Amsterdam -- 비활성 타임스탬프 아젠다에 나타나지 않는 시간입니다. ‘[’ ~ ']'로 표현되며 할 일을 완료해서 DONE이 되면 나타나는 시간입니다. * Gillian comes late for the fifth time [2006-11-01 Wed] 태그(Tags) 헤드라인에 서로 연관있는 정보나 추가 정보를 기입하기 위해 태그를 사용할 수 있습니다. 태그는 헤드라인의 끝에 들어가며 여러 태그를 같이 달 수 있습니다. 태그는 문자와 숫자, _, @로 구성되며 :와 :로 감싸야합니다. 아래는 태그의 예 입니다. 또한 태그는 상속이 됩니다. 아래 예에서 두 번째 레벨의 헤드라인은 :work:boss:notes: 태그를 갖게 되고 세 번째 레벨의 헤드라인은 :work:boss:notes:action: 태그를 갖게 됩니다. * Meeting with the French group :work: ** Summary by Frank :boss:notes: *** TODO Prepare slides for him :action: 태그는 파일 단위로도 달 수 있습니다. 아래와 같이 문서에 #+FILETAGS:를 이용하면 파일 전체에 태그가 적용됩니다. #+FILETAGS: :Peter:Boss:Secret: Enter new tags for the current headline. Org mode will either offer completion or a special single-key interface for setting tags, see below. After pressing , the tags will be inserted and aligned to org-tags-column. When called with a C-u prefix, all tags in the current buffer will be aligned to that column, just to make things look nice. 아젠다(Agenda) 기능 Feature list 일정관리(Todo) 팁 C-c C-c When the cursor is in a headline, this does the same as C-c C-q. 헤드라인에서 입력하는 경우 : 태그 입력 타임스탬프에서 입력하는 경우 : 타임스탬프 수정 org-support-shift-select 자주쓰는 단축키 태그 단축키 단축키 | 명령어 | 설명 — | — | C-c C-q | C-c C-q | 현재 엔트리에 태그를 추가합니다 할 일 목록 단축키 단축키 | 명령어 | 설명 — | — | C-c C-t | org-todo | 헤드라인을 할일, 완료, 상태없음(unmarked)로 변경 S-/ | org-shift-right / org-shift-left | 헤드라인을 할일, 완료, 상태없음(unmarked)로 변경 C-c / t | | 모든 할일 목록을 보여준다 S-M- | org-insert-todo-heading | 현재 헤드라인과 동일한 레벨에 할일 목록을 추가한다. 아젠다 단축키 단축키 | 명령어 | 설명 — | — | C-c [ | org-agenda-file-to-front | 현재 파일을 아젠다 목록에 추가 C-c ] | org-remove-file | 현재 파일을 아젠다 목록에서 제거 C-, | org-cycle-agenda-files | org-agenda-files 목록에 있는 아젠다 파일 순회 C-c C-d | org-deadline | 데드라인 타임스탬프 추가","link":"/2017/11/15/emacs/emacs-org-mode-intro/"},{"title":"이맥스(Emacs) Org 모드 - 1. 시작하기","text":"들어가며 Org 모드는 이맥스를 이용해 문서를 작성하거나 일정관리를 할 수 있도록 도와주는 모드입니다. 위의 그림과 같이 생각을 구조적으로 정리하고 타임스탬프를 이용해 일정을 관리할 수 있습니다. 또한 이렇게 작성된 문서는 다양한 형태의 포맷으로 변환이 가능합니다. Org 모드의 기능은 아주 많기 때문에 이번 포스팅에서는 Org 모드의 가장 기본이 되는 요소들에 대해 먼저 알아보고 이어지는 포스팅을 통해 점차 Org 모드의 세부 기능에 대해 알아보도록 하겠습니다. 이 포스팅에 있는 내용은 대부분 Org 모드 공식 페이지의 메뉴얼과 가이드를 가지고 정리한 것으로, 자세한 내용은 공식 홈페이지를 참고하시면 됩니다. 이맥스의 Org 모드가 갖는 장점 1. 문서작성 이맥스 자체는 텍스트 편집기이기 때문에 사람이 보기 좋게 서식을 갖추어 바로 보기는 어렵습니다. 하지만 이렇게 서식을 신경쓰지 않아도 되기 때문에 문서의 외형보다는 __내용__에 집중해서 문서를 작성할 수 있도록 해줍니다. 게다가 이렇게 Org 모드를 통해 작성한 문서는 HTML, PDF, LaTeX, Markdown, OpenDocument 등 다양한 형식으로 변환이 가능하기 때문에 결국 서식에 있어서도 워드프로세서에 비해 훨씬 확장성이 크다 할 수 있습니다. 데이터와 모양(서식)을 분리한게 마치 HTML과 CSS 관계랑 비슷하죠? 또한 문서 자체가 텍스트 이기 때문에 용량도 작고 OS나 특정 워드프로세서와 같은 소프트웨어 종속적이지 않다는 장점도 가집니다. 2. 일정관리 일정 관리에 있어서도 Org 모드는 할 일 목록(ToDO), 타임스탬프, 링크, 아젠다 뷰, 달력 등을 이용해 손쉽게 일정을 관리 할 수 있는 다양한 기능을 제공합니다. 이런 기능들은 이맥스 특유의 단축키 시스템과 결합되어 사용자에게 엄청난 생산성을 가져다 줍니다. 시작하기 Org 모드는 확장자가 .org인 파일을 열면 자동으로 활성화 되는 메이저 모드입니다. 직접 Org 모드를 활성화 시키고 싶으면 M-x org-mode&lt;RET&gt; 키를 입력하면 됩니다. 만약 Org 모드가 설치되어 있지 않다면 아래와 같이 org 모드를 설치합니다. M-x package-install RET org RET 헤드라인(Headlines) Org 모드의 시작은 헤드라인과 함께 합니다. 헤드라인은 위의 스크린 샷에서 *로 시작하는 줄입니다. 헤드라인은 단락과도 비슷합니다. 들여쓰기와 *의 개수는 단락의 레벨을 나타냅니다. 헤드라인을 이용해서 __트리 구조__로 문서를 작성할 수 있습니다. M-RET를 통해 헤드라인을 추가할 수 있으며, 헤드라인이 있는 줄에서 M-방향키를 입력하면 레벨과 위치를 조절 할 수 있습니다. 12345678* Top level headline ** Second level *** 3rd level some text *** 3rd level more text * Another top level headline 할 일 목록(TODO Items) 헤드라인은 모두 할 일이 될 수 있습니다. 할 일이 되기 위해서는 헤드라인이 __TODO__로 시작하면 됩니다. 헤드라인에서 S-&lt;LEFT&gt; 또는 S-&lt;RIGHT&gt;를 입력하면 헤드라인 -&gt; TODO -&gt; DONE 세 가지 상태로 쉽게 전환할 수 있습니다. 플레인 리스트(Plain lists) 1234567891011121314** Lord of the Rings My favorite scenes are (in this order) 1. The attack of the Rohirrim 2. Eowyn's fight with the witch king + this was already my favorite scene in the book + I really like Miranda Otto. 3. Peter Jackson being shot by Legolas - on DVD only He makes a really funny face when it happens. But in the end, no individual scenes matter but the film as a whole. Important actors in this film are: - Elijah Wood :: He plays Frodo - Sean Astin :: He plays Sam, Frodo's friend. I still remember him very well from his role as Mikey Walsh in The Goonies. 헤드라인이 단락과 같은 역할을 한다면 플레인 리스트는 단락에서 리스트를 표현하는데 사용됩니다. 또한 플레인 리스트는 이후 설명할 체크박스(Checkboxes)에도 사용됩니다. 플레인 리스트는 크게 순서가 있는 리스트, 순서가 없는 리스트, 디스크립션 리스트로 나눌 수 있습니다. 순서가 없는 리스트 -나 +, *로 시작합니다. 여기서 *는 위치에 따라 헤드라인이 되기도 하고 플레인 리스트가 되기도 하기 때문에 혼동을 줄이기 위해 -나 +를 사용하는게 좋습니다. 순서가 있는 리스트 1. 이나 1) 처럼 숫자에 .이나 )를 붙여서 표현합니다. 만약 20과 같은 숫자로 시작하고 싶다면 [@20]과 같이 사용하면 됩니다. 디스크립션 리스트 디스크립션 리스트는 정의를 표현하기 위해 사용며 순서가 없는 리스트에 ::를 이용해서 표현합니다… 사전을 생각하면 쉬운데, ::를 기준으로 왼쪽에는 단어, 오른쪽에는 설명을 적는다고 생각하면 쉬울 것 같습니다. 플레인 리스트에서 S-&lt;LEFT&gt; 또는 S-&lt;RIGHT&gt; 키를 입력하면 리스트의 형태가 바뀌고 M-&lt;RET&gt;를 입력하면 새로운 플레인 리스트 아이템을 추가할 수 있습니다. 체크박스(Checkboxes) 플레인 리스트 안에 있는 아이템은 체크박스를 가질 수 있습니다. 체크박스를 사용하는건 간단합니다. 아이템의 맨 앞에 [ ]를 삽입하면 됩니다. 단축키로는 M-S-&lt;RET&gt;를 사용합니다. 체크박스에 체크를 하거나 체크를 해제하는건 C-c C-c 단축키를 사용합니다. 또한 체크박스가 있는 아이템의 부모는 진행 사항을 알 수 있습니다. 부모 아이템의 마지막 줄에 [/]을 넣으면 [2/4]와 같은 형태로, [%]를 넣으면 [50%]와 같은 형식으로 진행 사항을 보여줍니다. 아래는 체크박스의 예입니다. 12345678* TODO Organize party [2/4] - [-] call people [1/3] - [ ] Peter - [X] Sarah - [ ] Sam - [X] order food - [ ] think about what music to play - [X] talk to the neighbors 접기/펼치기(Folding and Expanding) 헤드라인이나 플레인 리스트는 &lt;TAB&gt;키를 통해 접기와 펼치기가 가능합니다. 마무리 이번 포스팅에서는 간단히 Org 모드에 대한 설명과 기본 구성요소에 대해 정리 알아 보았습니다. 다음 포스팅에서는 Org 모드를 이용한 일정관리에 대해 조금 더 자세히 알아보도록 하겠습니다. 참고자료 Org 모드 공식 페이지 Org 모드의 기능에 대한 모든 설명을 볼 수 있습니다.","link":"/2017/11/15/emacs/emacs-org-mode-introduction/"},{"title":"이맥스(Emacs) 패키지 관리","text":"이맥스 설정 개요 이맥스가 실행되면 이맥스는 초기화 파일로부터 Lisp 프로그램들을 로드합니다. 초기화 파일은 아래 세 가지 중에 하나를 선택해서 사용하면 됩니다. ~/.emacs, ~/.emacs.el, or ~/.emacs.d/init.el 패키지 이맥스 24 이후부터 패키지 설치는 거의 ELPA를 사용합니다. 기존에 직접 패키지를 다운받아서 설치하던 방식에서 패키지 매니저를 통해 패키지들을 간편하게 설치 할 수 있게 된거죠. 여기서 ELPA는 이맥스 패키지들이 올라가있는 저장소입니다. 따로 설정을 해주지 않아도 이맥스 버전 24부터는 기본으로 ELPA 패키지 저장소가 설정되어있습니다. 패키지 저장소는 ELPA외에 다른 것들도 있는데 보통 MELPA를 많이 사용합니다. 저장소를 추가로 세팅하는 방법은 아래와 같습니다. 12(require 'package)(add-to-list 'package-archives '(&quot;melpa&quot; . &quot;https://melpa.org/packages/&quot;)) 패키지 설치 M-x list-package 명령어를 입력하면 아래와 같이 패키지 목록을 볼 수 있습니다. 여기에 있는 패키지 목록이 바로 ELPA에 등록된 패키지입니다. 만약 MELPA와 같은 저장소를 위와 같은 방법으로 추가했다면 해당 저장소에 있는 패키지도 함께 보여집니다. 패키지 로딩 load-path 변수에는 이맥스가 설치된 패키지를 로드할 때 패키지를 검색하는 디렉토리 목록이 저장됩니다. M-x describe-variable 명령어를 통해 load-path 변수의 값을 볼 수 있습니다. 사용하려고 하는 패키지가 load-path에 포함되어 있지 않으면 로딩을 실패합니다. 패키지 커스터마이징 패키지를 설치 했으면 이제 내 손맛에 맞게 커스터마이징을 합니다. 커스터마이징이라 하면 단축키, 자동 로딩 등이 있겠죠. 자동 로딩은 설치한 패키지가 이맥스가 시작 될 때 자동으로 로딩되도록 해주는 것입니다. 설치한 패키지가 필요할 때 마다 매번 패키지를 로드하는건 너무 불편하겠죠? :) 유용한 함수 함수 단축키 설명 describe-function - elisp 함수의 설명을 보여줌 describe-key - 현재 맵핑된 단축키에 대한 설명을 보여줌 describe-mode - 현재 모드의 키바인딩 목록을 볼 수 있음 describe-variable - elisp 변수에 대한 설명을 보여줌 단축키 이맥스 커맨드는 Lisp 함수입니다. 보통 소문자와 하이픈으로된 이름을 가집니다. 이맥스는 이런 커맨드를 다양한 단축키로 제공합니다. 단축키가 잘 정의되어 있고 이를 잘 사용하면 엄청난 생산성을 가질 수 있습니다. 그리고 이는 곧 사람들이 이맥스를 사용하는 가장 큰 이유가됩니다. 따라서 단축키를 익히고 커스터마이징 하는건 이맥스 사용자에게 가장 중요한 일중에 하나입니다. 키맵(Keymaps) 이맥스의 단축키는 키맵을 통해 제공됩니다. 키맵은 전역 키맵(Global keymap) XXX 키맵으로 구성됩니다. 전역 키맵은 이맥스의 기본 모드(Fundamental mode)의 키맵을 정의합니다. 이맥스의 단축키는 키(keys)와 문자(characters)로 구성됩니다. 여기서 키는 컨트롤(Ctrl), 메타(Alt or Meta), 펑션키(, , …)를 말하고 문자는 알파벳과 특수문자들을 생각하면 됩니다. 또한 이맥스에는 메이저 모드와 마이너 모드가 있는데요. 각 모드는 자신만의 키맵을 정의해서 사용할 수 있습니다. 키맵 커스터마이징 글로벌 키맵(Global Keymap) M-x global-set-key를 이용해 글로벌 키맵의 키를 재정의 할 수 있습니다. 1(global-set-key [f9] 'gud-break) 로컬 키맵(Local Keymaps) 미니버퍼 맵 마크다운 모드 링크 : https://jblevins.org/projects/markdown-mode/ 메뉴얼 : https://leanpub.com/markdown-mode 외부 모듈로 Markdown.pl, MultiMarkdown, Pandoc 중 하나를 설치해야한다. 프리뷰 모드 마크다운 문서를 웹브라우저를 통해 바로 보려면 markdown-preview 모드를 사용하면 된다. 다만 마크다운 문서는 기본적으로 html로 변환을 거쳐야 하기 때문에 이 작업을 해줄 프로그램이 필요하다. 마크다운 모드에서는 Markdown.pl, MultiMarkdown, Pandoc 중 하나를 사용한다고 한다. Debian 계열의 리눅스에서는 MultiMarkdown을 아래와 같이 설치 할 수 있다. sudo apt-get install libtext-multimarkdown-perl 모드 이맥스는 다양한 편집 모드를 가집니다. 모드는 메이저 모드와 마이너 모드로 나눠집니다. 메이저 모드(Major mode) 메이저 모드는 C 소스파일과 같이 특정한 파일 타입을 편집할 때나 쉘 버퍼와 같은 특정 타입의 버퍼에 대해 동작합니다. 메이저 모드는 한번에 하나의 모드만 동작할 수 있습니다. 모든 버퍼는 하나의 메이저 모드를 가집니다. 현재 메이저 모드는 아래 그림과 같이 이맥스 창 하단에서 확인 할 수 있습니다. 가장 기본적인 최소한의 메이저 모드는 펀드멘털 모드로 불립니다. 이 모드는 특정 모드에 한정된 재정의나 변수 설정을 갖지 않기 때문에 가장 기본적인 이맥스의 상태로 동작합니다. 대부분의 메이저 모드는 세개의 메이저 그룹으로 나눌 수 있습니다. 첫 번째 그룹은 플레인 텍스트나 마크업 텍스트를 가집니다. 여기에는 텍스트 모드, HTML 모드, SGML 모드, TeX 모드, 아웃라인 모드가 있습니다. 두 번째 그룹은 프로그래밍 언어들을 포함합니다. Lisp, C, Fortran 등등의 모드를 갖습니다. 세 번째 그룹은 파일의 형식과 관련이 없는 모드들을 갖습니다. Dired, Message, Shell 모드 등입니다. 메이저 모드는 보통 이맥스에 의해 파일이나 버퍼가 생성될 때 자동으로 설정됩니다. 모드를 바꾸고 싶을때는 M-x 뒤에 -mode를 붙여서 변경할 수 있습니다. (ex&gt; `M-x lisp-mode). 모든 버퍼는 하나의 메이저 모드를 갖기 때문에 메이저모드를 다른걸로 바꿀 수는 있어도 끌 수는 없습니다. 각 버퍼의 로컬 변수인 major-mode는 메이저 모드의 커맨드를 이름으로 갖습니다. 예를 들어 M-x lisp-mode를 통해 Lisp 메이저 모드를 선택했다면 major-mode 변수에는 list-mode가 자동으로 설정됩니다. major-mode의 기본 값은 정해진 메이저 모드가 없는 버퍼에 대해 설정되는 모드입니다. 보퐁 이 기본 값은 fundamental-mode입니다. 이 기본 값을 변경하고 싶으면 아래와 같이 하면 됩니다. 1(setq-default major-mode `text-mode) 만약 major-mode의 기본값이 nil이면 메이저 모드는 이전 버퍼의 모드를 따라갑니다. 특정 메이저 모드는 보통 모드에 맞게 특정 키, 사용자 옵션, 변수 등을 변경합니다. 예를 들면 보통 프로그래밍 언어 모드에서는 을 해당 언어의 가이드에 맞추어 들여쓰기 해주도록 합니다. 그리고 버퍼 로컬 변수인 comment-start를 수정하기도 합니다. 이 변수는 언어에 따른 주석의 형태를 정의합니다. *현재 설정된 메이저 모드에 대한 문서를 보려면 M-x describe-mode를 사용합니다. 모드에 대한 자세한 설명과 키 바인딩을 모두 확인할 수 있습니다. 기본 모드를 제외한 모든 메이저 모드는 모드가 활성화 될 때마다 실행되는 커스터마이징이 가능한 List 함수의 목록을 모드 훅(mode hook)으로 정의합니다. 아래는 c+±mode의 훅입니다. 훅의 이름은 모드명-hook입니다. 또한 모든 텍스트 기반의 메이저 모드는 text-mode-hook을, 많은 수의 프로그래밍 언어 모드는 prog-mode-hook을 각각의 메이저 모드가 갖는 훅을 실행 시키기 전에 실행합니다. 123(add-hook 'c++-mode-hook '(lambda () (c-set-style \"linux\"))) 메이저 모드의 훅은 마이너 모드의 훅들을 활성화 시키기 위해 자주 사용됩니다. 아래의 코드는 text-mode에 진입할 때 flyspell-mode 마이너 모드를 활성화 시키고 있습니다. 1(add-hook 'text-mode-hook 'flyspell-mode) 마이너 모드(Minor mode) 마이너 모드는 내가 원할때 켜고 끌 수 있습니다. 또한 특정한 타입의 파일이나 버퍼에 구분없이 동작 할 수 있습니다. 마이너 모드는 다른 메이저 모드나 마이너 모드에 대해 독립적입니다. 버퍼 로컬 마이너 모드는 활성화 된 버퍼에서만 동작합니다. 반면 글로벌 마이너 모드는 모든 버퍼에서 동작합니다. 자동완성 설치 : https://github.com/auto-complete/auto-complete 메뉴얼 : https://github.com/auto-complete/auto-complete/blob/master/doc/manual.md 참고자료 EmacsWiki 이맥스 영문 위키 페이지입니다. 이맥스 사용자에겐 여기가 보물 창고!","link":"/2017/11/09/emacs/emacs-package/"},{"title":"워블리 로켓","text":"오늘은 기술 이야기가 아닌 개인 프로젝트 이야기를 해보려 합니다. 이름은 워블리 로켓(Wobbly Rocket). 어떤 앱이 될지는 아래와 같이 정리해보았습니다. 자신의 매매 기록을 분석하여 트레이딩 습관과 패턴을 개선하고, 검증된 전략을 단계적으로 자동화하는 개인 트레이딩 플랫폼 사실 이 블로그는 개발하면서 배운 내용들을 정리하는 기술 블로그로 사용되고 있었는데요. AI 도구들이 발전하면서 기술 블로그를 운영하는게 의미가 있나…? 하는 생각에 한동안 손을 놓고 있다가 지금 하고 있는 프로젝트를 하면서 느끼는 점, 고민되는 부분 등을 편하게 남기는것도 의미가 있을 것 같아 오랜만에 키보드를 붙잡았습니다. 워블리 로켓을 시작하게 된 이유 저는 해외 암호화폐 선물 거래소의 개발자였습니다. 사실 처음에는 캔들 차트가 뭐인지도 몰라서 면접때 쩔쩔매던, 매매에 있어서는 백지 같은 사람이였습니다. 일을 하며 거래소를 만드는 사람으로서 매매를 모른다는 건 이상하다고 느꼈습니다. 그래서 직접 매매를 시작하게 되었습니다. 처음에는 초심자의 행운도 있었고 아무 전략 없이, 공부도 없이, 홀짝 게임처럼 진입했는데도 수익이 나기도 했습니다. 하지만 결국은 반복되는 청산과 손실. 계좌는 꾸준히 줄어들었습니다. 문제는 지식이 아니었습니다 결국 큰 손실을 겪고 저는 열심히 공부를 했습니다. 기술적 분석, 지표, 리스크 관리, 켈리 공식…이론은 점점 쌓여갔습니다. 그런데 이상하게도 손실은 계속되더군요. 그러다 깨달았습니다. 내가 몰라서 잃는 게 아니라 내가 나를 통제하지 못해서 잃는 순간이 훨씬 많다는 것. 뇌동매매(감정 매매, 틸트) 복구 심리 포지션 중독 성급함 지식과 별개로, 습관과 감정이 제 계좌를 무너뜨리고 있었습니다. 하지만 이걸 깨달았음에도 제 계좌는 계속 손실만 쌓여갔습니다. 사실 매매를 해보신 분들은 대부분 공감할 이야기일 겁니다. 배운건 많지만 결국 욕심과 감정 때문에 배운대로 매매 하는게 아니라 본능대로 매매 한다는 것을요. 내가 하고 싶은 것 워블리 로켓은 일단 저의 문제를 풀어보고 싶어서 시작한 프로젝트입니다. 그래서 제가 풀고 싶은 문제를 좀 구체화 해보았습니다. 내가 반복하는 실수를 데이터로 마주하고 싶다. 감정이 아니라 시스템으로 의사결정하고 싶다. “운”이 아니라 “재현 가능한 수익이 나는 시스템”을 만들고 싶다. 그래서 어떻게? 예전에 틱낫한 스님의 '화’라는 책을 감명깊게 본 기억이 있습니다. 이 책에서 화를 내는 습관을 고치는 핵심은 '화’가 날때마다 이를 인지하고 바라보라는 것이였습니다. 우리의 문제도 비슷하다고 생각합니다. 먼저 무엇이 문제인지를 명확하게 바라보고 인식할 수 있어야합니다. 내가 문제가 있다는걸 모르거나, 있더라도 그 문제를 구체적으로 보지 못하면 막연하게 나는 안좋은 습관이 있나부다 정도로 끝나게 됩니다. 그래서 저는 제가 풀고 싶은 매매에서의 문제를 아래의 단계로 풀어보려 합니다. 나의 매매 데이터를 통해 현재 매매를 분석하고 인사이트를 도출한다.(나의 문제를 인식한다.) 분석한 매매 정보를 바탕으로 수익이 나는 매매 구조를 만들기 위한 '행동’을 제안한다. 수익이 나는 구조를 시스템화 한다. 마무리 마지막으로 최근 AI 도구들이 정말 무섭게 발전하고 있습니다. 이에 따라 전통적인 기획, 디자인, 개발의 경계도 많이 흐려지고 있구요. 특히나 혼자서 기획, 설계, 개발, 디자인, 실험까지 모두 해야 하는 개인 프로젝트에서 AI는 이제 선택이 아니라 필수입니다. 그동안 개발자로서 기술에 많은 관심이 있었습니다. 하지만 이제는 AI가 발전하며 기술적인 부분의 많은 것들을 AI가 담당하고 있습니다. 이제는 개발자도 문제해결의 영역을 개발문제가 아닌 현실의 문제로 확장해야하는 시기가 온것 같습니다. 워블리 로켓에서 워블리(Wobbly)는 ‘흔들리는’, ‘기우뚱한’, ‘비틀거리는’ 등의 의미를 가진 단어입니다. 매매를 주제로 다루는 서비스에 다소 어울리지 않을 수도 있다고 생각합니다. 하지만 저는 이렇게 생각해보았습니다. 사람은 누구나 실패하고 실수를 합니다. 그리고 대부분의 커다란 성공에도 부족한 시작의 단계가 있을겁니다. 그래서 저는 이 이름이 좋습니다. 완벽하지 않고 부족하고, 실패도 겪지만 결국은 로켓처럼 성공을 향해 날아가리라는 바램을 담아보았습니다. 이 글을 보는 다른 분들도 모두 이렇게 되길 바라며 글을 마칩니다.","link":"/2026/02/11/wobbly-rocket/blueprint/"},{"title":"안드로이드에서의 딥링크(Deep links)와 앱링크(App links)","text":"웹이 지금 처럼 널리 사용되고 강력한 힘을 갖게 된 이유는 링크 덕분이였다고 해도 과언이 아닐거라고 생각을 합니다. 웹에서 사용되는 HTML(Hypertext Markup Language) 문서는 링크를 통해 서로 연결이 되고 우리는 링크를 타고 정보의 세계를 여행합니다. 안드로이드에서도 앱 내의 컨텐츠에 유저가 쉽게 이동 할 수 있도록 링크를 지원합니다. 우리는 이 링크를 딥링크라고 부릅니다. 디지털 세상에서의 링크 URI(Uniform Resource Identifier) 디지털 세상에서는 웹상의 컨텐츠를 URI라는 포맷으로 표시합니다. 앞에서 설명한 링크 역시 URI 포맷으로 표현됩니다. 그럼 먼저 URI가 어떻게 생겼는지 살펴보도록 하겠습니다. scheme://username:password@host:port/path?query_string#fragment_id 스킴(scheme): 리소스에 접근하기 위한 프로토콜을 나타냅니다. 예를들어 웹 리소스의 경우 http(Hypertext Transfer Protocol), 또는 https(HTTP Secure)를 사용합니다. 유저명 &amp; 비밀번호(Username and Password): 선택 필드로, 인증이 필요한 경우 사용할 수 있습니다. 보안에 취약하기 때문에 사용이 권장되지는 않습니다. 호스트(Host): 리소스가 존재하는 서버의 도메인 또는 IP 주소 입니다. 도메인은 IP 주소를 사람이 읽기 쉬운 형태로 사용할 수 있도록 해줍니다. www.example.com과 같은 형태의 도메인이 있다면 www는 서브도메인, example.com을 도메인이라고 부릅니다. 포트(Port): 선택 필드로, 서버 내에서 어떤 컴포넌트가 요청을 처리할지를 표현합니다. 정의가 되어있지 않은 경우 브라우저는 스킴에 주어진 기본 포트를 사용합니다. 예를 들어 http의 경우 80, https의 경우 443이 기본 포트입니다. 패스(Path): 서버에서의 구체적인 위치를 표현합니다. ex&gt; /path/to/myfile.html 쿼리 스트링(Query String): 서버에 데이터를 전달하기 위해 사용합니다. ?로 시작하며 키-값의 쌍을 표현합니다. 여러개의 쿼리 스트링은 &amp;로 구분합니다. ex&gt; ?key1=value1&amp;key2=value2 프래그먼트 아이디(Fragment ID): 리소스의 특정 파트를 나타내기 위해 사용되며 #으로 시작합니다. 보통 웹페이지의 특정 섹션으로 바로 이동하기 위해 사용됩니다. URI의 예 https://www.example.com:443/path/to/page?query=123#content 위의 URI의 경우 스킴은 https 프로토콜로 443 포트를 사용하며 서버의 위치는 www.example.com 도메인을 통해 접근합니다. /path/to/page는 접근하려는 자원이고, 키가 query 이고 123인 값을 쿼리 스트링으로 서버에 전달합니다. content는 해당 리소스에서 접근하고자 하는 부분입니다. 좀 더 이해를 돕기 위해서는 아래처럼 말할 수도 있겠네요. (조금 억지스런 예제일 수 있습니다. ^^;) 한국어://경기도용인시XX아파트:관리실/관리비?청구월=11월#전기료 프로토콜은 한국어입니다. 즉 한국어로 클라이언트와 서버가 소통합니다. 리소스를 받을 서버의 주소는 경기도 용인시 XX아파트이고 XX아파트의 관리실에서 요청을 처리합니다. 받고자 하는 리소스 즉 경로는 관리비입니다. 11월 관리비만 궁금하기 때문에 청구월 쿼리스트링으로 11월을 포함하여 관리비를 요청합니다. 그리고 관리비 고지서에서 전기료 파트에 바로 접근합니다. 안드로이드에서 사용할 수 있는 링크의 종류 안드로이드는 웹과 유사하게 링크를 통해 유저가 앱에서 제공하는 컨텐츠에 접근할 수 있도록 딥링크(Deep Link)라는 기능을 제공합니다. 접근하려는 컨텐츠가 웹이 아닌 안드로이드 앱 내부에 있지만 안드로이드에서 제공하는 인텐트(Intent)라는 도구를 이용해서 이를 처리 할 수 있습니다. 아래와 같이 AndroidManifest.xml에 intent-filter를 선언하면 URI를 통해 앱의 컨텐츠를 노출 할 수 있습니다. 눈여겨 봐야할 부분은 data 속성인데요. geo라는 스킴을 정의하고 있습니다. 1234567891011&lt;activity android:name=\".MyMapActivity\" android:exported=\"true\" ...&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.VIEW\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;category android:name=\"android.intent.category.BROWSABLE\" /&gt; &lt;data android:scheme=\"geo\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 이렇게 하면 이제 geo라는 스킴을 갖는 URI가 안드로이드 단말의 브라우저에서 클릭이 되거나 다른 앱에서 트리거 되면 우리 앱의 MyMapActivity 가 이를 처리 할 수 있게 됩니다. 위의 인텐트 필터에서 카테고리는 아래와 같은 역할을 합니다. &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt; 웹 브라우저에서의 링크 클릭을 인텐트로 받을 수 있게 합니다. &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; 암시적 인텐트를 받을 수 있도록 합니다. 이제 안드로이드 폰에서 웹브라우저를 통해 geo:// 스킴으로 시작하는 링크를 클릭하면 내가 만든 앱의 MyMapActivity가 받아서 처리할 수 있게 되었습니다. 딥링크의 한계 지금까지의 설명만 보면 딥링크 자체는 별 문제가 없어보입니다. 하지만 잘 생각해보면 우리가 받아서 처리하겠다고 AndroidManifest.xml에 선언한 스킴은 우리가 정의한 스킴입니다. 즉 다른 앱에서도 얼마든지 동일한 스킴을 받아서 처리하겠다고 선언할 수 있습니다. 위에서 예를 든 geo라는 스킴을 받아서 처리하는 앱이 스마트폰에 여러 개가 설치되어 있을 수 있습니다. 그런 경우 안드로이드는 아래와 같은 다이얼로그를 띄우게 됩니다. geo라는 스킴을 받아서 처리하겠다고 선언되어 있는 앱이 _Maps_와 Chrome 두개가 있으니 둘 중 어디서 이 요청을 처리할지 사용자가 선택하라는 다이얼로그입니다. 하단에 보면 JUST ONCE와 ALWAYS 버튼이 있어서 앞으로 동일한 스킴이 트리거 되었을 때 이번에 선택한 앱이 한번만 실행될지, 항상 실행될지를 결정할 수 있습니다. 유저 입장에선 선택권이 넓다고 할 수도 있지만 어떤 앱이 이걸 처리해야할지 헷갈릴수도 있고 맞는 앱을 선택 해야하는 것 자체가 어렵습니다. 그리고 앱 개발자 입장에서는 내가 만든 앱의 딥링크가 내 앱이 아닌 엉뚱한 앱에서 실행이 될 수도 있는 문제가 있습니다. 딥링크 중복 문제 해결 안드로이드에서는 이러한 문제를 해결하기 위해 앱링크(App Links)라는 해결책을 제공합니다. 이에 대해 알아보기 전에 먼저 웹링크(Web Links)에 대해 알아보도록 하겠습니다. 웹링크는 스킴이 http 또는 https인 링크를 말합니다. 웹에서 웹브라우저를 통해 인터넷을 할 때 사용되는 프로토콜이 http 또는 https 이기 때문에 이를 웹링크라고 하는 것이죠. 그럼 안드로이드 앱에서 아까와 같이 처리할 딥링크를 정의할 때 이를 웹링크로, 즉, 스킴에 http 또는 https를 선언하면 어떻게 동작할까요? 이건 안드로이드 OS 버전에 따라 다른데 12 미만에서는 일반 딥링크와 동일하게 처리되고(웹링크를 처리하는 앱으로 연결, 하나 이상이면 다이얼로그로 처리할 앱 선택) 12 이상에서는 단말에 기본으로 설정된 웹브라우저 앱이 뜹니다. 참고로 웹브라우저 앱은 설정 -&gt; 애플리케이션 웹링크를 스킴으로 설정한 앱들 중에 선택이 가능합니다. 아래는 웹링크의 인텐트 필터 샘플입니다. scheme가 http로 선언된걸 볼 수 있습니다. 12345678&lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.VIEW\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;category android:name=\"android.intent.category.BROWSABLE\" /&gt; &lt;data android:scheme=\"http\" /&gt; &lt;data android:host=\"myownpersonaldomain.com\" /&gt;&lt;/intent-filter&gt; 앱링크 앱링크는 안드로이드 6.0(API Level 23)에서 부터 사용이 가능한 기능입니다. 앱링크는 autoVerify라는 속성을 제공하는데 이 속성은 웹링크를 사용하더라도, 해당 도메인의 소유주가 확인이 되면 웹링크를 사용하는 다른 앱들이 있거나, 기본 브라우저 앱으로 등록이 되어 있지 않더라도 즉시 내가 만든 앱이 링크를 받을 수 있도록 해줍니다. 참고로 iOS에서는 앱링크와 유사한 개념으로 유니버셜 링크(Universal Link)를 제공합니다. 아래는 앱링크를 사용하는 인텐트 필터 샘플입니다. 웹링크와 다른점은 autoVerify속성이 추가되었고 이 값이 true로 세팅되었다는 점입니다. 12345678910&lt;intent-filter android:autoVerify=\"true\"&gt; &lt;action android:name=\"android.intent.action.VIEW\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;category android:name=\"android.intent.category.BROWSABLE\" /&gt; &lt;data android:scheme=\"http\" /&gt; &lt;data android:scheme=\"https\" /&gt; &lt;data android:host=\"myownpersonaldomain.com\" /&gt;&lt;/intent-filter&gt; 그럼 이렇게 인텐트 필터만 설정하면 앱링크가 동작할까요? 이것만으로는 부족합니다. 해당 도메인의 소유권이 나에게 있음을 확인할 수 있도록 ‘도메인 소유권 확인’ 처리를 해주어야합니다. 도메인 소유권 확인 절차가 없다면 아무나 동일한 링크를 선언할 수 있으니 딥링크와 다를게 없겠죠. 도메인 소유권 확인 도메인 소유권 확인은 디지털 애셋 링크 JSON 파일을 이용합니다. 특정한 포맷으로 구성된 JSON 파일을 아래의 위치에 업로드 하면 되는 방식입니다. https:///.well-known/assetlinks.json 내가 소유한 도메인에는 나만 파일을 올릴 수 있으니 이를 통해 소유권 확인이 되는 것이죠. 그럼 위에서 언급한 디지털 애셋 링크 JSON(assetlinks.json)은 어떻게 생겼을까요? 디지털 애셋 링크 디지털 애셋 링크의 생성은 아래 링크에서 어떻게 만들 수 있는지, 어떤 속성들이 있고 어떤 역할을 하는지에 대해 자세히 설명이 되어 있습니다. https://developer.android.com/studio/write/app-link-indexing 안드로이드 스튜디오의 Digital Asset Links File Generator를 이용하면 보다 편리하게 생성이 가능합니다. 기본적인 형태는 아래와 같습니다. 앱의 기본 정보와 사이닝 키의 해시 값이 들어갑니다. 업로드한 디지털 애셋 링크 파일에 있는 정보와 앱의 정보가 맞지 않으면 앱링크가 동작하지 않으니 주의깊게 디지털 애셋 링크 파일을 작성하고 테스트를 해야합니다. 123456789[{ \"relation\": [\"delegate_permission/common.handle_all_urls\"], \"target\": { \"namespace\": \"android_app\", \"package_name\": \"com.example\", \"sha256_cert_fingerprints\": [\"14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5\"] }}] 딥링크 vs 웹링크 vs 앱링크 지금까지 살펴본 딥링크와 웹링크, 그리고 앱링크의 관계는 아래와 같습니다. 딥링크는 앱에서 자유롭게 스킴을 포함한 URI를 정의 할 수 있기 때문에 자유도가 가장 높습니다. 하지만 딥링크가 충돌할 수 있는 위험이 있습니다. 웹링크는 스킴이 http 이거나 https인 링크를 말합니다. 즉 웹에서 사용되는 링크입니다. 안드로이드에서도 딥링크를 정의할 때 스킴을 http나 https로 정의함으로써 웹링크의 형태로 정의가 가능합니다. 하지만 이렇게 하면 딥링크가 제대로 동작하지 않습니다. 해당 웹링크가 얼마든지 중복이 될 수 있으니 결국 이것만으로는 딥링크와 다를게 없기 때문입니다. 이를 해결하기 위해 웹링크에 도메인 소유권 확인 절차를 추가한게 앱링크 입니다. 앱링크는 사용하고자 하는 도메인에 디지털 애셋 링크 JSON 파일을 업로드 함으로써 해당 도메인이 나의 소유임을 안드로이드 OS에서 알 수 있게 합니다. 그리고 이를 통해 다른 앱에서 동일한 링크를 선언했더라도 내 앱이 해당 링크를 처리할 수 있도록 보장해줍니다. 앱링크의 장단점 장점 도메인 소유권이 확인된 웹링크를 사용하기 때문에 앱 선택 다이얼로그가 뜨지 않아 더 좋은 유저 경험을 제공하고, 다른 앱과 링크가 중복되더라도 내가 만든 앱에서 링크를 받는게 보장됩니다. 안드로이드 인스턴트 앱 기능의 사용이 가능합니다. 인스턴트 앱은 앱의 설치 없이 앱의 일부 기능을 사용할 수 있도록 하는 기능입니다. 유저가 모바일 브라우저나, 구글 검색으로 웹링크 클릭으로 바로 앱의 컨텐츠에 접근이 가능하기 때문에 더 많은 유저 유입이 가능해집니다. 앱링크의 단점 도메인 소유권 확인 처리는 디지털 애셋 링크 생성 및 테스트, 파일 업로드의 과정을 걸치기 때문에 불편하고 추가로 시간과 노력이 필요합니다. 사용하는 도메인의 관리가 중요합니다. 실수로 도메인 연장을 하지 못했다면 해당 앱링크는 사용이 불가능합니다. 팀으로 작업 하는 경우 개발하는 머신마다 디버그 키가 다르기 때문에 디지털 애셋 링크 파일에 디버그 키의 해시 키 등록이 힘듭니다. 더 알아볼 것들 딥링크와 웹링크, 그리고 앱링크 까지 알았다면 안드로이드 앱에서의 링크에 대해 어느정도 알게된 것입니다. 하지만 실제 서비스를 개발할 때에는 마케팅이 필요하고 이를 위해 추가로 지연된 딥링크(Deferred Deep Links)와 파이어베이스(Firebase)에서 제공하는 지연된 딥링크 서비스인 다이나믹 링크(Dynamic Links)에 대해 알아두면 많은 도움이 됩니다. 지연된 딥링크 지연된 딥링크는 주로 마케팅에 많이 쓰이는데 마케팅을 통해 제공된 링크를 통해 앱의 설치를 유도하고 이에 대한 성과 측정을 위해 사용됩니다. UTM 코드라는 것과 함께 사용되며 여기에는 앱 설치를 위해 사용된 링크가 어디서 만들어졌는지, 어떤 캠페인에서 사용되었는지, 어떤 매체를 통해 공유되었는지 등의 정보가 들어갑니다. 즉 앱이 설치 되어 있지 않을때 앱의 설치를 유도 할 수 있고 설치 후 지연된 딥링크에 전달된 파라미터를 전달 받을 수 있습니다. 파이어베이스의 다이나믹 링크 파이어베이스의 다이나믹 링크는 파이어베이스에서 제공하는 지연된 딥링크 서비스입니다. 하나의 링크로 링크가 실행된 플랫폼에 따라 서로 다른 동작을 할 수 있도록 편리하게 구성할 수 있습니다. 또한 해당 링크를 받아서 처리할 수 있는 앱이 있는지 없는지에 따라 다른 동작을 정의할수도 있습니다. 예를 들어, 하나의 링크로 안드로이드에서 링크가 클릭되었다면 해당 링크를 실행할 수 있는 앱을 찾고 없다면 앱을 설치할 수 있도록 안드로이드 마켓으로, 있다면 앱으로 링크를 전달할 수 있습니다. 또한 대시보드를 통해 링크의 성과를 바로 볼 수도 있습니다. 단축 URL 기능도 제공을 하는데 이는 긴 URL을 짧은 URL로 바꿔주는 기능입니다. 즉 파이어베이스의 다이나믹 링크는 지연된 딥링크에 여러가지 추가 기능을 제공하는 솔루션 이라고 보면 됩니다. 그리고 이 솔루션의 핵심은 사실상 다이나믹 링크의 성과를 볼 수 있는 대시보드 일 것입니다. 즉 마케팅의 성과를 볼 수 있는 기능입니다. 결국 지연된 딥링크와 파이어베이스의 다이나믹 링크의 핵심은 마케팅을 위한 추가 기능이라고 보면 됩니다. 당연히 이런 서비스는 파이어베이스에서만 제공하는 것은 아니고, AppsFlyer 나 Branch 같은 다른 마케팅 솔루션 서비스에서도 제공합니다. 맺음말 안드로이드 앱 개발을 하다보면 딥링크는 반드시 사용해야 하는 기능입니다. 앱의 초기 세팅이나 기초에 해당하는 부분에 딥링크 처리가 반드시 들어갑니다. 개발자는 웹과의 연동이나, 마케팅을 위해 적절한 링크 기능을 제공해야합니다. 그리고 요구사항에 맞는 선택을 하기 위해서는 각각의 개념과 장단점을 잘 알아야합니다. 이런 개념을 전달하는 것이 이번 글의 목적입니다. 딥립크가 한계를 가지고 있지만 앱링크를 사용하지 않더라도 스킴을 잘 겹치지 않을만한 걸로 사용한다거나 하면 실제로는 앱링크를 사용하지 않는게 더 좋은 선택일 수도 있습니다. 앱링크는 도메인 소유권 확이이나, 관리, 디버그 모드에서의 불편함 등을 감안하면 공짜가 아닙니다. 물론 이것은 서비스와, 팀의 상황에 따라 달라지며 팀의 상황에 맞게 맞는 선택을 하기 위해서는 각각의 차이가 무엇인지, 어떤 문제점을 해결하기 위해 등장했는지, 장단점이 무엇인지를 잘 알아야합니다. 마지막으로 서비스를 잘 만드는 것 만큼이나 중요한 것이 마케팅입니다. 모바일 앱의 생태계가 이미 굉장히 성숙해져 있기 때문에 이제는 유저가 스스로 원하는 앱을 찾기보다는 이미 알고 있는 서비스만 사용하는 것이 트렌드입니다. 즉 신규 서비스의 경우 이제는 아무리 잘 만들어도 유저에게 노출 시키기가 굉장히 힘이듭니다. 따라서 운영중인 앱에 대한 마케팅을 준비하고 있다면 적절한 마케팅 서비스를 선택하고 이를 활용할 수 있도록 지연된 딥링크와 이를 제공하는 서비스에 대해 잘 알고 있는것이 중요합니다. 참고 자료 App Links Verify app links","link":"/2023/11/25/android/android-applinks/"},{"title":"CSS 글꼴(Font) 이야기","text":"CSS 글꼴 우리는 하루에도 수많은 글을 봅니다. 스마트폰으로 웹서핑을 하거나 책을 볼 때, 우연히 길에서 스쳐간 간판까지, 눈을 뜨고 있다면 의식적으로든, 무의식적으로든 글을 읽는 걸 피할 수 없죠. 글은 기본적으로 정보를 전달하지만 같은 글이라도 다양한 서체로 표현될 수 있습니다. 사람마다 글씨체가 모두 다른 것처럼 말이죠. 이에 따라 세상에는 굉장히 많은 글꼴이 개발되어 사용되고 있습니다. 애플의 스티브 잡스가 글꼴을 굉장히 중요하게 다루었다는건 굉장히 유명한 이야기입니다. 프로그래머인 저에게도 글꼴을 다룰일은 굉장히 많습니다. 개발하는 서비스에 따라 디자이너가 원하는 글꼴이 다르기 때문에 디자인 팀에서 선정한 글꼴을 적용해야합니다. 또한 개발환경을 세팅할 때 좋아하는 글꼴을 설치하고 이를 IDE에 적용하는 것은 마치 신성한 의식과도 같은 일입니다. 이번 글에서는 프로그래머로서 글꼴을 다룰 때 자주 마주치는 몇 가지 개념들에 대해 다루도록 하겠습니다. 세리프(Serif)와 산 세리프(Sans-Serif) 세리프(Serif) 세리프는 '장식’을 의미합니다. 위에 이미지에서 세리프 글꼴을 보면 선의 끝에 굴림 처리가 되어있고, 선의 굵기도 다른 특징을 가집니다. 한글로 치면 궁서체가, 영어로는 타임즈 뉴 로만(Times New Roman)이 대표적이죠. 보통 인쇄물에 많이 사용됩니다. 산 세리프(Sans-Serif) Sans는 '없음’을 나타냅니다. 즉 세리프가 없다라는 의미가 되니 장식이 없다라고 받아들이면 되겠죠? 위의 이미지에서 산 쉐리프 서체를 보면 선의 굵기가 동일하고 장식이 없습니다. 한글 글꼴에서는 고딕 서체들을 떠올리면 됩니다. 주로 모니터 화면에서 보는 서체에 많이 사용됩니다. 참고로 디지털 세상에서 산 세리프 글꼴이 자주 쓰이게 된건 과거에는 디스플레이 기능의 제약상 곡선을 매끄럽게 표현하기 어려워 세리프 글꼴을 표현하기 어려웠던 이유가 있었다고 하네요. 세리프와 산 세리프의 차이 둘의 차이를 위에서 간단히 살펴 보았습니다. 표면적으로는 글꼴에 '장식’이 있는지 없는지가 핵심이지만 조금만 더 이 둘의 차이를 알아보도록 하겠습니다. 먼저 세리프와 산 세리프의 차이는 가독성(readability)과 판독성(legibility)을 가지고 볼 수 있습니다. 가독성은 많은 양의 글을 볼 때의 읽기 쉬운 정도를 나타내는데 일반적으로 신문과 같은 인쇄물에서는 쉐리프가, 모니터 화면 상에서는 산세리프가 가독성이 높다고 봅니다. 다만 이건 사람에 따라, 익숙한 정도에 따라 달라지는 주관적인 부분입니다. 판독성은 각각의 글자가 정확히 어떤 글자를 나타내는지를 인식할 수 있는 정도를 나타냅니다. 예를 들어 i와 l은 글꼴에 따라 매우 비슷하게 보일 수 있습니다. 프로그래머가 코딩을 할 때 가장 먼저 프로그래밍 하기 좋은 글꼴을 설정하는데 그 이유가 여기에 있습니다. 프로그래머가 사용하는 글꼴들은 대부분 이 판독성이 좋은 것들이 많습니다. 아래의 예는 네이버에서 만든 D2Coding 이라는 글꼴입니다. 이미지를 보시면 헷갈리기 쉬운 글자들이 구분되기 쉽도록 신경을 많이 쓴 것이 느껴 지시나요? 그리고 이런 노력들이 앞에서 이야기한 판독성을 높여줍니다. 모노스케이프(Monoscape) 앞에서 세리프와 산 세리프에 대해 알아보았습니다. 그럼 두 번째. 글꼴을 이야기 할 때 모노스케이프는 무엇을 의미하는 걸까요? 답은 간단합니다. 모노스케이프 글꼴을 모든 글자의 가로길이가 같은 글꼴을 이야기합니다. 모노스케이프란 단어 자체가 고정너비라는 뜻이기도 합니다. 그럼 모노스케이프 글꼴은 언제 주로 사용할까요? 바로 프로그래밍을 할 때 가장 많이 선택 합니다. 글꼴이 고정너비여야만 코드가 동일한 간격으로 정렬되어 편집도 쉽고 보기도 좋기 때문이죠. 엄밀히 말하면 보통 모노스케이프이면서 산 세리프인 글꼴을 많이 사용합니다. 참고로 저는 코딩을 할 때 D2Coding이나 나눔고딕코딩 글꼴을 주로 사용하는데요. 이 두 글꼴은 한국에서 개발된 글꼴이라 한글도 잘 지원이 되고 무료이기까지 합니다. 아무래도 우린 한국 사람이니 코드를 짜다보면 주석이나, 코드 자체에도 한글이 들어갈 일이 생깁니다. 이럴 때 외국에서 만든 글꼴을 쓰면 한글이 예쁘게 나오지 않는 경우가 많은데(폰트에 한글 자체가 아예 안들어가 있기 때문에) D2Coding이나 나눔고딕코딩을 쓰면 이런 문제가 깨끗이 해결됩니다. 참고로 이 두 글꼴은 네이버에서 만든 글꼴입니다. 한때 제가 몸담았던 회사라 괜히 더 애정이 가네요. :) 폰트 패밀리(Font Families) 글꼴은 우리가 글을 사용하며 함께 발전해 왔습니다. 어떤 운영체제를 사용하든 글꼴 설정에 들어가서 내가 사용할 수 있는 글꼴을 확인해 보면 그 숫자에 아마 놀라실겁니다. 이렇게 많은 글꼴중에 원하는 글꼴을 좀 더 쉽게 적용하려면 어떻게 해야할까요? 그리고 내가 사용하려고 하는 글꼴이 시스템에 설치가 되어있지 않다면 어떻게 해야할까요? 폰트 패밀리는 이런 문제를 해결해 줍니다. 아래는 CSS에서 폰트 패밀리를 설정하는 예제입니다. 아래 코드는 이렇게 읽을 수 있습니다. 시스템에 Verdana 글꼴이 있으면 Verdana를, 없으면 Arial을, Arial도 없으면 산 세리프 글꼴 중에 하나를 사용해주세요. 1font-family: Verdana, Arial, sans-serif; 즉 글꼴이 없는 경우를 대비해서 좌측에서부터 순서대로 예비 글꼴을 지정할 수 있는 것이죠. 이때 특정 글꼴을 지정하거나, 앞서 우리가 배웠던 글꼴의 형태를 지정해 줄 수 있습니다. 위의 예에서는 산 세리프(sans-serif) 부분이 이에 해당합니다. 마무리 이번 글에서는 프로그래머로서 글꼴을 다룰 때 알아야할 아래의 세 가지 주요 개념에 대해 알아보았습니다. 세리프와 산 세리프 모노스케이프 폰트 패밀리 세리프와 산 세리프, 모노스케이프는 글꼴에 대한 전반적인 개념이고 폰트 패밀리는 CSS에서 글꼴을 지정하는 방식입니다. 폰트 패밀리는 CSS에서 대표적으로 사용되지만 다른 언어나, 툴 등에서도 자주 사용됩니다. 다만 사용되는 곳에 따라 구체적인 사용법은 조금 다를 수 있습니다. 하지만 우리는 개념을 알고 있으니 문서를 보면 금방 이해하고 적용할 수 있겠죠?","link":"/2020/04/30/web/css-font/"},{"title":"자바와 코틀린에서의 변성(Variance in Java and Kotlin)","text":"들어가며 코틀린 코드에서 자주 보게되는 in과 out, 그리고 자바에서 자주 보게 되는 &lt;? extends T&gt;, &lt;? super T&gt; 는 제네릭의 변성과 깊은 관련이 있습니다. 이 글에서는 자바와 코틀린과 같은 객체지향 프로그래밍 언어에서 사용되는 변성의 개념을 살펴 보도록 하겠습니다. 서브타입과 다형성(Subtypes and Polymorphism) 객체지향 프로그래밍 언어에서는 클래스의 상속이나 인터페이스, 추상클래스를 이용하여 객체를 모델링 합니다. 추상화된 개념을 이용하여 슈퍼타입을 만들면 이로부터 슈퍼타입을 구체화 하는 서브타입을 만들어 낼 수 있습니다. 서브타입은 슈퍼타입에 정의된 기능과 속성을 상속받아 그대로 사용하거나 필요에 따라 재정의할 수 있습니다. 서브타입을 인스턴스화 할 때 해당 인스턴스는 그 슈퍼타입으로 받아 사용이 가능합니다. 이를 다형성이라고 합니다. 다형성은 객체지향 프로그래밍의 핵심 기능으로 아주 강력한 편의성과 확장성을 가져다 주는 도구입니다. 이를테면 동물이라는 추상화를 하고 이를 구체화하는 개, 고양이와 같은 서브타입을 만들 수 있는데 이를 서브타이핑이라 하고, 동물이란 타입을 이용하여 개나 고양이 객체를 받아서 동물에 정의된 공통 동작과 속성을 사용하는 것을 다형성 이라고 합니다. 객체 지향 프로그래밍 언어에서 갖는 설계상 이점의 아주 큰 부분이 다형성을 바탕으로 존재합니다. 예제 코드 12345678910111213141516171819202122232425262728// Super classopen class Animal { open fun makeSound() { println(\"Animal makes a sound\") }}// Sub classclass Dog : Animal() { override fun makeSound() { println(\"Bark\") }}// Sub classclass Cat : Animal() { override fun makeSound() { println(\"Meow\") }}fun main() { val myDog: Animal = Dog() val myCat: Animal = Cat() myDog.makeSound() // Outputs: Bark myCat.makeSound() // Outputs: Meow} 제네릭(Generics) 제네릭은 객체지향 프로그래밍을 지원하는 언어에서 타입 안정성을 제공하면서도 다양한 타입을 다룰 수 있는 방법으로 제공됩니다. 클래스, 인터페이스, 함수를 정의 할 때 타입을 플레이스홀더로 지정하는 방식으로 사용합니다. 이해를 돕기 위한 예를 들자면 제네릭은 라벨이 붙은 상자라고 볼 수 있습니다. 상자에 붙은 라벨에 따라 이 박스는 Animal을 넣거나, Dog, Cat 을 넣을 수 있습니다. 제네릭 클래스(Generic Classes) 123class Box&lt;T&gt;(t: T) { var value = t} 제네릭 함수(Generic Functions) 123fun &lt;T&gt; singletonList(item: T): List&lt;T&gt; { return listOf(item)} 변성(Variance) 앞서 서브타이핑, 다형성, 그리고 제네릭에 대해 설명했습니다. 그럼 Box&lt;T&gt;라는 제네릭 타입이 있을 때, Box&lt;Animal&gt;과 Box&lt;Dog&gt;, Box&lt;Cat&gt; 사이에도 Animal, Dog, Cat 사이에 있었던 서브타이핑 관계가 유지될까요? 변성이란 바로 서브타이핑 관계에 있는 타입들이 제네릭에서 갖는 성질입니다. 변성은 불변성(Invariance), 공변성(Covariance), 반공변성(Contravariance) 의 세 가지 성질을 가집니다. 불변성(Invariance) 자바나 코틀린에서는 다형성으로 인해 S가 T의 서브타입이면 T = S가 가능하지만, Box&lt;T&gt; = Box&lt;S&gt;는 기본적으로 허용되지 않습니다. 이것이 제네릭의 불변성입니다. 한마디로 제네릭 타입 간에는 다형성과 같은 규칙이 적용되지 않습니다. 아래와 같은 코드는 잘 동작하지만, 1234class Animalclass Dog: Animalval animal: Animal = Dog() 아래와 같은 코드는 허용되지 않습니다. 12345class Animalclass Dog: Animalclass Box&lt;T&gt;(var t: T)val animalBox: Box&lt;Animal&gt; = Box&lt;Dog&gt;(Dog()) 제네릭 타입이 불변인 이유 그렇다면 제네릭이 불변성을 갖는 이유는 무엇일까요? 이는 런타임 타입 안정성 때문입니다. 예를들어 자바에서 Object는 모든 타입의 슈퍼타입이지만 다형성에서 허용하듯 제네릭에서도 이를 허용하면 아래와 같은 경우 런타임 타입 안정성이 깨지게 됩니다. 12345678910// 다형성에서는 슈퍼타입이 서브타입을 받을 수 있다.Animal obj = new Dog();// 제네릭 타입에서는 다형성에서의 타입 관계가 허용되지 않는다.List&lt;Dog&gt; dogs = new ArrayList&lt;Dog&gt;();List&lt;Animal&gt; animals = dogs; // 컴파일이 되지 않음!// 컴파일이 됐다면 아래 코드에서 런타임 에러 발생animals.add(Cat()); // 쓰기: animals는 사실 ArrayList&lt;Dog&gt;이므로 Cat을 넣을 수 없음Dog s = dogs.get(0); // 읽기: dogs는 ArrayList&lt;Dog&gt;이지만 Cat을 반환하게 됨 공변성(Covariance)과 반공변성(Contravariance) 공변성과 반공변성은 불변의 위험성이 없는 경우, 즉 런타임 타입 안정성이 보장되는 경우 불변의 제약을 제한적으로 풀어주는 것 입니다. 공변성과 반공변성이 필요한 이유 제네릭 타입이 불변이어야 하는 이유는, 런타임 타입 안정성을 유지하기 위한 것입니다. 공변성과 반공변성은 이러한 제약을 완화하면서도 안전성을 보장할 수 있는 경우에 사용됩니다. 예제에서 처럼 런타임 타입 안정성이 깨지는 경우도 있지만 안전한 경우도 있습니다. 이런 경우에는 불변성이라는 제약이 필요없습니다. 그렇다면 이런 경우에는 제한적으로라도 불변성 이라는 제약을 풀어줄 수 있지 않을까요? 공변성(Covariance) 공변성에서는 한 타입이 다른 타입의 서브타입이면, 그 제네릭 타입도 서브타입 관계를 유지합니다. 예를 들어, Dog이 Animal의 서브타입인 경우, List&lt;Dog&gt;을 List&lt;Animal&gt;의 서브타입으로 간주할 수 있습니다. 공변성의 조건 공변성이 성립하기 위해서는 제네릭 타입이 데이터를 쓰지 않고, 오직 읽기만 가능해야합니다. 그리고 데이터를 읽을 때는 제네릭에서 사용하는 타입의 슈퍼타입으로만 데이터를 읽어와야합니다. 데이터를 쓰지 않고 제공(읽기)만 하기 때문에 우리는 이것을 생산자 라고도 부릅니다. 자바에서 제네릭 타입에 공변성 부여하기 자바에서는 상한 와일드 카드(Upper bound wild card)를 이용하여 공변성을 부여할 수 있습니다. 아래 코드에서 보면 &lt;? extends E&gt;가 상한 와일드 카드입니다. 123interface Collection&lt;E&gt; ... { boolean addAll(Collection&lt;? extends E&gt; items);} 상한 와일드 카드는 제네릭 타입의 E에 E 또는 E 의 서브타입이 들어올 수 있도록 컴파일러에 알려줍니다. 상한 와일드 카드는 읽기만 허용하고 쓰기는 허용하지 않습니다. 쓰기를 허용하지 않는 것은 제약이지만 이 제약 덕분에 앞서 설명한 런타임 타입 안정성이 깨지는 상황을 막을 수 있습니다. 잘 생각해보면 제네릭에 공변성을 부여하는 것은 불변성의 제약을 제네릭 타입에 쓰기를 허용하지 않는 제약으로 바꾸는 걸로도 볼 수 있습니다. 앞서 공변성을 줄 수 있는 조건에 대한 설명과도 딱 맞아 떨어집니다. Collection의 addAll()이 공변성이 없이 아래와 같이 선언이 되었다면 우리는 animals.addAll(dogs) 같은 코드를 사용할 수 없었을 것 입니다. 123interface Collection&lt;E&gt; ... { boolean addAll(Collection&lt;E&gt; items);} 코틀린에서 제네릭 타입에 공변성 부여하기 이번에는 코틀린에서의 공변성을 부여하는 방법에 대해 알아보도록 하겠습니다. 아래 Source 인터페이스를 보면 T를 반환하는 메소드만 존재합니다. 123interface Source&lt;T&gt; { fun nextT(): T} 이 인터페이스는 T 타입을 반환하는 코드만 있기 때문에 공변성을 부여할 수 있는 조건에 해당합니다. 즉 이 제네릭 인터페이스는 값을 생산(읽기) 하기만 할 뿐 쓰는 동작을 하지 않는 생산자입니다. 하지만 그럼에도 불구하고 아래와 같은 코드는 컴파일 에러를 발생 시키며 허용하지 않습니다. 1234void demo(Source&lt;String&gt; strs) { Source&lt;Object&gt; objects = strs; // !!! Not allowed in Java // ...} 이는 앞서 설명한 대로 제네릭이 불변이기 때문입니다. 자바에 Source&lt;T&gt; 가 안전하다는걸 알려주기 위해 앞서 배웠던 상한 와일드 카드를 이용해서 아래와 같이 수정이 가능합니다. 1234void demo(Source&lt;? extends Object&gt; strs) { Source&lt;Object&gt; objects = strs; // ...} 자바에서처럼 제네릭 타입을 사용할 때마다 사용하는 곳에서 상한 와일드 카드를 사용해서 공변성을 부여하는 것을 사용 지점 변성(use-site variance) 이라고 합니다. 하지만 이렇게 매번 반복하는 것은 번거롭습니다. 코틀린에서는 선언 지점 변성(Declaration-site variance) 을 이용하여 이를 좀 더 편리하게 사용할 수 있습니다. 선언 지점 변성은 제네릭 타입이 이미 공변성이나 반공변성을 만족한다면 제네릭 타입의 선언 시점에 이를 함께 선언해줄 수 있습니다. (참고로 코틀린에서는 사용 지점 변성과 선언 지점 변성을 둘 다 지원합니다.) 즉 코틀린에서는 매번 공변성을 사용할때마다 상한 와일드 카드를 사용하는 것이 아니라 Source 인터페이스를 선언하면서 T 앞에 out 이라는 키워드를 추가하는 방식으로 한번에 공변성 부여가 가능합니다. 12345678interface Source&lt;out T&gt; { fun nextT(): T}fun demo(strs: Source&lt;String&gt;) { val objects: Source&lt;Any&gt; = strs // This is OK, since T is an out-parameter // ...} 다만 out 키워드를 이용해 선언 지점 변성을 사용하기 위해서는 제네릭 타입이 공변성의 조건에 부합해야합니다. 그러기 위해서는 해당 제네릭 타입은 쓰기 동작이 없고, 읽기 동작만 있어야합니다. 읽기 동작은 데이터를 생산 하는 것을 의미 합니다. 따라서 T는 이제 out-position 에서만 사용이 가능합니다. 이는 T가 제네릭 클래스 내 함수의 리턴 타입 위치, 또는 퍼블릭 속성으로만 사용이 가능하다는 의미입니다. 이렇게 T가 제네릭 클래스 안에서 out-position 에서만 사용이 되는 경우 이 제네릭 클래스는 T의 생산자라고 합니다. 이런 경우 해당 클래스 또는 인터페이스는 T를 소비하지 않고 생산만 하기 때문에 out 키워드를 통해 제네릭 타입의 선언 시점에 공변성 부여가 가능합니다. 공변성을 말할 때는 아래의 네 가지를 떠올리면 이해가 빠릅니다. Upper Bounded Wildcards (&lt;? extends Type&gt;) out producer read 반공변성(Contravariance) 반공변성에서는 한 타입이 다른 타입의 서브타입이면, 그 제네릭 타입은 슈퍼타입 관계를 유지합니다. 예를 들어, Dog이 Animal의 서브타입인 경우, List&lt;Animal&gt;은 List&lt;Dog&gt;의 슈퍼타입으로 간주할 수 있습니다. 반공변성의 조건 반공변성은 데이터를 소비(쓰기)만 하는 경우 안전하게 사용이 가능합니다. 읽기도 가능은 하지만 이 경우 안전하게 사용하기 위해서는 자바에서는 Object, 코틀린에서는 Any와 같이 가장 범용적인 타입으로 가져와야 안전하게 사용이 가능합니다. 데이터를 쓰는데 사용되기 때문에 이를 소비자 라고 부릅니다. 자바에서 제네릭 타입에 반공변성 부여하기 자바에서는 하한 와일드 카드(Lower bound wild card)를 이용하여 반공변성을 부여할 수 있습니다. 아래 코드에서 보면 &lt;? super E&gt;가 하한 와일드 카드입니다. 1public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) sort 메서드는 List&lt;T&gt;의 원소들을 정렬하는 데 사용되며, Comparator&lt;? super T&gt; 타입의 Comparator를 인자로 받습니다. Comparator는 리스트의 원소 타입 T 또는 T의 슈퍼타입 객체들을 비교할 수 있습니다. Comparator&lt;? super T&gt;는 T 타입 또는 T의 어떤 슈퍼타입을 사용하여 두 객체를 비교할 수 있습니다. 이는 Comparator가 반공변적임을 의미하는데, T의 슈퍼타입에 대해 비교 기능을 제공할 수 있기 때문입니다. 1234567891011121314151617181920212223242526272829class Animal { int age; public Animal(int age) { this.age = age; }}class Dog extends Animal { public Dog(int age) { super(age); }}class AnimalAgeComparator implements Comparator&lt;Animal&gt; { public int compare(Animal a1, Animal a2) { return Integer.compare(a1.age, a2.age); }}public static void main(String[] args) { List&lt;Dog&gt; dogs = new ArrayList&lt;&gt;(); dogs.add(new Dog(5)); dogs.add(new Dog(2)); dogs.add(new Dog(9)); // AnimalAgeComparator는 Comparator&lt;Animal&gt;이지만, 여기서는 Dog 리스트를 정렬하는 데 사용됩니다. Collections.sort(dogs, new AnimalAgeComparator());} 위 예제에서 AnimalAgeComparator는 Animal 객체들을 나이에 따라 비교합니다. Collections.sort() 메서드는 이 비교자를 사용하여 Dog 객체의 리스트를 정렬할 수 있습니다. 이는 Comparator&lt;Animal&gt;이 Dog의 슈퍼타입인 Animal을 처리할 수 있기 때문입니다. 이 예제에서 Comparator&lt;? super T&gt;의 반공변성을 통해 Dog 리스트를 정렬하는 데 Animal을 대상으로 하는 Comparator를 사용할 수 있습니다. 코틀린에서 제네릭 타입에 반공변성 부여하기 아래 예제는 코틀린의 Comparable 제네릭 인터페이스 입니다. Comparable 은 operator fun compareTo(other: T): Int 메소드만 가지고 있습니다. 이 메소드는 T 타입을 파라미터로 받아서 소비하기만 합니다. 따라서 in 키워드를 통해 Comparable에 반공변성을 부여할 수 있습니다. 12345678interface Comparable&lt;in T&gt; { operator fun compareTo(other: T): Int}fun demo(x: Comparable&lt;Animal&gt;) { x.compareTo(Dog()) val y: Comparable&lt;Dog&gt; = x} 코드를 보면 x: Comparable&lt;Animal&gt; 를 가지고 Animal의 서브타입인 Dog와 값 비교를 하고, val y: Comparable&lt;Dog&gt; = x 역시 가능함을 볼 수 있습니다. 반공변성을 말할 때는 아래의 네 가지를 떠올리면 이해가 빠릅니다. Lower Bounded Wildcards (&lt;? super Type&gt;) in consumer write 마치며 변성에 대한 이해가 부족하여 공부를 할겸 작성한 글입니다. 변성이란 개념은 처음에는 다소 이해하기가 어렵지만 잘 이해해둔다면 다른 코드를 읽거나, 제네릭을 이용한 객체지향 설계 능력을 향상 시키는데 큰 도움이 될거라 생각합니다. 개인적으로는 이 개념을 이해하는게 참 힘들었는데 이 글이 다른 분들에게도 아주 조금이나마 도움이 되었으면 좋겠습니다. 참고 제네릭(코틀린 공식 문서) Variance… without Generics!","link":"/2024/04/13/kotlin/variance%20in%20kotlin%20and%20java/"},{"title":"웹링크 미리보기 화면 보여주기(OGTag)","text":"웹서핑을 하다보면 재미있는 글이나 자료들을 URL 링크 형태로 공유하는 경우가 많이 있습니다. 하지만 단순히 URL만 보게되면 보는 사람 입장에서는 해당 링크가 어떤 웹페이지인지 알기가 어렵죠. 그래서 많은 앱과 서비스에서 아래와 같이 해당 페이지에 대한 미리보기(제목, 설명, 이미지)를 제공합니다. 이런 화면을 보여주기 위해 사용되는 가장 기본적인 방법은 OGTag(Open Graph Meta Tag)를 이용하는 방법입니다. OGTag는 웹페이지에 대한 간단한 정보를 html에 입력해두고 이 페이지를 보여주는 앱이나 서비스에서 이를 이용해 위의 스크린 샷과 같이 페이지에 대한 간략한 정보를 보기 쉽게 보여줄 수 있도록 하는 것입니다. 아래는 html에 OGTag를 입력하는 예입니다. 1234567891011&lt;head&gt;......&lt;meta property=\"og:title\" content=\"test\"/&gt;&lt;meta property=\"og:type\" content=\"article\"/&gt;&lt;meta property=\"og:url\" content=\"https://rootree.net\"/&gt;&lt;meta property=\"og:description\" content=\"This is a description.\"/&gt;&lt;meta property=\"og:image\" content=\"https://img.jpg\"/&gt;&lt;meta property=\"og:image:width\" content=\"1200\" /&gt;&lt;meta property=\"og:image:height\" content=\"627\" /&gt;......&lt;/head&gt; 보시면 property가 og:xxx인 메타 태그들이 있는데요. 이것들이 바로 OGTag 입니다. 메타 태그는 본래 해당 페이지를 설명하는 정보들을 넣기위한 태그입니다. 검색엔진이 웹페이지를 검색하거나 웹브라우저가 해당 페이지를 정확하게 보여주기 위해 도움이 되는 정보 등으로 사용됩니다. 이중에서도 Open Graph Meta Tag는 사용자가 웹사이트를 페이스북에 공유하기 좋게 하기 위한 목적으로 만들어졌습니다. 이와 유사한 걸로는 트위터의 card 태그가 있습니다. 위와 같이 og:xxx 태그를 입력해둔 웹페이지를 페이스북에 공유하면 페이스북에서는 이 태그들을 이용해서 해당 페이지의 링크를 마치 페이스북의 오브젝트처럼 다루어서 보다 예쁘게 보여줍니다. 아래 이미지는 페이스북에 링크를 공유했을때 보여지는 화면인데요. 이걸 보시면 바로 이해가 가실겁니다. 제가 공유한건 단순히 https://naver.com 이란 URL인데 아래와 같이 페이스북에서 자체적으로 예쁘게 보여주죠. 지금은 페이스북이 아니라 밴드, 라인, 카톡등 다른 서비스에서도 이를 이용해서 비슷하게 미리보기를 해주고 있습니다. Open Graph Meta Tag는 페이스북의 Open Graph Protocol에 정의가 되어있습니다. 이에 대한 자세한 설명은 아래 링크에서 확인 가능합니다. 지금까지 소개에선 타이틀, 설명, 썸네일 이미지 정도의 정보를 보여줄 수 있다는 정도였지만 실제로는 OGTag를 이용해 동영상, 음악 같은 것들도 표현할 수 있습니다. 또한 아래의 Open Graph Protocol 페이지에 가면 언어별 파서 및 플러그인, 개발 도구 등도 보실 수 있습니다. Open Graph Protocol Open Graph API 그럼 안드로이드 앱에서 OGTag를 이용하려면 어떻게 하면 될까요? 아주 간단합니다. 링크를 입력 받는다. 해당 링크의 html을 가져와 OGTag를 파싱한다. 2에서 파싱된 OGTag 정보를 가지고 원하는 UI로 예쁘게 보여준다. 위의 과정을 간단히 코드로 구현해 보았습니다. Jsoup를 통해 html을 가져오고 여기서 OGTag를 파싱하는 코드입니다. 간단히 위의 로직만 옮긴 코드라서 슈도코드 정도 느낌으로 참고만 하면 될 것 같습니다. 1234567891011121314151617181920212223242526272829private void getOGTag(String url, final OGTag ret) { // 입력받은 url에 해당하는 html을 요청하고 OGTag들을 가져온다. try { Connection con = Jsoup.connect(url); Document doc = con.get(); Elements ogTags = doc.select(\"meta[property^=og:]\"); if (ogTags.size() &lt;= 0) { return; } // 필요한 OGTag를 추려낸다 for (int i = 0; i &lt; ogTags.size(); i++) { Element tag = ogTags.get(i); String text = tag.attr(\"property\"); if (\"og:url\".equals(text)) { ret.setOgUrl(tag.attr(\"content\")); } else if (\"og:image\".equals(text)) { ret.setOgImageUrl(tag.attr(\"content\")); } else if (\"og:description\".equals(text)) { ret.setOgDescription(tag.attr(\"content\")); } else if (\"og:title\".equals(text)) { ret.setOgTitle(tag.attr(\"content\")); } } } catch (IOException e) { return; }} 조금 더 생각해볼 것들 서비스 적용하기 위의 예는 아주 간단한 구현이지만 실제로 서비스에 적용하려면 성능과 네트워크 사용에 대한 부분도 생각해봐야합니다. 링크가 PC 페이지인 경우 html 자체도 상당한 크기를 가질 수 있기때문에 이 자체도 부담이 될 수 있습니다. 따라서 매번 URL을 통해 OGTag를 파싱하는 건 쓸데없이 네트워크 트래픽 및 성능 상 낭비가 될 수 있습니다. 이를 피하기 위해서는 중간에 서버를 두거나, 캐싱을 사용하는 건데요. 서버를 두는건 OGTag를 통해 얻을 수 있는 장점에 비해 너무 큰 리소스가 들어가는 문제가 있습니다. 또한 서버를 두든 앱에서 로컬 캐싱을 하든 웹페이지의 OGTag를 실시간으로 반영하기 어렵다는 이슈가 있습니다. 따라서 서비스에 따라 상황에 맞춰 적절히 적용하는 센스가 필요합니다. 앱개발자 입장에서는 며칠 단위의 로컬 캐시를 만들어서 서버없이 간단히 구현하는 방식도 좋을것 같습니다. OGTag가 없는 경우 OGTag를 사용자가 넣어두지 않은 경우에도 URL미리보기를 적용하고 싶다면 html내에서 적당한 이미지와 타이틀, 설명을 뽑아서 사용하면 됩니다. 가령 타이틀은 메타 태그의 title을, 설명은 description을 사용한다든지, 아니면 본문의 텍스트 중 앞부분에서 적당히 잘라서 쓴다든지 하는 것이죠. 이미지 역시 div 또는 body안에서 첫번째 이미지를 찾아서 가져 올 수 있겠죠. 이런 부분은 정답이 없기에 성능이나 정책을 적당히 고려해서 적용하면 될 것 같습니다. 페이스북의 OGTag 처리 참고로 페이스북은 서버단에서 OGTag를 처리하고 자체적으로 캐싱도 해주고 있습니다. 사용자의 포스팅을 피드 형식으로 보여주니 당연한거 같기도 합니다. 사용자가 포스팅에 URL을 첨부하면 페이스북 크롤러가 해당 페이지의 OGTag를 캐싱해서 피드에 내려주는 방식입니다. 성능 이슈 때문인지 캐싱된 OGTag는 크롤링 될 때의 스냅샷이 저장되고 개발자 콘솔에서 캐시를 초기화 해주지 않으면 OGTag가 수정되어도 반영이 되지 않습니다. 폴라에는 각 엔드나 프로필등의 주요화면에 URL 공유하기 기능이 있는데요. 위와 같은 이슈때문에 공유하기 URL을 생성할때 앱에서 URL 뒤에 타임스탬프를 붙여서 이를 회피하고 있습니다(캐싱이 되지 않도록). 그리고 OGTag가 없더라도 타이틀, 설명, 이미지를 적당히 가져와서 보여줍니다. 페이스북 크롤러가 미리보기에 사용할 값을들 파싱할때 OGTag가 있으면 OGTag를, 없으면 다른 곳에서 데이터를 가져오도록 구현되어 있는듯 하네요. http://develope.android.com 페이지를 가지고 테스트 해봤더니(ogtag가 없는 페이지) 타이틀은 title, 설명은 description을 가져옵니다. 이미지는 첫번째 이미지가 아니고 중간에 있는걸 가져오는데 뭘 기준으로 고르는지는 잘 모르겠네요. 마무리 폴라에서 공유하기 기능을 개발하면서 단순히 URL링크만 공유했는데 어떻게 다른 서비스에서는 저렇게 링크를 보기좋게 보여줄까 하고 궁금했습니다. 다른 분께도 이 글이 도움이 되면 좋겠습니다","link":"/2016/03/30/web/web-ogtag/"},{"title":"코틀린에서의 위임(Delegation in Kotlin)","text":"위임(Delegation)의 개념 위임은 다른 사람에게 나의 일을 맡기는 행위라고 할 수 있습니다. 제가 까페를 운영한다고 합시다. 까페를 운영하는 일은 매장관리, 재고관리, 홍보, 음료 준비 등 다양한 일을 포함합니다. 이를 혼자 다하는건 아주 힘든 일입니다. 그래서 저는 숙련된 바리스타인 &quot;동동이&quot;를 고용했습니다. 동동이는 손님이 오면 음료 준비와 관련된 모든 업무를 수행합니다. 즉 저는 동동이에게 음료 준비를 위임 함으로써 까페 운영을 위한 다른 업무에 집중하고, 좀 더 효율적으로 까페를 운영할 수 있게 되었습니다. 구성요소 위의 예제에서 까페 사장인 저는 델리게이터(Delegator), 바리스타로 고용된 동동이는 델리게이트(Delegate)라고 합니다. 델리게이터는 일을 떠넘기는 사람이고, 델리게이트는 일을 대신 받아서 해주는 사람입니다. 프로그래밍에서의 위임 직관적으로 위임을 잘 사용하면 내가 하려고 하는 일을 좀 더 효율적으로 할 수 있다는 것은 명확합니다. 그럼 프로그래밍의 세계에서는 위임이 구체적으로 어떤 방식으로 우리 일을 효율적으로 할 수 있도록 도와 줄까요? 위임의 장점 위임의 장점을 코드의 관점에서 바라보면 크게 아래 세 가지로 나눌 수 있습니다. 코드의 재사용성 동동이는 바리스타로서 음료 준비의 전문가입니다. 손님으로 부터 주문을 받으면 계속 동동이를 이용해서 음료를 제공할 수 있습니다. 제가 새로운 까페 체인점을 만든다면 다른 체인점에서 동동이를 쓸 수도 있겠죠. 잠시 일을 도우러 온 알바 생이 궁금한게 있으면 동동이에게 도움을 받을 수도 있습니다. 이렇게 바리스타로서 음료의 전문가인 동동이로부터 음료와 완련된 모든 일들에 걸쳐 도움 받을 수 있으니 재사용성이 높습니다. 관심사의 분리(SoC - Separation of Concerns) 까페의 사장으로서 저는 까페의 운영이라는 작업에 집중하고 음료 준비와 관련된 일들은 전문가인 동동이에게 맡길 수 있습니다. 즉 까페 운영이라는 관심사와 음료 준비라는 관심사가 분리되었습니다. 확장성 &amp; 동적 행위 변경 음료의 퀄리티나 스타일을 바꾸고 싶으면 동동이를 변경하거나, 동동이를 해고하고 다른 바리스타를 고용하기만 하면 됩니다. 까페의 다른 구성요소의 변경 없이 최소한의 수정으로 런타임에 행위를 변경할 수 있습니다. 기본 사용법 - 클래스 위임 클래스 위임을 이용하면 인터페이스의 구현을 다른 델리게이트에게 넘길 수 있습니다. 즉 인터페이스의 기능(함수)와 데이터(속성)를 직접 구현할 필요 없이 다른 객체를 이용해서 처리할 수 있습니다. 인터페이스의 구현을 특정 델리게이트로 위임하기 아래의 예제를 보면 Barista를 구현하는 클래스를 생성하면서 by 키워드를 이용하여 Barista의 구현을 특정 델리게이트로 넘길 수 있습니다. 여기서는 Barista를 구현하는 StarbucksBarista 또는 EdiyaBarista 둘 중 하나가 되겠네요. 12345678910111213141516171819202122232425262728293031// Interfaceinterface Barista { fun makeCoffee()}// Delegateclass StarbucksBarista : Barista { override fun makeCoffee() { println(\"Make Starbucks-style coffee\") }}// Delegateclass EdiyaBarista : Barista { override fun makeCoffee() { println(\"Make Ediya-style coffee\") }}// Delegator: Cafe, Delegate: StarbucksBaristaclass StarbucksCafe(): Barista by StarbucksBarista// Delegator: Cafe, Delegate: EdiyaBaristaclass EdiyaCafe(): Barista by EdiyaBarista// Usagefun main() { val starbucks = StarbucksCafe() starbucks.makeCoffee() val ediya = EdiyaCafe() ediya.makeCoffee()} 인터페이스의 구현을 생성자를 이용하여 특정 델리게이트로 위임 하기 좀 더 유연하게 쓰고 싶다면 아래 처럼 쓸 수 있습니다. 생성자를 통해 Barista 인터페이스를 구현하는 구현체를 넘기는 방식입니다. Cafe 클래스에 Barista만 바꿔서 생성하면 되니 좀 더 유연하다고 할 수 있겠네요. 이 방법은 처음 방식보다 조금 더 유연하지만 여전히 객체의 생성 시 바리스타가 고정되며, 이후 바리스타를 바꾸는 것은 불가능합니다. 까페를 개업할 때 바리스타를 고용해서 평생 함께 가는거네요. 바리스타 입장에선 고용 안정이 되어서 좋지만 사장 입장에선 자유롭게 바리스타를 바꿀 수 있었으면 좋겠습니다. 1234567891011121314151617181920212223242526272829// Interfaceinterface Barista { fun makeCoffee()}// Delegateclass StarbucksBarista : Barista { override fun makeCoffee() { println(\"Make Starbucks-style coffee\") }}// Delegateclass EdiyaBarista : Barista { override fun makeCoffee() { println(\"Make Ediya-style coffee\") }}// Delegator: Cafe, Delegate: baristaclass Cafe(barista: Barista): Barista by barista// Usage of Cafefun main { val starbucks = Cafe(StarbucksBarista()) starbucks.makeCoffee() val ediya = Cafe(EdiyaBarista()) ediya.makeCoffee()} 동적으로 델리게이트 변경하기 동적으로 런타임에 새로운 객체 생성 없이 바리스타를 바꾸고 싶다면 이렇게 하면 됩니다. 델리게이터인 Cafe 객체를 생성할 때 델리게이트를 넣어줄 수도 있지만 changeBarista를 이용하여 객체의 재 생성 없이 델리게이트를 변경 할 수 있습니다. 123456789101112131415161718192021222324252627282930313233343536373839// Interfaceinterface Barista { fun makeCoffee()}// Delegateclass StarbucksBarista : Barista { override fun makeCoffee() { println(\"Make Starbucks-style coffee\") }}// Delegateclass EdiyaBarista : Barista { override fun makeCoffee() { println(\"Make Ediya-style coffee\") }}// Delegator: Cafe, Delegate: changable in runtimeclass Cafe(b: Barista): Barista by b { private var barista: Barista = b override fun makeCoffee() { barista.makeCoffee() } fun changeBarista(newBarista: Barista) { this.barista = newBarista }}// Usage of Cafefun main { val cafe = Cafe(StarbucksBarista()) cafe.makeCoffee() cafe.changeBarista(EdiyaBarista()) cafe.makeCoffee()} 기본 사용법 - 2. 프로퍼티 위임 말 그대로 속성의 접근을 다른 객체에 위임하는 방법입니다. 즉 속성의 값을 읽거나 쓰는 두 가지 동작을 다른 객체에 위임 할 수 있다는 말이 됩니다. 코틀린에서는 몇 가지 프로퍼티 위임을 처리하는 델리게이트를 제공합니다. 코틀린에서 제공하는 내장 Delegate의 종류 Lazy Properties 속성의 지연 초기화를 지원합니다. 아래의 예에서 lazyValue는 최초 접근 시 lazy 함수에 전달되는 객체의 초기화 로직을 수행하는 람다 함수를 호출함으로써 객체를 초기화 합니다. 이 로직은 최초 접근 시 한번만 호출되며 이후에는 초기화 된 값으로 데이터 읽기가 수행됩니다. 1234val lazyValue: String by lazy { println(\"Computed!\") \"Hello\"} Observable Delegates.observable는 첫번째 파라미터로 초기값을, 두번째 파라미터로는 람다 함수를 인자로 받습니다. 람다 함수는 old, new로 이전 값과, 새로 바뀐 값을 전달해줍니다. 12345678910var name: String by Delegates.observable(\"&lt;no name&gt;\") { prop, old, new -&gt; println(\"$old -&gt; $new\")}name = \"first\"name = \"second\"// result// &lt;no name&gt; -&gt; first// first -&gt; second Vetoable Delegates.vetoable은 Delegates.observable과 다르게 값이 변경되기 전에 콜백이 호출됩니다. 두번째 파라미터에서 Delegates.observable과 다른 점은 Boolean을 반환하는 람다를 파라미터로 받는 다는 점인데 이 값이 true인 경우에만 값이 변경됩니다. 아래의 예제에서는 새 값이 기존 값보다 클때만 max의 값이 변경됩니다. 1234567891011var max: Int by Delegates.vetoable(0) { prop, old, new -&gt; new &gt; old}println(max) // 0max = 10println(max) // 10max = 5println(max) // 10 아래와 같이 사용하면 아예 예외를 던지도록 하는 것도 가능합니다. 12345678910var max: Int by Delegates.vetoable(0) { property, oldValue, newValue -&gt; if (newValue &gt; oldValue) true else throw IllegalArgumentException(\"New value must be larger than old value.\")}println(max) // 0max = 10println(max) // 10// max = 5 // will fail with IllegalArgumentException Map Delegation 위임을 이용하면 map에 있는 값을 속성으로 사용할 수 있습니다. 1234567891011121314val properties = mapOf( \"name\" to \"jude\", \"age\" to 10)data class User(val map: Map&lt;String, Any?&gt;) { val name: String by map val age: Int by map}val user = User(properties)println(user) // User(map={name=jude, age=10})println(user.name) // judeprintln(user.age) // 10 아래와 같이 mutableMap을 이용하면 속성의 값을 수정 가능하도록 만들 수도 있습니다. 이를 이용하면 JSON을 파싱하는 작업을 아주 편하게 할 수 있습니다. 1234class MutableUser(val map: MutableMap&lt;String, Any?&gt;) { var name: String by map var age: Int by map} NotNull var로 선언된 속성에 값이 설정되기 전에 접근하면 IllegalStateException을 발생 시킵니다. 이를 이용하면 런타임에 예외를 적절히 다뤄줘야하긴 하지만 선언과 값의 설정을 분리 할 수 있습니다. 참고로 코틀린에서는 notNull을 쓰지 않고 var로 변수를 선언하면서 값을 초기화 해주지 않으면 컴파일이 되지 않습니다. 1var notNullVar: String by Delegates.notNull() 프로퍼티 위임의 커스텀 코틀린에서는 속성에 대한 위임을 지원합니다. 즉 클래스, 함수, 코드 블럭 안에서 사용하는 변수에 대한 접근을 델리게이트에 위임할 수 있습니다. 속성에 대한 접근이라고 하면 데이터를 가져오는 동작과, 데이터를 쓰는 동작이 있습니다. 따라서 속성에 대한 델리게이트는 결국 이 두 가지 동작을 커스텀 델리게이트에 구현하는 것 입니다. 먼저 사용법을 바로 보도록 하겠습니다. 123class Example { var p: String by Delegate()} 위의 샘플 코드는 아래와 같이 문법적으로 나눠서 볼 수 있습니다. 일반적인 변수 선언 방법에서 뒤에 by &lt;expression&gt; 이 추가된 형태로, by 뒤에 있는 델리게이트에 속성에 대한 읽기, 쓰기를 위임한다는 의미입니다. val/var &lt;property name&gt;: &lt;Type&gt; by &lt;expression&gt; 코틀린에서의 속성에 대한 델리게이트는 아래와 같은 형태로 구현할 수 있습니다. 아까 언급한 것처럼 읽기와 쓰기를 대신 처리해주기 위해 getValue와 setValue를 구현하고 있는걸 볼 수 있습니다. 1234567891011import kotlin.reflect.KPropertyclass Delegate { operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String { return \"$thisRef, thank you for delegating '${property.name}' to me!\" } operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) { println(\"$value has been assigned to '${property.name}' in $thisRef.\") }} 만약 델리게이트가 읽기 전용으로 val로만 쓰인다면 getValue만 추가하면 됩니다. 수정이 가능한 var로 사용하신다면 델리게이트에 setValue도 추가로 구현이 필요합니다. ReadOnlyProperty와 ReadWriteProperty 인터페이스 코틀린 표준 라이브러리에서는 델리게이트를 만들기 위해 구현해야하는 getValue와 setValue를 정의하는 인터페이스를 제공합니다. 이름을 보면 알 수 있듯이 ReadOnlyProperty에서는 getValue만을 정의하고, ReadWriteProperty에서는 getValue와 setValue 둘 다 정의하고 있습니다. 이를 구현하지 않아도 앞서 설명한 getValue와 setValue를 구현해주면 델리게이트로 동작하지만 ReadOnlyProperty나 ReadWriteProperty를 이용하면 클래스 선언 없이 익명 클래스로 바로 델리게이트를 만들 수도 있습니다. 또한 구현하고 있는 인터페이스를 보면 바로 델리게이트로서 동작이 가능하다는 것을 알 수 있기 때문에 가독성도 올라갑니다. 복잡한 getValue와 setValue의 시그니처를 외울 필요없이 IDE의 도움을 받아 편하게 정의 할 수 있는 점도 장점이겠죠? 1234567891011fun resourceDelegate(resource: Resource = Resource()): ReadWriteProperty&lt;Any?, Resource&gt; = object : ReadWriteProperty&lt;Any?, Resource&gt; { var curValue = resource override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): Resource = curValue override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: Resource) { curValue = value } }val readOnlyResource: Resource by resourceDelegate() // ReadWriteProperty as valvar readWriteResource: Resource by resourceDelegate() 실제 코드로 보는 위임의 사용 예(mutableStateOf) 안드로이드에서 Jetpack Compose로 UI를 개발하고 있다면 State의 개념은 아주 친숙할 것입니다. Compose는 데이터를 UI로 그대로 노출하는 선언형 UI 프레임워크 입니다. Compose에서는 UI에 노출할 데이터를 관리하는 특별한 인터페이스를 하나 제공하는데요. 바로 State라는 인터페이스입니다. 1234@Stableinterface State&lt;out T&gt; { val value: T} State안에는 val value: T 형태로 value 속성을 가지고 있습니다. State의 특별함은 Composable function에서 State의 상태 변화를 구독해서 State가 변경되면 자동으로 재구성(Recomposition) 트리거 된다는 점입니다. 이런 State는 어떤 식으로 사용될까요? 아래는 안드로이드에서 컴포즈로 UI를 개발하고 있다면 아주 친숙한 코드일거라 생각합니다. (Composable 함수가 아닌 ViewModel에서는 mutableStateOf가 아닌 mutableStateFlow의 사용이 권장 되지만 이해를 돕기위한 예제로 이렇게 구성했으니 참고해주세요) 12345678910111213141516class MyViewModel: ViewModel() { ... var showDialog: MutableState&lt;Boolean&gt; = mutableStateOf(false) ...}@Composablefun MyScreen(viewModel: MyViewModel) { ... if (viewModel.showDialog.value) { MyDialog(onDismissRequest = { viewModel.showDialog.value = false }) } ...} showDialog의 value에 따라 MyDialog()를 UI에 노출 합니다. showDialog의 값은 MutableState기 때문에 변경이 가능하구요. 하지만 위의 예를 보고 뭔가 이상함을 느끼신 분들도 계실거 같습니다. 사실 우리가 실제로 MutableState를 쓰는 방식은 대부분 아래와 같습니다. 1234567891011121314class MyViewModel: ViewModel() { ... var showDialog: MutableState&lt;Boolean&gt; by mutableStateOf(false) ...}@Composablefun MyScreen(viewModel: MyViewModel) { if (viewModel.showDialog) { MyDialog(onDismissRequest = { viewModel.showDialog = false }) }} 귀찮거나, 지저분한 코드를 병적으로 싫어하는 개발자 답게 코틀린의 위임을 이용해서 조건문에서 showDialog.value로 State에 접근하던걸 showDialog로 단순화 했네요. 위임을 사용했기 때문에 showDialog를 선언할 때 =가 by로 바뀐 것을 볼 수 있습니다. 그럼 MutableState 부터 차근차근 코드를 따라가 보도록 하겠습니다. 당연히 MutableState 역시 State를 구현하고 있는걸 볼 수 있습니다. 한 가지 눈에 띄는 부분은 State의 value를 오버라이드 하면서 val 키워드로 선언되었던 value가 변경 가능한 변수임을 나타내는 var로 바뀐 점입니다. MutableState라는 이름에서 보이듯이 MutableState는 가지고 있는 value가 변경 가능해야하기 때문입니다. 123456@Stableinterface MutableState&lt;T&gt; : State&lt;T&gt; { override var value: T operator fun component1(): T operator fun component2(): (T) -&gt; Unit} MutableState의 델리게이트 구현 MutableState와 State가 어떻게 생겼는지 보았는데 이것들이 델리게이트로는 어떻게 구현이 되어있는지를 살펴보도록 하겠습니다. 먼저 MutableState는 값의 변경이 가능해야합니다. 즉 쓰기 가능해야합니다. 따라서 setValue를 구현해주어야겠죠? 코드를 보면 바로 해당 함수를 찾을 수 있습니다. 아주 심플하게 this.value = value 이렇게 구현이 되어있네요. 123inline operator fun &lt;T&gt; MutableState&lt;T&gt;.setValue(thisObj: Any?, property: KProperty&lt;*&gt;, value: T) { this.value = value} 그럼 getValue 는 어떻게 구현되어 있을까요? 역시나 간단히 State 인터페이스의 value를 반환하는 단순한 코드로 구현이 되어있습니다. 1inline operator fun &lt;T&gt; State&lt;T&gt;.getValue(thisObj: Any?, property: KProperty&lt;*&gt;): T = value 위임의 본질 상속 vs 구성(위임) 앞에 설명드린 많은 예제들을 보면 사실 위임이 아닌 다양한 방식으로 구현이 가능합니다. 전 프로그래밍이 결국 글쓰기와 동일하다고 생각합니다. 글쓰기에서는 전하는 핵심 메세지가 동일하더라도 이를 표현하는 문장은 수없이 다양할 수 있습니다. 다만 제목에 적은 세 가지의 개념을 간단히 한번 짚고 넘어간다면 도움이 될거 같습니다. 위의 세 가지 개념은 객체지향 프로그래밍의 토대가 되는 개념 들이며 대다수의 객체지향 프로그래밍 언어에서 이를 이용하여 코드를 작성할 수 있도록 지원합니다. 상속 먼저 상속은 객체의 관계를 부모-자식 관계로, 또는 is - a 관계로 많이 표현합니다. 당연히 구현하려고 하는 객체 사이의 관계를 이렇게 표현하는게 직관적이라면 상속을 사용할 수 있습니다. 상속을 사용하면 객체간의 관계를 수직적으로 표현하여 사람이 직관적으로 이해하기 좋고 부모의 속성과 기능이 자식에게 모두 전해지기 때문에 잘 모델링 하면 공유되는 기능과 속성을 부모에 두고 코드를 재활용 할 수 있는 장점이 있습니다. 상속보단 구성(Composition over Inheritance) 객체 지향 디자인 원칙에서 자주 언급되는 개념입니다. 앞서 상속의 장점들을 이야기 했지만 상속의 장점은 곧 단점이 되기도 합니다. 부모의 속성과 기능이 자식에게 전해지는 것은 얼핏 보면 코드의 재사용성을 높여주기도 하지만 크게 보면 캡슐화가 약해지는 단점과, 부모의 변경에 따라 자식이 영향을 받게 되는 강한 결합이 발생하며, 상속 관계가 깊어지면 자식 객체는 지나치게 비대해 져서 필요없는 기능이나 속성이 늘어나고, 어떤 기능과 속성이 있는지를 파악하는 것도 매우 힘들어집니다. 구성 이에 따라 최근에는 상속 보단 구성을 이용해서 코드를 작성하는걸 권장하고 있습니다. 구성은 has-a 관계로 많이 표현하며 해야하는 작업을 여러 객체로 나누고 합쳐서 원하는 기능을 구현하는 방식입니다. 각각의 객체가 할 일을 나눠서 가지고 있기 때문에 캡슐화가 잘 지켜지며 상속과 같은 복잡한 수직 구조를 갖지 않습니다. 물론 이에 따라 훨씬 더 많은 객체가 생겨나고 이들의 관계가 복잡해 지는 부분은 단점이 될 수도 있습니다. 위임 위임은 객체가 필요한 기능을 다른 객체로 전달하는 방식입니다. 결국 위임은 구성의 한 방법입니다. 구성이 좀 더 강력하고 편리하게 쓰일 수 있도록 도와주는 문법적인 장치라고도 볼 수 있습니다. 실제로 코틀린에서 by 키워드를 통해 위임을 사용하면 코틀린 컴파일러는 by가 지정하는 객체를 직접 생성해서 해당 객체의 레퍼런스를 갖고 이를 호출 하는 방식으로 위임을 처리합니다. 즉 다른 객체를 생성하고 이를 이용해서 특정 기능을 수행하는 구성과 완전 동일합니다. 다만 코틀린에서 문법적으로 매번 해당 객체의 레퍼런스를 호출하는걸 줄여주는 것일 뿐이죠. 아래 코드는 코틀린 공식 페이지에 있는 설명으로, 위임이 실제 어떤 식으로 구현이 되는지를 보여줍니다. 1234567891011class C { var prop: Type by MyDelegate()}// this code is generated by the compiler instead:class C { private val prop$delegate = MyDelegate() var prop: Type get() = prop$delegate.getValue(this, this::prop) set(value: Type) = prop$delegate.setValue(this, this::prop, value)} 위임의 대표적인 사용 예 위임이 구성의 한 방법이라고 보면 아래의 일들은 당연히 위임으로 처리하기 아주 좋은 사례라고 할 수 있습니다. 위임을 하면 특정 인터페이스나, 속성의 접근을 내가 통제할 수 있습니다. 즉 프록시나, 훅과 같은 역할을 델리게이트에 구현할 수 있는 것이죠. 결국 아래의 사용 사례들은 프록시나 훅으로 처리하기 좋은 것들이기도 합니다. 로직의 재사용 데이터 유효성 검사 의존성 주입 동적 행위 변경 자원 관리 모니터링 &amp; 로깅 원래의 기능에 새로운 기능 추가 이번 포스트에서는 위임에 대해 알아보았습니다. 내용이 좀 많긴 하지만 위임을 활용했을 때 가질 수 있는 많은 장점을 생각하면 여기서 다룬 내용들이 독자에게 많은 도움이 될거라 생각합니다. 또한 위임을 통해 구현된 코틀린, 안드로이드의 많은 기능들을 직접 코드를 따라가면서 분석해본다면 코드를 이해하는데에도 많은 도움이 될 것입니다.","link":"/2023/11/09/kotlin/delegation%20in%20kotlin/"},{"title":"테마(Theme)를 이용해서 다양한 모습의 안드로이드 앱 만들기","text":"멋쟁이들은 계절이나 분위기에 따라 다양한 색의 옷으로 스스로를 표현합니다. 아름다운 자연도 계절에 따라 완전 다른 모습으로 우리의 눈을 사로잡습니다. 최근 Android, iOS에 많은 화제가 되고 있는 다크 모드(Dark Mode)도 비슷합니다. 모드에 따라 하나의 앱이 밝고, 어두운 두 가지 모습을 자유자재로 오갑니다. 안드로이드에서는 테마(Theme)를 이용해서 이를 구현할 수 있습니다. 계절에 따라 모습이 바뀌는 자연을 생각하면 테마는 계절이라고 생각할 수도 있고, 기분에 따라 옷의 컬러를 선택하는 사람에겐 기분이 테마가 될 수 있습니다. 안드로이드의 다크 모드라는 것도 결국은 시스템이 '다크 모드(Dark mode)'일 때 이에 맞는 미리 만들어둔 테마를 적용시켜주는 것에 불과합니다. 아래 이미지는 안드로이드 공식 페이지에서 테마에 대해 설명하는 이미지입니다. 동일한 액티비티에 서로 다른 테마를 적용한 모습으로, 테마에 따라 액티비티가 완전히 다른 느낌으로 변하는 모습을 볼 수 있죠. 그럼 이번 포스팅에서는 테마에 따라 다양한 모습으로 변신하는 앱을 어떻게 만들 수 있는지에 대해 이야기하도록 하겠습니다. 테마의 선언과 구성 앞에서 테마에 대해 개념적으로 설명을 드렸지만 우리는 개발자이니 좀 개발자의 관점에서 테마를 살펴보도록 하겠습니다. 테마는 아래와 같이 res/values/style.xml에 선언합니다. 여기서 파일 명은 원하는 대로 작성하셔도 됩니다. 12345678&lt;resources&gt; &lt;style name=\"AppTheme\" parent=\"Theme.MaterialComponents.DayNight.NoActionBar\"&gt; &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt; &lt;item name=\"colorImagePlaceHolder\"&gt;@color/GR80&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 일단 기본적으로 테마는 키, 값의 쌍으로 이루어진 맵과 같이 생각할 수 있습니다. 더 위에 style 태그를 보면 마치 클래스 처럼 parent를 통해 다른 테마를 상속 받을 수도 있습니다. 위의 예에서는 AppTheme이라는 테마가 Theme.MaterialComponents.DayNight.NoActionBar라는 테마를 상속받아 선언되고 있습니다. 다른 테마를 상속 받으면 새로 정의한 테마는 parent 테마의 모든 속성을 동일하게 갖게되고 기존의 속성을 오버라이드할 수 있습니다. &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.MaterialComponents.DayNight.NoActionBar&quot;&gt; 이제 가장 중요한 내용입니다. 테마에 있는 속성들은 컬러와 같은 디자인 리소스에 의미있는 이름을 붙인 것 입니다. 예를 들어 위에 colorAccent은 안드로이드의 뷰가 가진 속성이 아닙니다. 그리고 colorAccent는 이름에서 보이듯이 이름에서 어떤 특정 색을 표현하지 않고 '강조를 나타내는 색’이라는 의미를 더 강조하고 있습니다. 즉 테마에 따라 colorAccent를 다르게 적용할 수 있음을 표현하는 것입니다. 꼭 인터페이스와 구현체의 관계와 비슷합니다. colorAccent라는 속성(인터페이스)은 서로 다른 테마(구현체)에서 다른 컬러로 표현될 수 있는 것입니다. 머티리얼 디자인에 포함된 주요 테마 속성 테마는 내가 직접 정의해서 사용할 수도 있고 안드로이드 플랫폼에 정의되어 바로 사용할 수 있는 것들도 있습니다. 아래 이미지는 롤리팝과 함께 머티리얼 디자인이 소개되면서 많이 쓰인 이미지입니다. 위에 보이는 colorPrimary, textColorPrimary, colorPrimaryDark, windowBackground, navigationBarColor와 같은 속성들은 머티리얼 테마(Material Theme)에 미리 정의된 것으로 보시는 것처럼 시스템 UI에 미리 사용되고 있고 앱에서 얼마든지 이를 재정의(Override)해서 사용이 가능합니다. 즉 앱에서 사용하는 테마에서 colorPrimaryDark를 노란색으로 적용하면 위에 위에 그림에 있는 상태바(Status bar)의 색은 노란색으로 변경될 것입니다. 그렇다면 이게 어떻게 가능할까요? 바로 안드로이드도 플랫폼에서 상태바의 색상에 특정 컬러를 하드코딩 한게 아니라 colorPrimaryDark라는 테마의 속성을 참조하도록 해두었기 때문입니다. 아래는 머티리얼 테마를 상속받아서 앱에서 직접 사용할 테마를 AppTheme라는 이름으로 선언해서 사용하는 예입니다. 아래 예에서 android:windowBackground나 android:windowActivityTransitions와 같은 속성은 안드로이드 프레임워크에 있는 테마이고, colorPrimary, colorPrimaryDark, colorAccent는 머티리얼 테마에 선언된 속성입니다. 그리고 마지막에 있는 colorImagePlaceHolder는 제가 직접 만든 속성입니다. 123456789101112131415&lt;resources&gt; &lt;style name=\"AppTheme\" parent=\"Theme.MaterialComponents.DayNight.NoActionBar\"&gt; // Attributes from material theme &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt; // Attributes from android framework &lt;item name=\"android:windowBackground\"&gt;#ffffff&lt;/item&gt; &lt;item name=\"android:windowActivityTransitions\"&gt;true&lt;/item&gt; // Attributes that I've defined &lt;item name=\"colorImagePlaceHolder\"&gt;@color/GR80&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; colorImagePlaceHolder와 같이 기존에 없는 속성을 선언하고 싶으면 res/values/values.xml 파일에 아래와 같은 방식으로 선언하면됩니다. 보시면 좌측에 속성이 가질 리소스 포맷을 적고 name에 사용할 속성 명을 적어주면 됩니다. 123456&lt;resources&gt; &lt;attr format=\"color\" name=\"colorImagePlaceHolder\"/&gt; &lt;attr format=\"color\" name=\"colorDivider\"/&gt; &lt;attr format=\"color\" name=\"mildBackgroundColor\"/&gt; ...&lt;/resources&gt; 테마에 적용된 값을 사용하기 자 이제 테마의 개념부터, 종류, 선언하는 방법까지 알아봤으니 어떻게 사용하는지를 알아봅시다. 테마를 사용하는 가장 기본적인 방법은 ?attr/[attributeName] 을 사용하는겁니다. 구체적으로 아래와 같이 사용할 수 있습니다. 123456&lt;androidx.appcompat.widget.Toolbar android:id=\"@+id/toolbar\" style=\"@style/Toolbar\" app:titleTextColor=\"?attr/titleTextColor\" app:titleTextAppearance=\"@style/ToolbarTitle\" tools:title=\"Toolbar\" /&gt; 툴바의 텍스트 컬러를 지정하는 부분을 보시면 아래처럼 ?attr을 사용하고 있죠. ?attr/titleTextColor ?attr은 테마에서 attr 뒤에 있는 속성 이름으로 값을 찾아오라는 의미입니다. 예를 들어 위의 예에서는 현재 나에게 적용된 테마에서 titleTextColor라는 이름으로 정되된 컬러값을 가져오라는 뜻입니다. 앱에 현재 LightTheme과 DarkTheme가 있다고 합시다. 현재 이 툴바가 LightTheme를 적용받고 있고 LightTheme에 titleTextColor가 흰색이라면 툴바의 텍스트는 흰색이 될 것이고, DarkTheme를 적용받고 있고 여기에 titleTextColor가 검정이라면 툴바의 텍스트는 검정이 됩니다. 결국 테마를 통해 화면의 모습을 다이나믹하게 변경하는 것은 내가 변경하고자 하는 UI 요소의 컬러를 최대한 ?attr을 이용해서 테마의 속성을 간접 참조(indirect reference)로 설정하고, 사용자의 선택이나, 환경에 따라 테마를 변경하는 것입니다. (이 포스팅 전체에서 가장 중요한 내용인거 같네요.) 테마의 적용 그렇다면 위의 예에서 저 툴바에 적용되는 테마는 어떻게 결정 될까요? 테마는 컨텍스트에 적용이 됩니다. 자 그럼 안드로이드 플랫폼에서 컨텍스트를 갖는게 어떤게 있을까요? View, ViewGroup, Activity, Application 등이 있겠죠. 테마는 컨텍스트에 적용이 되기 때문에 여기에 모두 적용이 됩니다. 또한 테마는 범위를 갖는데 상위레벨에 적용한 테마는 하위 레벨까지 모두 적용이 되고 하위레벨에 적용된 테마가 상위레벨에 적용된 테마에 우선해서 적용됩니다. 어플리케이션 레벨로 적용하기 androidManifest.xml 12345678&lt;manifest ...&gt; &lt;application ... android:theme=\"@style/AppTheme\"&gt; ... &lt;/application&gt;&lt;/manifest&gt; 액티비티에 적용하기 androidManifest.xml 1234567891011&lt;manifest ...&gt; &lt;application ...&gt; &lt;activity ... android:theme=\"@style/SplashTheme\"&gt; &lt;/activity&gt; ... &lt;/application&gt;&lt;/manifest&gt; 뷰그룹 및 뷰에 적용하기 1234567891011&lt;LinearLayout ... android:theme=\"@style/Theme.MaterialComponents.Light\"&gt; &lt;TextView ... /&gt; &lt;TextView ... android:theme=\"@style/ThemeOverlay.MaterialComponents.Dark\" /&gt; &lt;/LinearLayout&gt; xml에서 각 테마는 android:theme를 통해 적용이 가능하고 적용하고자 하는 범위에 따라 androidManifest.xml의 application 태그나, activity 태그 또는 레이아웃 파일에서 각 뷰그룹 또는 뷰에 적용이 가능합니다. 코드에서 테마에 정의된 속성 값 읽어오기 앞서 테마는 컨테스트에 적용이 된다고 이야기했습니다. 그럼 테마에 엮여있는 특정 속성의 값을 코드에서 가져오려면 어떻게 할까요? (xml이였다면 ?attr/[attributeName]을 썼겠죠) 아래는 컨텍스트에 엮여있는 컬러값을 가져오는 예제입니다. 12345678@ColorIntfun Context.getThemeColor(@AttrRes themeAttrId: Int): Int { return obtainStyledAttributes( intArrayOf(themeAttrId) ).use { it.getColor(0, Color.TRANSPARENT) }} 현재 액티비티의 테마에 있는 colorPrimary를 가져오려면 액티비티 내에서 getThemeColor(R.attr.colorPrimary)와 같이 할 수 있을 것이고 특정 뷰그룹에 적용된 테마에 대한 컬러를 가져오려면 targetViewGroup.getContext().getThemeColor(R.attr.colorPrimary)와 같이 사용할 수 있겠죠. 테마의 사용 자 그럼 위에서 알아본 테마의 개념이 어떤식으로 사용될 수 있을까요? 아래의 UI를 예로 들어 봅시다. 이 앱의 처음 디자인은 좌측의 밝은 색 위주의 디자인이였는데 어떤 과정을 거쳐서 우측과 같이 어두운 테마를 적용할 수 있었을까요? 이를 위해서는 아래와 같은 단계를 밟아가면 됩니다. 테마에 따라 색상이 변하는 부분과 변치 않을 부분을 나눠봅니다. UI에서 컬러가 하드코딩 되어있는 부분을 찾고 테마의 어떤 속성을 사용할지 결정합니다. 이때는 이미 시스템에 정의된 테마의 속성을 사용할지, 새로운 속성을 만들지 결정합니다. 새로운 테마를 만들고 이 테마에서 변화를 줄 속성을 오버라이드합니다. UI에서 변경이 필요한 부분의 컬러를 테마의 속성을 참조하도록 ?attr/을 이용하여 변경합니다. 테마에 따라 색상이 변하는 부분과 변치 않을 부분을 나눠보기 위의 예제에서 변하는 부분과 변치 않는 부분을 나눠봤습니다. 변하는 것 화면의 배경 툴바의 배경 쿨바의 텍스트 리스트 내의 카드 배경 리스트 내의 카드 텍스트 바텀네비게이션 배경 바컴네비게이션 아이콘 탭레이아웃 배경 변하지 않는 것 탭레이아웃 인디케이터 및 선택된 탭의 텍스트 리스트 내 카드의 재생시간 뱃지 변하는 부분과 변치 않는 부분을 나눴으면 각각에 어떤 테마의 속성을 사용할 수 있을까요? 모두 새로 선언해도 되지만 이미 선언돼있는 다양한 속성들이 있으니 이것들을 먼저 확인해봅니다. 아래 링크에는 머티리얼 디자인 시스템에 이미 선언돼있는 다양한 속성들에 대한 설명이 있습니다. Android Styling: Common Theme Attributes 이 글에서는 컬러에 대한 내용을 주로 다루고 있으니 몇 가지 컬러 관련 속성을 보겠습니다. ?attr/colorPrimary : 앱의 메인 브랜딩 컬러 ?attr/colorSecondary : 앱의 세컨 브랜딩 컬러로 주로 메인 브랜딩 컬러를 보완하는 좀 더 밝은 색상으로 사용 ?attr/colorOn[Primary, Secondary, Surface etc] : 각 컬러에 대한 대비를 이루는 색입니다. 예를 들어 배경에 ?attr/colorPrimary를 쓰고, 여기위에 다른 UI 컴포넌트를 올릴 때 colorOnPrimary를 사용하면 이 컴포넌트를 좀 더 눈에 띄게 강조 할 수 있겠죠. ?attr/colorSurface : 카드(cards), 시트(sheets), 메뉴(menues)와 같은 컴포넌트의 표면 색을 나타냅니다. ?attr/colorBackground : 스크린의 백그라운드 색 ?attr/colorError : 에러를 표시할 때 사용할 색 아래 이미지는 material.io 페이지에 있는 The baseline Material color theme로, 위의 컬러를 보통 어떤식으로 선택하는지에 대한 예시를 보여주고 있습니다. 참고로 material.io 페이지에 가면 대비가 되는 색을 선택하거나, 위에 있는 머티리얼 테마에 사용되는 속성값들을 어떤 식으로 결정하면 좋을지에 대한 가이드와 툴이 잘 나와있습니다. 다시 아래 목록으로 돌아와서 위에 있는 속성들을 참고하면 저는 아래와 같이 테마의 속성을 정의할 수 있을거 같습니다. 이걸 바탕으로 각 UI 컴포넌트에 하드코딩 되어있던 컬러를 ?attr를 이용해서 바꿔줍니다. 이제 위의 속성들을 각 테마에 따라 정의합니다. 밝은 테마 1234567&lt;style name=\"LightTheme\" parent=\"Theme.MaterialComponents.DayNight.NoActionBar\"&gt; &lt;item name=\"colorSurface\"&gt;@android:color/white&lt;/item&gt; &lt;item name=\"backgroundColor\"&gt;@android:color/white&lt;/item&gt; &lt;item name=\"android:windowBackground\"&gt;@color/gray_bg&lt;/item&gt; &lt;item name=\"titleTextColor\"&gt;@android:color/black&lt;/item&gt; ...&lt;/style&gt; 어두운 테마 1234567&lt;style name=\"DarkTheme\" parent=\"Theme.MaterialComponents.DayNight.NoActionBar\"&gt; &lt;item name=\"colorSurface\"&gt;@color/gray_900&lt;/item&gt; &lt;item name=\"backgroundColor\"&gt;@android:color/black&lt;/item&gt; &lt;item name=\"android:windowBackground\"&gt;@android:color/black&lt;/item&gt; &lt;item name=\"titleTextColor\"&gt;@android:color/white&lt;/item&gt; ...&lt;/style&gt; 이제 감이 오시나요? 위의 속성들을 재정의 하는 테마를 추가하기만 하면 이제 얼마든지 분위기가 확 다른 앱을 만들 준비가 된 것이죠. 그럼 이제 이런 테마를 어떻게 적용하면 될까요? 아까 위에 기술 했던대로 activity 또는 application 단위로 androidManifest의 android:theme 태그를 이용해 정의하면 됩니다. 이걸 동적으로 하고 싶다구요? 그럼 간단히 테마를 선택할 수 있는 다이얼로그를 하나 만들고 테마를 선택하면 이걸 Preference 같은 곳에 저장하고, 액티비티가 시작 시 setContentView 이전에 테마를 설정해주면 됩니다. 123456789101112override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val userSelectedPref = getThemeFromPref() when(userSelectedPref) { \"light\" -&gt; setTheme(R.style.LightTheme) \"pink\" -&gt; setTheme(R.style.PinkTheme) \"dark\" -&gt; setTheme(R.style.DarkTheme) else -&gt; setTheme(R.style.LightTheme) } setContentView(R.layout.activity_main) ...} 테마는 뷰가 인플레이트 되기 전에 설정이 되고 인플레이트 후에는 변경해도 UI에 업데이트가 반영이 되지 않기때문에 setOntentView 이전에 해주어야합니다. 다크 모드 그럼 다크모드는 뭘까요? 다크모드는 안드로이드 9에서부터 지원되는 시스템 설정입니다. 즉 앱이 아니라 안드로이드 시스템에서 설정 가능한 모드입니다. 앱에서 다크모드를 지한한다는 것은, 사용자가 시스템의 다크모드를 적용하면 이에 따른 어두운 테마를 만들어 두었다가 이게 적용되도록 해주면 됩니다. 간단하죠? 이 부분은 이 글의 내용을 이해했다면 간단히 적용이 가능하지만 이 글에서 다루면 너무 길어질 것 같아서 다음 포스팅에서 따로 다루도록 하겠습니다. 마무리 저는 디자인과는 좀 거리가 있어보이는 개발자입니다. 노트북이 들어간 백팩과 체크무늬 셔츠가 가장 편안합니다. 하지만 그럼에도 제가 만든 앱은 어디서나 돋보였으면 좋겠고 보기에 좋았으면 좋겠습니다. 또한 저는 잘 다듬어진 디자인은 그 자체로 유저에게 큰 가치를 준다고 생각합니다. 이 글을 보신 분들도 테마를 이용해서 보다 다양한 느낌의 앱을 앱을 만드는데 도움이 되셨으면 합니다. 참고 테마에 관련된 글들은 주로 안드로이드 엔지니어인 Nick Butcher의 유튜브 영상과 미디엄 글을 많이 참고했습니다. 또한 material.io에 있는 페이지들도 개발자에게 디자인과 관련된 컴포넌트나 개념을 잡는데 도움이 많이 되었습니다. 마지막으로 안드로이드의 테마를 이야기하면 항상 스타일(Style)에 대한 이야기를 보통 함께 합니다. 이 둘은 상당히 비슷하면서 다른데 개인적으로는 두개를 같이 다루면 오히려 개념을 잡는데 헷갈리기 때문에 스타일에 대한 이야기는 최대한 배제하였습니다. 하지만 테마를 이해했다면 스타일에 대한 부분도 꼭 짚고 넘어가면 좋을 것 같습니다. Dark theme Styles and Themes Material io Android Styling: Themes vs Styles Android Styling: Common Theme Attributes Android Styling: Prefer Theme Attribute Android Styling: Themes Overlay","link":"/2020/03/08/android/styling/android-theming/"},{"title":"안드로이드(Android) 뷰모델(ViewModel)","text":"들어가며 뷰모델은 안드로이드 AAC(Android Architecture Components)중 하나로 라이브 모델과 함께 굉장히 중요한 역할을 차지합니다. AAC는 구글에서 안드로이드 앱을 좀 더 쉽고 견고하게 개발할 수 있도록 개발자 커뮤니티의 피드백을 받아 만들어지고 있는 라이브러리입니다. 소프트웨어는 마치 사람처럼 성장합니다. 안드로이드가 1.0이 2008년에 발표되었으니 벌써 12년이 되었습니다. 당연히 안드로이드 API도 초기 설계는 부족한 부분이 많이 있었습니다. 이에 따라 어떤 부분은 개발하기도 어렵고 버그가 발생하기 쉬운 구조적인 문제도 아주 많았죠. 하지만 구글이 대단하고 잘하고 있는건 이런 부족한 부분을 끊임없이 발견하고 피드백을 받아 개선시켜주고 있다는 점입니다. AAC가 등장한 배경도, 그 AAC의 하나인 뷰모델이 등장하게 된 배경도 결국은 이런 맥락입니다. 자, 그럼 뷰모델이 해결하고자 하는 문제는 무엇이고, 뷰모델은 이 문제를 어떻게 해결해주고 있을까요? 이번 글에서는 이 두 가지 질문에 대해 알아보도록 하겠습니다. (결론을 먼저 말하자면 뷰모델은 액티비티의 재생성 시 UI와 관련된 데이터를 유지하기 위해 사용합니다.) 뷰모델이 해결하고 싶은 문제 안드로이드 앱 개발을 한다고 하면, 가장 많이 부딪히는 개념중에 하나가 액티비티의 생명주기입니다. 안드로이드 앱의 거의 모든 UI 요소들은 액티비티에 속하게됩니다. 그리고 이 액티비티는 생명주기를 가집니다. 여기서 생명주기라 함은 크게 액티비티의 생성(onCreate)부터 소멸(onDestroy)까지를 말하고 좀 더 디테일하게 보면 유저에게 최초로 보여지는 시점(onStart - onStop), 포커스를 갖게되는 시점(onResume - onPause) 등을 포함합니다. 문제. 액티비티는 시스템에 의해 재생성(re-created)될 수 있습니다. 이런 상황은 단말의 몇몇 설정 변경 시 발생합니다. 가장 흔한 예는 단말의 방향 전환(가로모드, 세로모드), 언어 설정 변경을 생각해 볼 수 있습니다. 이런 시스템 설정 변경은 앱 밖에서 발생하기 때문에 이로 인한 발생되는 액티비티의 재생성은 우리가 제어할 수 없습니다. 그리고 이렇게 액티비티가 재생성이 되면 액티비티가 가지고 있던 데이터는 사라집니다. 위와 같은 이유로 액티비티가 재생성 되었을 때, 좋은 유저 경험을 주기 위해서는 마치 아무일도 없었던 것 처럼 UI와 관련된 데이터를 어딘가에 저장해 두었다가 이를 이용해서 다시 화면을 그려줘야합니다. 기존의 해결책. onSaveInstanceState()와 onRestoreInstanceState() 액티비티의 onSaveInstanceState() 콜백을 이용하면 이런 예외적인 상황에서 저장해두고 싶은 데이터를 번들(Bundle)에 저장할 수 있습니다. 그리고 이렇게 저장해둔 데이터는 액티비티가 재생성될 때 onCreate(savedInstanceState: Bundle?)나 onRestoreInstanceState() 콜백을 통해 다시 전달받을 수 있습니다. 하지만 이 방법은 번들을 사용하기 때문에 저장하고자 하는 데이터의 형태도 제한이 되고, 많은 양의 데이터를 저장하기에는 제한이 있습니다. 번들의 사용에 대해 가이드 하고 있는 공식 문서에서는 50Kb 미만으로 유지하기를 가이드 하고 있습니다. 또한 이 방법에서 onSaveInstanceState()는 메인 쓰레드에서 동작해야하기 때문에 여기서 데이터를 저장하는데 시간을 많이 사용하게 되면 그만큼 UI에 버벅거림이 생기게 됩니다. 뷰모델은 이 문제를 어떻게 해결 할 수 있을까? 뷰모델은 아래와 같이 액티비티가 재생성이 되는 시나리오에서는 액티비티의 onDestroy가 호출되더라도 소멸되지 않습니다. 뷰모델은 액티비티내에서 finish()를 직접 호출하거나 사용자가 액티비티를 닫을 때(백키를 누르거나 히스토리에서 제거해서) 소멸됩니다. 뷰모델이 액티비티의 재생성시에도 살아 남으니 해결책은 아주 간단합니다. 액티비티가 재생성 되었을 때에도 유지하고 싶은 데이터는 뷰모델에 저장하면 됩니다. 뷰모델 사용 방법 간단히 화면에 게임의 점수를 표시해 준다고 생각해봅시다. 이 점수는 유저에 의해 업데이트가 되고, 가로모드를 지원하기 때문에 화면 방향이 전환되어도 유저에 의해 업데이트된 점수는 유지되어야 합니다. 이런 요구사항이 있을 때 뷰모델에 저장해야하는 값은 점수가 되어야 합니다. 아래와 같이 score를 저장하는 변수를 뷰모델에 선언해줍니다. 뷰모델 생성123class MyViewModel : ViewModel() { var scroe: Int = 0} 이렇게 만든 뷰모델은 생성자를 통해 만들지 않고 ViewModelProvider라는 팩토리 객체를 이용해서 만들어줘야합니다. 일단 뷰모델의 인스턴스를 얻었다면 그 이후 사용법은 간단합니다. 일반적인 클래스 객체를 사용하듯이 데이터를 읽고 쓰면 됩니다. 뷰모델의 사용123456789101112131415161718@Override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) // Get ViewModel instance mViewModel = ViewModelProviders.of(this).get(MyViewModel.class); // Update ui updateUi(mViewModel.scoreTeamA);}fun updateScore(score: Int) { // Read and write data from the ViewModel mViewModel.score = mViewModel.score + 1 // Update UI textViewScore.text = mViewModel.score.toString()} 참고로 안드로이드 개발자 페이지에서는 뷰모델과 라이브데이터(LiveData)를 함께 사용하는 예제를 보여주고 있습니다. 그 이유는 뷰모델과 라이브데이터를 함께 사용할 때 그 효용성이 극대화 되기 때문입니다. 지금은 이해를 돕기위해 라이브데이터에 대한 이야기는 하지 않겠습니다. 하지만 나중에 반드시 라이브데이터에 대해서도 공부해 보기를 권해드립니다. 뷰모델에 대해 조금 더 알아보자 앞에서 뷰모델이 어떤 문제를, 어떻게 해결 할 수 있는지 알아보았습니다. 이를 바탕으로 뷰모델을 언제, 어떻게 써야할지 조금 더 구체적으로 알아보도록 하겠습니다. 뷰모델에는 어떤 데이터를 저장해야 할까? 액티비티는 굉장히 다양한 데이터를 가지고 있을 수 있습니다. 그중에 뷰모델에 저장해야할 데이터는 어떤 데이터일까요? 정답은 UI와 연관된 데이터입니다. 앞서 뷰모델이 어떤 문제를 해결하고자 하는지를 이해했다면 당연한 이야기겠죠? 뷰모델을 사용할 때 주의점 뷰모델에는 반드시 액티비티나 프래그먼트(Fragment), 컨텍스트(Context)에 대한 참조를 저장하면 안됩니다. 뷰(Views)도 컨텍스트를 가지기 때문에 뷰에 대한 참조 역시 저장하면 안됩니다. 이에 대한 이유는 뷰모델의 생명주기를 생각해보면 알 수 있습니다. 뷰모델이 액티비티에 대한 참조를 갖고 있다고 생각해봅시다. 이 때 단말의 방향이 변경되어 액티비티가 재생성이 되면 어떻게 될까요? 현재 액티비티는 종료되고 새로운 액티비티가 생성되지만 뷰모델은 액티비티가 재생성 되어도 살아있기 때문에 종료된 액티비티의 참조를 갖고 있게됩니다. 결국 해당 액티비티는 뷰모델이 종료될 때까지 계속 메모리에 남게 됩니다. 즉 메모리 릭(Memory leak)이 발생합니다. 다만 여기에 한 가지 예외가 있는데, 어플리케이션의 컨텍스트는 뷰모델에서 가져도 됩니다. 어플리케이션은 액티비티가 아닌 어플리케이션의 생명주기를 따르기 때문입니다. 더해서, 뷰모델에서 시스템 서비스를 사용하기 위해 어플리케이션 컨텍스트가 필요한 경우 AndroidViewModel을 이용하면 됩니다. AndroidViewModel은 이런 경우를 위해 제공되는 뷰모델로 Application에 대한 참조를 가집니다. 뷰모델은 액티비티가 재생성될 때 UI와 관련된 데이터를 저장하기 위해 사용합니다. 또한 뷰모델은 액티비티의 재생성 시 UI 데이터를 저장하는 데 사용합니다. 데이터가 영구히 저장되어야 한다면 프리퍼런스(Preference)나 데이터베이스에 저장해야합니다. 뷰모델을 사용할 때 얻을 수 있는 추가적인 장점 뷰모델을 사용하면 UI와 관련된 데이터를 액티비티나 프래그먼트로부터 분리할 수 있습니다. 일반적으로 UI 개발 시 데이터와, 뷰, 로직을 분리하는 것이 코드의 복잡도를 줄이고 개발을 편하게 해준다는 것은 UI 개발에서 MVC, MVP, MVVM과 같이 다양한 패턴이 존재하는 것을 보아도 알 수 있습니다. 또한 이렇게 데이터와 UI를 분리하면 코드를 테스트 하기도 좋아집니다. 그리고 뷰모델을 올바르게 사용한다면 코드에 대한 가독성도 높아 질 수 있습니다. 예를 들어 어떤 액티비티의 코드를 분석하는데 여기서 뷰모델을 쓰고 있다면 바로 이 액티비티의 UI 관련 데이터는 이 뷰모델 코드를 보면 되겠구나하고 알 수 있습니다. 마무리 이번 글에서는 뷰모델의 개념에 대해 알아보았습니다. 뷰모델이 왜 만들어졌고 어떻게 사용하면 되는지만 알고 바로 뷰모델을 사용해도 되지만 뷰모델과 관련된 개념들은 재밌는 부분이 많습니다. 액티비티의 생명주기, 데이터를 저장하는 다양한 방법들, 라이브데이터, 프래그먼트, 디자인 패턴에서의 뷰모델과, 안드로이드 AAC 뷰모델과의 차이 등이 있는데 이런 개념들을 시간을 두고 하나씩 완전히 익혀두면 굉장히 큰 도움이 될 수 있습니다. 참고로 뷰모델에서 데이터를 저장하는 것은 내부적으로 프래그먼트의 setRetainInstance라는 메커니즘을 사용합니다. 마지막으로 어떤 도구도 상황에 맞게 사용하는 것이 중요합니다. 뷰모델에는 다양한 장점이 있지만 사용해야하는 곳과 주의할 점이 분명합니다. 이런 점들을 잘 알고 필요할 때 사용하는 것이 중요합니다. 이 글이 뷰모델을 사용하는데 조금이라도 도움이 되면 좋겠습니다. 참고자료 ViewModel Overview 안드로이드 공식 페이지의 뷰모델 사용 가이드 Understand the Activity Lifecycle 안드로이드 공식 페이지의 액티비티 생명주기 가이드 Parcelables and Bundles 안드로이드 공식 페이지의 Parcelables과 번들에 대한 설명 ViewModels : A Simple Example 구글 Advocator인 Lyla가 쓴 뷰모델의 사용 시 주의할 점과 다른 방식들과의 비교 ViewModels: Persistence, onSaveInstanceState(), Restoring UI State and Loaders 구글 Advocator인 Lyla가 쓴 뷰모델에 대한 전반적인 설명","link":"/2020/05/04/android/architecture-components/viewmodel/"}],"tags":[{"name":"android","slug":"android","link":"/tags/android/"},{"name":"floating widget","slug":"floating-widget","link":"/tags/floating-widget/"},{"name":"chat head","slug":"chat-head","link":"/tags/chat-head/"},{"name":"widget","slug":"widget","link":"/tags/widget/"},{"name":"system window","slug":"system-window","link":"/tags/system-window/"},{"name":"window","slug":"window","link":"/tags/window/"},{"name":"foundation","slug":"foundation","link":"/tags/foundation/"},{"name":"enum","slug":"enum","link":"/tags/enum/"},{"name":"typedef","slug":"typedef","link":"/tags/typedef/"},{"name":"annotation","slug":"annotation","link":"/tags/annotation/"},{"name":"compose","slug":"compose","link":"/tags/compose/"},{"name":"SideEffects","slug":"SideEffects","link":"/tags/SideEffects/"},{"name":"state","slug":"state","link":"/tags/state/"},{"name":"viewpager","slug":"viewpager","link":"/tags/viewpager/"},{"name":"process","slug":"process","link":"/tags/process/"},{"name":"thread","slug":"thread","link":"/tags/thread/"},{"name":"asynctask","slug":"asynctask","link":"/tags/asynctask/"},{"name":"gradle","slug":"gradle","link":"/tags/gradle/"},{"name":"build speed","slug":"build-speed","link":"/tags/build-speed/"},{"name":"tools","slug":"tools","link":"/tags/tools/"},{"name":"chromeadb","slug":"chromeadb","link":"/tags/chromeadb/"},{"name":"vysor","slug":"vysor","link":"/tags/vysor/"},{"name":"emacs","slug":"emacs","link":"/tags/emacs/"},{"name":"tool","slug":"tool","link":"/tags/tool/"},{"name":"org mode","slug":"org-mode","link":"/tags/org-mode/"},{"name":"package","slug":"package","link":"/tags/package/"},{"name":"elpa","slug":"elpa","link":"/tags/elpa/"},{"name":"melpa","slug":"melpa","link":"/tags/melpa/"},{"name":"wobbly-rocket","slug":"wobbly-rocket","link":"/tags/wobbly-rocket/"},{"name":"trading","slug":"trading","link":"/tags/trading/"},{"name":"personal-project","slug":"personal-project","link":"/tags/personal-project/"},{"name":"problem-solving","slug":"problem-solving","link":"/tags/problem-solving/"},{"name":"ai","slug":"ai","link":"/tags/ai/"},{"name":"agent-coding","slug":"agent-coding","link":"/tags/agent-coding/"},{"name":"Deeplinks","slug":"Deeplinks","link":"/tags/Deeplinks/"},{"name":"AppLinks","slug":"AppLinks","link":"/tags/AppLinks/"},{"name":"DynamicLinks","slug":"DynamicLinks","link":"/tags/DynamicLinks/"},{"name":"DefferedLinks","slug":"DefferedLinks","link":"/tags/DefferedLinks/"},{"name":"AppFundmental","slug":"AppFundmental","link":"/tags/AppFundmental/"},{"name":"URI","slug":"URI","link":"/tags/URI/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"font","slug":"font","link":"/tags/font/"},{"name":"font-family","slug":"font-family","link":"/tags/font-family/"},{"name":"serif","slug":"serif","link":"/tags/serif/"},{"name":"sans-serif","slug":"sans-serif","link":"/tags/sans-serif/"},{"name":"monoscape","slug":"monoscape","link":"/tags/monoscape/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Variance","slug":"Variance","link":"/tags/Variance/"},{"name":"Invariance","slug":"Invariance","link":"/tags/Invariance/"},{"name":"Covariance","slug":"Covariance","link":"/tags/Covariance/"},{"name":"Contravariance","slug":"Contravariance","link":"/tags/Contravariance/"},{"name":"OOP","slug":"OOP","link":"/tags/OOP/"},{"name":"Polymorphysm","slug":"Polymorphysm","link":"/tags/Polymorphysm/"},{"name":"ogtag","slug":"ogtag","link":"/tags/ogtag/"},{"name":"weblink","slug":"weblink","link":"/tags/weblink/"},{"name":"card","slug":"card","link":"/tags/card/"},{"name":"programming","slug":"programming","link":"/tags/programming/"},{"name":"kotlin","slug":"kotlin","link":"/tags/kotlin/"},{"name":"delegation","slug":"delegation","link":"/tags/delegation/"},{"name":"theme","slug":"theme","link":"/tags/theme/"},{"name":"style","slug":"style","link":"/tags/style/"},{"name":"dark theme","slug":"dark-theme","link":"/tags/dark-theme/"},{"name":"dark mode","slug":"dark-mode","link":"/tags/dark-mode/"},{"name":"viewmodel","slug":"viewmodel","link":"/tags/viewmodel/"},{"name":"testing","slug":"testing","link":"/tags/testing/"}],"categories":[{"name":"programming","slug":"programming","link":"/categories/programming/"},{"name":"android","slug":"programming/android","link":"/categories/programming/android/"},{"name":"tool","slug":"tool","link":"/categories/tool/"},{"name":"wobbly-rocket","slug":"wobbly-rocket","link":"/categories/wobbly-rocket/"},{"name":"web","slug":"programming/web","link":"/categories/programming/web/"},{"name":"kotlin","slug":"programming/kotlin","link":"/categories/programming/kotlin/"},{"name":"emacs","slug":"tool/emacs","link":"/categories/tool/emacs/"},{"name":"compose","slug":"programming/android/compose","link":"/categories/programming/android/compose/"},{"name":"android","slug":"programming/kotlin/android","link":"/categories/programming/kotlin/android/"}]}