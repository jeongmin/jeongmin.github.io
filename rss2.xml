<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>코딩 소년의 블로그</title>
    <link>https://jeongmin.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>프로그래밍을 하며 배운 것들과 생각들을 남기는 공간입니다. 다른 개발자 분들과도 많은 교류를 할 수 있었으면 좋겠습니다.</description>
    <pubDate>Fri, 13 Feb 2026 07:51:03 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>매매는 객관화했지만 행동은 그대로였다(인사이트 탭 MVP 회고)</title>
      <link>https://jeongmin.github.io/2026/02/13/wobbly-rocket/insights/</link>
      <guid>https://jeongmin.github.io/2026/02/13/wobbly-rocket/insights/</guid>
      <pubDate>Thu, 12 Feb 2026 15:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/wobbly-rocket/wobblyrocket-logo.png&quot; alt=&quot;Wobbly Rocket&quot;&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://jeong
        
      
      </description>
      
      
      <content:encoded><![CDATA[<div align="center"><p><img src="/assets/img/wobbly-rocket/wobblyrocket-logo.png" alt="Wobbly Rocket"></p></div><p><a href="https://jeongmin.github.io/2026/02/11/wobbly-rocket/blueprint/">이전 글(워블리 로켓 소개)</a>에서 소개한 워블리 로켓의 첫번째 주인공 <code>인사이트</code> 탭의 MVP가 어느정도 완료되어 개발하고 사용해보면서 느낀 점을 남겨보려 합니다.</p><h1>인사이트 탭 소개</h1><blockquote><p>본인의 매매 습관을 개선하고 수익이 나는 시스템을 만든다.</p></blockquote><p>이게 워블리 로켓의 메인 컨셉인데요. 이를 위해 제가 생각한 문제 해결 방법은 아래와 같습니다.</p><ol><li>문제를 객관화 하고 인사이트를 도출한다.</li><li>1에서 도출한 인사이트를 바탕으로 안좋은 습관을 개선한다.</li><li>자기만의 수익이 나는 시스템을 구축한다.</li></ol><p>안좋은 습관을 개선하고, 수익이 나는 매매 시스템을 만들기 위한 첫걸음은 나의 매매 기록을 통해 객관적으로 매매를 분석해야합니다.</p><p>이 역할을 위해 인사이트 탭을 MVP로 구상하게되었습니다.</p><h2 id="기본-구성">기본 구성</h2><p>인사이트 탭은 오늘을 기준으로 90일, 30일, 7일을 기준으로 매매기록을 가져와서 분석합니다. 그리고 이를 바탕으로 객관적인 데이터, 그리고 이에 대한 인사이트를 함께 보여주도록 설계하였습니다.</p><p>분석 결과는 <code>순손익</code>, <code>자산 곡선</code>, <code>승률 &amp; 손익비</code>, <code>포지션 크기 분석(켈리 기준)</code>, <code>레버리지별 성과</code>, <code>보유 기간별 성과</code>, <code>시간대별 성과</code> 카드로 구성하여 데이터와 인사이트, 그리고 각 카드의 해석 방법 및 원리를 설명하는 가이드로 UI를 구성하였습니다.</p><div align="center"><p><img src="/assets/img/wobbly-rocket/insights.gif" alt="Insights"></p></div><h2 id="어떤-데이터를-보여줘야-할까">어떤 데이터를 보여줘야 할까</h2><p>단순히 매매의 기록을 나열하는건 의미가 없습니다. 인사이트라는 탭의 이름 처럼 데이터를 통해 의미있는 인사이트가 나올 수 있는 데이터를 보여주는 것이 중요합니다.</p><p>그래서 MVP를 만들때도 이 부분을 많이 고민했는데요.</p><p>예를들어 롱, 숏 포지션 비율과 포지션 별 P&amp;L 같은 데이터의 경우 처음엔 매력적인 데이터라 생각했지만 곰곰히 생각해보니 어떤 포지션을 잡는지는 장의 상황에 따라 달라질 수 있고, 추세라는 것은 매매를 하는 타임 프레임에 따라 장기, 중기, 단기 추세가 모두 다를 수 있기에 의미있는 데이터로 보기 어렵다고 생각했습니다.</p><p>티커별 분석 역시 비슷한 맥락의 고민이 있었습니다. 티커별 매매 횟수를 나누면 표본이 줄어들고, 특정 티커에서 강하다는 결과가 나오더라도 그것이 실력인지 운인지 구분하기 어렵습니다.</p><p>결국 인사이트 탭에서 가장 중요한건 레버리지, 손절 미준수, 감정적 진입, 틸트, 복수 매매나, 집중하지 못하는 매매 시간대 등의 매매 행동과 관련된 정보라고 보았습니다.</p><h2 id="각-카드-소개">각 카드 소개</h2><p>어떤 데이터를 보여줘할지 다양한 고민을 통해 MVP에서 추가한 각 카드에 대해 소개합니다.</p><h3 id="순손익">순손익</h3><div align="center"><p><img src="/assets/img/wobbly-rocket/pnl.png" alt="순손익"></p></div><p>가장 먼저 보여주는 것은 하나의 숫자로 바로 보여지는 내 매매의 성적표입니다. 선택한 기간 동안의 순손익과 거래당 평균 손익을 통해 “내가 잘하고 있는것 같아”, &quot;잘 못하고 있는것 같아&quot;같은 감이 아닌 구체적인 숫자로 현재 위치를 확인하게 합니다. <code>&quot;열심히 했다&quot;가 아니라 &quot;결과가 어땠는지&quot;를 한번에 보여줍니다.</code></p><h3 id="자산-곡선">자산 곡선</h3><div align="center"><p><img src="/assets/img/wobbly-rocket/assets-chart.png" alt="자산 곡선"></p></div><p>순손익은 한줄의 숫자이지만, 자산 곡선은 과정입니다. 수익, 손실이 어떻게 쌓였는지, 어디에서 무너졌는지, 급격한 변동은 언제였는지를 한눈에 보여줍니다. 특히 급락 구간은 대부분 전략이 아니라 감정이 개입된 지점입니다.</p><h3 id="승률-손익비">승률 &amp; 손익비</h3><div align="center"><p><img src="/assets/img/wobbly-rocket/winrate-pnl.png" alt="승률 &amp; 손익비"></p></div><p>많이 이겼는지가 아니라 제대로 이겼는지를 보여주는 카드입니다. 승률과 손익비를 함께 보여줌으로써 &quot;이기는 구조인지&quot;를 점검합니다. 승률이 높아도 손익비가 낮으면 결국 무너집니다. 승률이 낮아도 손익비가 받쳐주면 살아남습니다.</p><h3 id="포지션-크기-분석-켈리-기준">포지션 크기 분석 (켈리 기준)</h3><div align="center"><p><img src="/assets/img/wobbly-rocket/position-size-kelly.png" alt="포지션 크기 분석 (켈리 기준)"></p></div><p>켈리 값(Kelly Criterion)은 승률과 손익비를 기반으로, 장기적으로 자본을 가장 효율적으로 성장시킬 수 있는 <code>적정 베팅 비율</code>을 계산하는 공식입니다.</p><p>승률이 높고 손익비가 좋을수록 켈리 값은 커지고, 구조가 불리할수록 값은 작아지거나 음수가 됩니다. 음수라는 것은, 현재의 승률과 손익비로 계속 매매하면 결국 손실로 수렴할 가능성이 높다는 의미입니다.</p><p>이 카드를 통해 현재의 매매 방식이 지속 가능한 구조인지와, 자산을 안전하게 불릴 수 있는 적당한 크기의 포지션 크기를 알 수 있습니다.</p><h3 id="레버리지별-성과">레버리지별 성과</h3><div align="center"><p><img src="/assets/img/wobbly-rocket/leverage.png" alt="레버리지별 성과"></p></div><p>레버리지를 올릴수록 수익이 늘었는지, 아니면 손실이 커졌는지를 확인합니다. 많은 경우 문제는 방향이 아니라 포지션의 크기에 있습니다. 이 카드는 ‘얼마를 베팅했는지’, 즉 비중 조절이 성과에 어떤 영향을 미쳤는지를 보여줍니다.</p><h3 id="보유-기간별-성과">보유 기간별 성과</h3><div align="center"><p><img src="/assets/img/wobbly-rocket/holding-time.png" alt="보유 기간별 성과"></p></div><p>나는 짧게 잘하는 사람인지, 길게 잘하는 사람인지를 보여줍니다. 보유 시간이 길어질수록 수익이 나는지, 손실이 커지는지를 통해 자신의 스타일과 실제 성과를 비교할 수 있습니다.</p><h3 id="시간대별-성과">시간대별 성과</h3><div align="center"><p><img src="/assets/img/wobbly-rocket/time-period.png" alt="시간대별 성과"></p></div><p>시장에는 리듬이 있고, 사용자에게도 리듬이 있습니다. 시장은 유동성과 변동성이 커지거나 작아지는 시간대가 있고, 사용자에게도 집중할 수 있는 시간, 집중력이 떨어지고 이성보다 감정으로 매매하게 되는 시간이 있습니다. 본인이 성과를 내는 시간, 반대로 손실을 내는 시간대가 있다면 이를 매매에 반영할 수 있습니다.</p><h3 id="인사이트-탭이-내게-남긴-가르침">인사이트 탭이 내게 남긴 가르침</h3><p>인사이트 탭 소개 단락에서 문제 해결을 위한 첫번째 단계로 <code>문제를 객관화 하고 인사이트를 도출한다.</code>를 말씀드렸습니다.</p><p>결론적으로 현재 MVP의 구성으론 어느정도 이 목표를 달성했다고 생각합니다. 물론 부족한 부분이 아주 많습니다. 매매별 상세 분석이나, 기간 별 변화, 즉 나의 매매가 개선되고 있는지, 나빠지고 있는지, 그리고 가장 중요한 나쁜 매매 습관을 잡아내는 부분은 추가해야할 부분입니다.</p><p>특히나 복수 매매, 틸트 같이 안좋은 습관을 찾아내는 부분은 생각보다 고민할 부분이 많아 MVP에서 제외하였습니다.</p><h2 id="그래서-인사이트-탭이-내-매매를-개선해줄까요">그래서 인사이트 탭이 내 매매를 개선해줄까요?</h2><p>인사이트 탭을 만들면서 처음으로 제 매매를 객관화해서 볼 수 있었고, 막연히 감으로만 느끼고 있던 내 매매의 문제들을 구체적인 숫자로 마주할 수 있었습니다.</p><p>굉장히 충격적이였고 재미있었습니다. <code>하지만 나쁜 매매 습관은 여전히 달라지지 않았습니다.</code></p><p>여전히 손절을 어려워했고, 감정 매매나, 확신없는 고레버리지의 사용이 반복되었습니다. 사실 인사이트 탭의 목적은 행동 교정보다는 매매의 객관화와 인사이트 제공에 있습니다.</p><p>하지만 그럼에도 유저가 본인의 매매를 객관화 할 수 있다면 행동 교정의 효과도 있지 않을까 하고 막연히 생각했던 가설은 보기 좋게 빗나갔습니다.</p><h3 id="새롭게-발견한-가치">새롭게 발견한 가치</h3><p>인사이트 탭이 나쁜 습관을 교정해주는 힘은 약했지만 리텐션 쪽으로는 강한 잠재력이 있다고 느꼈습니다. 매매가 끝날 때마다 변화된 수치를 눈으로 확인하는 것이 재미있었고, 이런 면에서는 수치를 개선하는 재미를 잘 풀어냈을때 재미를 통한 행동 교정 효과 역시 가져올 수 있겠구나 하는 생각이 들었습니다.</p><p>두번째로, 인사이트 탭은 아직 성과가 안정적이지 않은 사람보다 어느정도 잘하는 사람에게 더 매력있는 탭이 될 수 있단 생각이 들었습니다.</p><p>잘 못하는 사람이 본인의 데이터를 반복적으로 보면서 개선을 하는 패턴을 생각했지만, 내가 매매를 잘 못한 경우엔 인사이트 탭의 데이터가 안좋아 진걸 확인하기 싫었고, 반대로 매매를 통해 수익을 내고 좋은 매매를 하고 있다고 생각이 들땐 반복적으로 인사이트 탭의 데이터를 보면서 기분이 좋아졌습니다.</p><p>이런 부분을 잘 참고해서 인사이트 탭을 개선하면 MVP를 벗어나 정말 의미있는 기능이 되지 않을까 생각해봅니다.</p><h3 id="앞으로의-방향">앞으로의 방향</h3><p>오늘 소개드린 인사이트 탭은 MVP 입니다. 당연히 개선할 부분이 많고, MVP를 진행하면서 보이는 방향성도 확실합니다. 특히 기간별 비교를 통한 동기부여나 재미요소를 추가하는 부분은 반드시 빠르게 개선해야할 부분입니다.</p><h3 id="아쉬운-점">아쉬운 점</h3><p>이 프로젝트는 저 개인의 문제를 해결해보자는 마음으로 시작했지만 이게 정말 다른 사람에게도 의미가 있을지는 사실 모르겠습니다. 다양한 유저 피드백을 받을 수 있다면 더 완성도를 올릴 수 있을거라 생각합니다.</p><h2 id="마무리">마무리</h2><p>이 글에서는 워블리 로켓의 인사이트 탭 MVP를 진행하면서 고민했던 점들과 결과물을 소개해보았습니다. 기술적인 내용은 없지만 문제 해결을 위한 다양한 고민을 해보면서 개인적으로 아주 즐거웠습니다. 앞으로 워블리 로켓의 발전 모습을 꾸준히 올려보려 합니다. 감사합니다.</p>]]></content:encoded>
      
      <comments>https://jeongmin.github.io/2026/02/13/wobbly-rocket/insights/#disqus_thread</comments>
    </item>
    
    <item>
      <title>워블리 로켓</title>
      <link>https://jeongmin.github.io/2026/02/11/wobbly-rocket/blueprint/</link>
      <guid>https://jeongmin.github.io/2026/02/11/wobbly-rocket/blueprint/</guid>
      <pubDate>Tue, 10 Feb 2026 15:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/assets/img/wobbly-rocket/wobblyrocket-logo.png&quot; alt=&quot;Wobbly Rocket&quot;&gt;&lt;/p&gt;
&lt;p&gt;오늘은 기술 이야기가 아닌 개인 프로젝트 이야기를 해보려 합니다. 이름은 &lt;code&gt;워블리
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="/assets/img/wobbly-rocket/wobblyrocket-logo.png" alt="Wobbly Rocket"></p><p>오늘은 기술 이야기가 아닌 개인 프로젝트 이야기를 해보려 합니다. 이름은 <code>워블리 로켓(Wobbly Rocket)</code>. 어떤 앱이 될지는 아래와 같이 정리해보았습니다.</p><blockquote><p>자신의 매매 기록을 분석하여 트레이딩 습관과 패턴을 개선하고, 검증된 전략을 단계적으로 자동화하는 개인 트레이딩 플랫폼</p></blockquote><p>사실 이 블로그는 개발하면서 배운 내용들을 정리하는 기술 블로그로 사용되고 있었는데요. AI 도구들이 발전하면서 기술 블로그를 운영하는게 의미가 있나…? 하는 생각에 한동안 손을 놓고 있다가 지금 하고 있는 프로젝트를 하면서 느끼는 점, 고민되는 부분 등을 편하게 남기는것도 의미가 있을 것 같아 오랜만에 키보드를 붙잡았습니다.</p><h1>워블리 로켓을 시작하게 된 이유</h1><p>저는 해외 암호화폐 선물 거래소의 개발자였습니다. 사실 처음에는 캔들 차트가 뭐인지도 몰라서 면접때 쩔쩔매던, 매매에 있어서는 백지 같은 사람이였습니다. 일을 하며 거래소를 만드는 사람으로서 매매를 모른다는 건 이상하다고 느꼈습니다. 그래서 직접 매매를 시작하게 되었습니다.</p><p>처음에는 초심자의 행운도 있었고 아무 전략 없이, 공부도 없이, 홀짝 게임처럼 진입했는데도 수익이 나기도 했습니다. 하지만 결국은 반복되는 청산과 손실. 계좌는 꾸준히 줄어들었습니다.</p><h2 id="문제는-지식이-아니었습니다">문제는 지식이 아니었습니다</h2><p>결국 큰 손실을 겪고 저는 열심히 공부를 했습니다. 기술적 분석, 지표, 리스크 관리, 켈리 공식…이론은 점점 쌓여갔습니다. 그런데 이상하게도 손실은 계속되더군요.</p><p>그러다 깨달았습니다.</p><blockquote><p>내가 몰라서 잃는 게 아니라<br>내가 나를 통제하지 못해서 잃는 순간이 훨씬 많다는 것.</p></blockquote><ul><li>뇌동매매(감정 매매, 틸트)</li><li>복구 심리</li><li>포지션 중독</li><li>성급함</li></ul><p>지식과 별개로, 습관과 감정이 제 계좌를 무너뜨리고 있었습니다. <code>하지만 이걸 깨달았음에도 제 계좌는 계속 손실만 쌓여갔습니다.</code> 사실 매매를 해보신 분들은 대부분 공감할 이야기일 겁니다. 배운건 많지만 결국 욕심과 감정 때문에 배운대로 매매 하는게 아니라 본능대로 매매 한다는 것을요.</p><h2 id="내가-하고-싶은-것">내가 하고 싶은 것</h2><p>워블리 로켓은 일단 저의 문제를 풀어보고 싶어서 시작한 프로젝트입니다. 그래서 제가 풀고 싶은 문제를 좀 구체화 해보았습니다.</p><ul><li>내가 반복하는 실수를 데이터로 마주하고 싶다.</li><li>감정이 아니라 시스템으로 의사결정하고 싶다.</li><li>“운”이 아니라 “재현 가능한 수익이 나는 시스템”을 만들고 싶다.</li></ul><h2 id="그래서-어떻게">그래서 어떻게?</h2><p>예전에 틱낫한 스님의 '화’라는 책을 감명깊게 본 기억이 있습니다. 이 책에서 화를 내는 습관을 고치는 핵심은 '화’가 날때마다 이를 인지하고 바라보라는 것이였습니다.</p><p>우리의 문제도 비슷하다고 생각합니다. 먼저 무엇이 문제인지를 명확하게 바라보고 인식할 수 있어야합니다. 내가 문제가 있다는걸 모르거나, 있더라도 그 문제를 구체적으로 보지 못하면 막연하게 나는 안좋은 습관이 있나부다 정도로 끝나게 됩니다.</p><p>그래서 저는 제가 풀고 싶은 매매에서의 문제를 아래의 단계로 풀어보려 합니다.</p><ol><li>나의 매매 데이터를 통해 현재 매매를 분석하고 인사이트를 도출한다.(나의 문제를 인식한다.)</li><li>분석한 매매 정보를 바탕으로 수익이 나는 매매 구조를 만들기 위한 '행동’을 제안한다.</li><li>수익이 나는 구조를 시스템화 한다.</li></ol><h2 id="마무리">마무리</h2><p>마지막으로 최근 AI 도구들이 정말 무섭게 발전하고 있습니다. 이에 따라 전통적인 기획, 디자인, 개발의 경계도 많이 흐려지고 있구요. 특히나 혼자서 기획, 설계, 개발, 디자인, 실험까지 모두 해야 하는 개인 프로젝트에서 AI는 이제 선택이 아니라 필수입니다.</p><p>그동안 개발자로서 기술에 많은 관심이 있었습니다. 하지만 이제는 AI가 발전하며 기술적인 부분의 많은 것들을 AI가 담당하고 있습니다. 이제는 개발자도 문제해결의 영역을 개발문제가 아닌 현실의 문제로 확장해야하는 시기가 온것 같습니다.</p><p>워블리 로켓에서 워블리(Wobbly)는 ‘흔들리는’, ‘기우뚱한’, ‘비틀거리는’ 등의 의미를 가진 단어입니다. 매매를 주제로 다루는 서비스에 다소 어울리지 않을 수도 있다고 생각합니다.</p><p>하지만 저는 이렇게 생각해보았습니다. 사람은 누구나 실패하고 실수를 합니다. 그리고 대부분의 커다란 성공에도 부족한 시작의 단계가 있을겁니다. 그래서 저는 이 이름이 좋습니다. 완벽하지 않고 부족하고, 실패도 겪지만 결국은 로켓처럼 성공을 향해 날아가리라는 바램을 담아보았습니다. 이 글을 보는 다른 분들도 모두 이렇게 되길 바라며 글을 마칩니다.</p>]]></content:encoded>
      
      <comments>https://jeongmin.github.io/2026/02/11/wobbly-rocket/blueprint/#disqus_thread</comments>
    </item>
    
    <item>
      <title>rememberUpdatedState 이해하기</title>
      <link>https://jeongmin.github.io/2024/06/19/android/rememberUpdatedState/</link>
      <guid>https://jeongmin.github.io/2024/06/19/android/rememberUpdatedState/</guid>
      <pubDate>Tue, 18 Jun 2024 15:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;Jetpack Compose를 사용하다 보면 상태(State)와 재구성(Recomposition)에 대해 자주 마주하게 됩니다. &lt;code&gt;rememberUpdatedState&lt;/code&gt;는 이러한 상태 관리에서 중요한 역할을 합니다. 공식 문서
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>Jetpack Compose를 사용하다 보면 상태(State)와 재구성(Recomposition)에 대해 자주 마주하게 됩니다. <code>rememberUpdatedState</code>는 이러한 상태 관리에서 중요한 역할을 합니다. 공식 문서에 나와 있는 설명을 보면 다음과 같습니다.</p><blockquote><p>reference a value in an effect that shouldn’t restart if the value changes</p></blockquote><p>저는 이 설명이 처음에 잘 이해되지 않았습니다. 그래서 <code>rememberUpdatedState</code>를 이해하기 위해 정리 겸 이 글을 쓰게 되었습니다. 이 글이 다른 사람에게 도움이 되기를 바랍니다.</p><h2 id="예시-코드">예시 코드</h2><p>다음은 <code>rememberUpdatedState</code>를 설명하기 위해 공식 문서에서 사용된 샘플 코드입니다. <code>LandingScreen</code> 컴포저블은 최초 생성 후 일정 시간(<code>SplashWaitTimeMillis</code>)이 지나면 <code>onTimeout</code> 함수를 호출하는 역할을 합니다.</p><p><strong>중요한 요구사항은 <code>LandingScreen</code>이 재구성 되더라도 딜레이는 늘어나면 안 된다는 점입니다.</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">LandingScreen</span><span class="params">(onTimeout: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This will always refer to the latest onTimeout function that</span></span><br><span class="line">    <span class="comment">// LandingScreen was recomposed with</span></span><br><span class="line">    <span class="keyword">val</span> currentOnTimeout <span class="keyword">by</span> rememberUpdatedState(onTimeout)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create an effect that matches the lifecycle of LandingScreen.</span></span><br><span class="line">    <span class="comment">// If LandingScreen recomposes, the delay shouldn't start again.</span></span><br><span class="line">    LaunchedEffect(<span class="literal">true</span>) &#123;</span><br><span class="line">        delay(SplashWaitTimeMillis)</span><br><span class="line">        currentOnTimeout()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Landing screen content */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드에서 <code>rememberUpdatedState</code>의 역할은 무엇일까요? <code>rememberUpdatedState</code>를 사용하지 않고 <code>onTimeout</code>을 <code>LaunchedEffect</code>에서 사용하면 어떻게 될까요?</p><h2 id="rememberUpdatedState-없이-사용하는-경우">rememberUpdatedState 없이 사용하는 경우</h2><p><code>LaunchedEffect</code>는 키가 <code>true</code> 로 설정되어 한번만 실행됩니다. 하지만 <code>LandingScreen</code>은 <code>onTimeout</code> 이 변경될 때마다 재구성됩니다.</p><p><strong>이때 <code>LaunchedEffect</code>는 처음 실행될 때 캡쳐한 <code>onTimeout</code>을 사용하기 때문에, <code>LandingScreen</code>의 <code>onTimeout</code>이 변경되어 재구성된 후에도 처음 받은 <code>onTimeout</code>을 호출하게 됩니다.</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">LandingScreen</span><span class="params">(onTimeout: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    LaunchedEffect(<span class="literal">true</span>) &#123;</span><br><span class="line">        delay(SplashWaitTimeMillis)</span><br><span class="line">        onTimeout() <span class="comment">// 변경된 onTimeout이 아니라 처음 캡처된 onTimeout이 호출됨</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Landing screen content */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LaunchedEffect의-키로-onTimeout을-사용하는-경우">LaunchedEffect의 키로 onTimeout을 사용하는 경우</h2><p><code>LaunchedEffect</code>의 키로 <code>onTimeout</code>을 사용하면, <code>onTimeout</code>이 변경될 때마다 <code>LaunchedEffect</code>가 재실행됩니다.</p><p><strong>이렇게 하면 항상 최신의 <code>onTimeout</code>이 호출되지만, <code>LaunchedEffect</code>가 재실행될 때마다 <code>delay(SplashWaitTimeMillis)</code>도 다시 시작되므로 딜레이 시간이 길어질 수 있습니다.</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">LandingScreen</span><span class="params">(onTimeout: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    LaunchedEffect(onTimeout) &#123;</span><br><span class="line">        delay(SplashWaitTimeMillis)</span><br><span class="line">        onTimeout() <span class="comment">// 항상 최신 onTimeout이 호출됨</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Landing screen content */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rememberUpdatedState의-역할">rememberUpdatedState의 역할</h2><p><strong><code>rememberUpdatedState</code>를 사용하면 <code>LaunchedEffect</code>가 재실행되지 않으면서도 항상 최신의 <code>onTimeout</code>을 참조할 수 있습니다. 이는 <code>LaunchedEffect</code>가 재실행되지 않아 딜레이 시간이 유지되면서도, 최신 상태를 유지할 수 있게 합니다.</strong></p><p>이제 아래의 <code>rememberUpdatedState</code>에 대한 공식 문서의 한줄 설명이 이해가 되시나요?</p><blockquote><p>reference a value in an effect that shouldn’t restart if the value changes</p></blockquote><p>혹시 이 글이 다소 이해가 되지 않는다면 람다와 클로저, 그리고 이펙트에 대해 다시 학습해보면 도움이 되리라 생각합니다.</p><h2 id="구현-보기">구현 보기</h2><p>마지막으로 <code>rememberUpdatedState</code>의 구현을 코드로 살펴봅시다.</p><p><code>rememberUpdatedState</code>는 아래와 같이 구현되어 있습니다. <code>remember</code>에서 <code>mutableStateOf(newValue)</code>를 통해 <code>newValue</code>를 값으로 갖는 <code>State</code>를 반환 합니다. 따라서 이렇게 반환된 <code>State</code>는 리컴포지션이 발생하더라도 변경되지 않고 캐싱됩니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">rememberUpdatedState</span><span class="params">(newValue: <span class="type">T</span>)</span></span>: State&lt;T&gt; = remember &#123;</span><br><span class="line">    mutableStateOf(newValue)</span><br><span class="line">&#125;.apply &#123; value = newValue &#125;</span><br></pre></td></tr></table></figure><p>그리고 바로 <code>apply { value = newValue }</code>를 통해 상태를 최신 값인 <code>newValue</code>로 업데이트 합니다. 즉 이 구현은 상태 객체 자체는 유지하면서 값만 최신으로 업데이트하는 역할을 합니다. 이를 통해 최신 값을 항상 참조할 수 있습니다.</p>]]></content:encoded>
      
      <comments>https://jeongmin.github.io/2024/06/19/android/rememberUpdatedState/#disqus_thread</comments>
    </item>
    
    <item>
      <title>자바와 코틀린에서의 변성(Variance in Java and Kotlin)</title>
      <link>https://jeongmin.github.io/2024/04/13/kotlin/variance%20in%20kotlin%20and%20java/</link>
      <guid>https://jeongmin.github.io/2024/04/13/kotlin/variance%20in%20kotlin%20and%20java/</guid>
      <pubDate>Fri, 12 Apr 2024 15:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;들어가며&quot;&gt;들어가며&lt;/h2&gt;
&lt;p&gt;코틀린 코드에서 자주 보게되는 &lt;code&gt;in&lt;/code&gt;과 &lt;code&gt;out&lt;/code&gt;, 그리고 자바에서 자주 보게 되는 &lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="들어가며">들어가며</h2><p>코틀린 코드에서 자주 보게되는 <code>in</code>과 <code>out</code>, 그리고 자바에서 자주 보게 되는 <code>&lt;? extends T&gt;</code>, <code>&lt;? super T&gt;</code> 는 제네릭의 변성과 깊은 관련이 있습니다. 이 글에서는 자바와 코틀린과 같은 객체지향 프로그래밍 언어에서 사용되는 변성의 개념을 살펴 보도록 하겠습니다.</p><h2 id="서브타입과-다형성-Subtypes-and-Polymorphism">서브타입과 다형성(Subtypes and Polymorphism)</h2><p>객체지향 프로그래밍 언어에서는 클래스의 상속이나 인터페이스, 추상클래스를 이용하여 객체를 모델링 합니다. 추상화된 개념을 이용하여 슈퍼타입을 만들면 이로부터 슈퍼타입을 구체화 하는 서브타입을 만들어 낼 수 있습니다.</p><p>서브타입은 슈퍼타입에 정의된 기능과 속성을 상속받아 그대로 사용하거나 필요에 따라 재정의할 수 있습니다.</p><p>서브타입을 인스턴스화 할 때 해당 인스턴스는 그 슈퍼타입으로 받아 사용이 가능합니다. 이를 <strong>다형성</strong>이라고 합니다. 다형성은 객체지향 프로그래밍의 핵심 기능으로 아주 강력한 편의성과 확장성을 가져다 주는 도구입니다.</p><p><img src="/assets/img/variance/subtyping.png" alt="Subtyping"></p><blockquote><p>이를테면 동물이라는 추상화를 하고 이를 구체화하는 개, 고양이와 같은 서브타입을 만들 수 있는데 이를 <strong>서브타이핑</strong>이라 하고, 동물이란 타입을 이용하여 개나 고양이 객체를 받아서 동물에 정의된 공통 동작과 속성을 사용하는 것을 <strong>다형성</strong> 이라고 합니다.</p></blockquote><p>객체 지향 프로그래밍 언어에서 갖는 설계상 이점의 아주 큰 부분이 다형성을 바탕으로 존재합니다.</p><h3 id="예제-코드">예제 코드</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Super class</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">makeSound</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"Animal makes a sound"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sub class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="type">Animal</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">makeSound</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"Bark"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sub class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> : <span class="type">Animal</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">makeSound</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"Meow"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> myDog: Animal = Dog()</span><br><span class="line">    <span class="keyword">val</span> myCat: Animal = Cat()</span><br><span class="line"></span><br><span class="line">    myDog.makeSound()  <span class="comment">// Outputs: Bark</span></span><br><span class="line">    myCat.makeSound()  <span class="comment">// Outputs: Meow</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="제네릭-Generics">제네릭(Generics)</h2><p>제네릭은 객체지향 프로그래밍을 지원하는 언어에서 타입 안정성을 제공하면서도 다양한 타입을 다룰 수 있는 방법으로 제공됩니다. 클래스, 인터페이스, 함수를 정의 할 때 타입을 플레이스홀더로 지정하는 방식으로 사용합니다.</p><p>이해를 돕기 위한 예를 들자면 제네릭은 라벨이 붙은 상자라고 볼 수 있습니다. 상자에 붙은 라벨에 따라 이 박스는 <code>Animal</code>을 넣거나, <code>Dog</code>, <code>Cat</code> 을 넣을 수 있습니다.</p><p><img src="/assets/img/variance/generics.png" alt="Generics"></p><h3 id="제네릭-클래스-Generic-Classes">제네릭 클래스(Generic Classes)</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="type">T</span>&gt;</span>(t: T) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="제네릭-함수-Generic-Functions">제네릭 함수(Generic Functions)</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">singletonList</span><span class="params">(item: <span class="type">T</span>)</span></span>: List&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> listOf(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="변성-Variance">변성(Variance)</h2><p>앞서 서브타이핑, 다형성, 그리고 제네릭에 대해 설명했습니다. 그럼 <code>Box&lt;T&gt;</code>라는 제네릭 타입이 있을 때, <code>Box&lt;Animal&gt;</code>과 <code>Box&lt;Dog&gt;</code>, <code>Box&lt;Cat&gt;</code> 사이에도 <code>Animal</code>, <code>Dog</code>, <code>Cat</code> 사이에 있었던 서브타이핑 관계가 유지될까요?</p><p><strong>변성이란 바로 서브타이핑 관계에 있는 타입들이 제네릭에서 갖는 성질입니다.</strong></p><p>변성은 <strong>불변성(Invariance)</strong>, <strong>공변성(Covariance)</strong>, <strong>반공변성(Contravariance)</strong> 의 세 가지 성질을 가집니다.</p><h3 id="불변성-Invariance">불변성(Invariance)</h3><p>자바나 코틀린에서는 다형성으로 인해 <code>S</code>가 <code>T</code>의 서브타입이면 <code>T = S</code>가 가능하지만, <code>Box&lt;T&gt; = Box&lt;S&gt;</code>는 기본적으로 허용되지 않습니다. 이것이 제네릭의 불변성입니다. 한마디로 제네릭 타입 간에는 다형성과 같은 규칙이 적용되지 않습니다.</p><p>아래와 같은 코드는 잘 동작하지만,</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>: <span class="type">Animal</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> animal: Animal = Dog()</span><br></pre></td></tr></table></figure><p>아래와 같은 코드는 허용되지 않습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>: <span class="type">Animal</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">var</span> t: T)</span><br><span class="line"><span class="keyword">val</span> animalBox: Box&lt;Animal&gt; = Box&lt;Dog&gt;(Dog())</span><br></pre></td></tr></table></figure><h4 id="제네릭-타입이-불변인-이유">제네릭 타입이 불변인 이유</h4><p>그렇다면 제네릭이 불변성을 갖는 이유는 무엇일까요?</p><p><strong>이는 런타임 타입 안정성 때문입니다.</strong> 예를들어 자바에서 <code>Object</code>는 모든 타입의 슈퍼타입이지만 다형성에서 허용하듯 제네릭에서도 이를 허용하면 아래와 같은 경우 런타임 타입 안정성이 깨지게 됩니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 다형성에서는 슈퍼타입이 서브타입을 받을 수 있다.</span></span><br><span class="line">Animal obj = <span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 제네릭 타입에서는 다형성에서의 타입 관계가 허용되지 않는다.</span></span><br><span class="line">List&lt;Dog&gt; dogs = <span class="keyword">new</span> ArrayList&lt;Dog&gt;();</span><br><span class="line">List&lt;Animal&gt; animals = dogs; <span class="comment">// 컴파일이 되지 않음!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 컴파일이 됐다면 아래 코드에서 런타임 에러 발생</span></span><br><span class="line">animals.add(Cat());  <span class="comment">// 쓰기: animals는 사실 ArrayList&lt;Dog&gt;이므로 Cat을 넣을 수 없음</span></span><br><span class="line">Dog s = dogs.get(<span class="number">0</span>); <span class="comment">// 읽기: dogs는 ArrayList&lt;Dog&gt;이지만 Cat을 반환하게 됨</span></span><br></pre></td></tr></table></figure><h2 id="공변성-Covariance-과-반공변성-Contravariance">공변성(Covariance)과 반공변성(Contravariance)</h2><p>공변성과 반공변성은 <strong>불변의 위험성이 없는 경우, 즉 런타임 타입 안정성이 보장되는 경우</strong> 불변의 제약을 제한적으로 풀어주는 것 입니다.</p><h3 id="공변성과-반공변성이-필요한-이유">공변성과 반공변성이 필요한 이유</h3><p>제네릭 타입이 불변이어야 하는 이유는, 런타임 타입 안정성을 유지하기 위한 것입니다. 공변성과 반공변성은 이러한 제약을 완화하면서도 안전성을 보장할 수 있는 경우에 사용됩니다.</p><p>예제에서 처럼 런타임 타입 안정성이 깨지는 경우도 있지만 안전한 경우도 있습니다. 이런 경우에는 불변성이라는 제약이 필요없습니다. 그렇다면 이런 경우에는 제한적으로라도 불변성 이라는 제약을 풀어줄 수 있지 않을까요?</p><h3 id="공변성-Covariance">공변성(Covariance)</h3><p>공변성에서는 한 타입이 다른 타입의 서브타입이면, 그 제네릭 타입도 서브타입 관계를 유지합니다. 예를 들어, <code>Dog</code>이 <code>Animal</code>의 서브타입인 경우, <code>List&lt;Dog&gt;</code>을 <code>List&lt;Animal&gt;</code>의 서브타입으로 간주할 수 있습니다.</p><h4 id="공변성의-조건">공변성의 조건</h4><blockquote><p>공변성이 성립하기 위해서는 제네릭 타입이 데이터를 쓰지 않고, 오직 읽기만 가능해야합니다. 그리고 데이터를 읽을 때는 제네릭에서 사용하는 타입의 슈퍼타입으로만 데이터를 읽어와야합니다.</p></blockquote><p>데이터를 쓰지 않고 제공(읽기)만 하기 때문에 우리는 이것을 생산자 라고도 부릅니다.</p><h4 id="자바에서-제네릭-타입에-공변성-부여하기">자바에서 제네릭 타입에 공변성 부여하기</h4><p>자바에서는 상한 와일드 카드(Upper bound wild card)를 이용하여 공변성을 부여할 수 있습니다. 아래 코드에서 보면 <code>&lt;? extends E&gt;</code>가 상한 와일드 카드입니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; ... </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; items)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>상한 와일드 카드는 제네릭 타입의 <code>E</code>에 <code>E</code> 또는 <code>E</code> 의 서브타입이 들어올 수 있도록 컴파일러에 알려줍니다. 상한 와일드 카드는 <strong>읽기만 허용하고 쓰기는 허용하지 않습니다.</strong> 쓰기를 허용하지 않는 것은 제약이지만 이 제약 덕분에 앞서 설명한 런타임 타입 안정성이 깨지는 상황을 막을 수 있습니다.</p><p>잘 생각해보면 제네릭에 공변성을 부여하는 것은 불변성의 제약을 제네릭 타입에 쓰기를 허용하지 않는 제약으로 바꾸는 걸로도 볼 수 있습니다.</p><p>앞서 공변성을 줄 수 있는 조건에 대한 설명과도 딱 맞아 떨어집니다.</p><p><code>Collection</code>의 <code>addAll()</code>이 공변성이 없이 아래와 같이 선언이 되었다면 우리는 <code>animals.addAll(dogs)</code> 같은 코드를 사용할 수 없었을 것 입니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; ... </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;E&gt; items)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="코틀린에서-제네릭-타입에-공변성-부여하기">코틀린에서 제네릭 타입에 공변성 부여하기</h4><p>이번에는 코틀린에서의 공변성을 부여하는 방법에 대해 알아보도록 하겠습니다. 아래 Source 인터페이스를 보면 <code>T</code>를 반환하는 메소드만 존재합니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Source</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">nextT</span><span class="params">()</span></span>: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 인터페이스는 <code>T</code> 타입을 반환하는 코드만 있기 때문에 공변성을 부여할 수 있는 조건에 해당합니다. 즉 이 제네릭 인터페이스는 값을 생산(읽기) 하기만 할 뿐 쓰는 동작을 하지 않는 생산자입니다. 하지만 그럼에도 불구하고 아래와 같은 코드는 컴파일 에러를 발생 시키며 허용하지 않습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">(Source&lt;String&gt; strs)</span> </span>&#123;</span><br><span class="line">    Source&lt;Object&gt; objects = strs; <span class="comment">// !!! Not allowed in Java</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이는 앞서 설명한 대로 제네릭이 불변이기 때문입니다. 자바에 <code>Source&lt;T&gt;</code> 가 안전하다는걸 알려주기 위해 앞서 배웠던 상한 와일드 카드를 이용해서 아래와 같이 수정이 가능합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">(Source&lt;? extends Object&gt; strs)</span> </span>&#123;</span><br><span class="line">    Source&lt;Object&gt; objects = strs;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자바에서처럼 제네릭 타입을 사용할 때마다 사용하는 곳에서 상한 와일드 카드를 사용해서 공변성을 부여하는 것을 <strong>사용 지점 변성(use-site variance)</strong> 이라고 합니다. 하지만 이렇게 매번 반복하는 것은 번거롭습니다.</p><p>코틀린에서는 <strong>선언 지점 변성(Declaration-site variance)</strong> 을 이용하여 이를 좀 더 편리하게 사용할 수 있습니다. 선언 지점 변성은 제네릭 타입이 이미 공변성이나 반공변성을 만족한다면 제네릭 타입의 선언 시점에 이를 함께 선언해줄 수 있습니다. (참고로 코틀린에서는 사용 지점 변성과 선언 지점 변성을 둘 다 지원합니다.)</p><p>즉 코틀린에서는 매번 공변성을 사용할때마다 상한 와일드 카드를 사용하는 것이 아니라 <code>Source</code> 인터페이스를 선언하면서 <code>T</code> 앞에 <code>out</code> 이라는 키워드를 추가하는 방식으로 한번에 공변성 부여가 가능합니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Source</span>&lt;<span class="type">out T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">nextT</span><span class="params">()</span></span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">demo</span><span class="params">(strs: <span class="type">Source</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> objects: Source&lt;Any&gt; = strs <span class="comment">// This is OK, since T is an out-parameter</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다만 <code>out</code> 키워드를 이용해 선언 지점 변성을 사용하기 위해서는 제네릭 타입이 공변성의 조건에 부합해야합니다. 그러기 위해서는 해당 제네릭 타입은 쓰기 동작이 없고, 읽기 동작만 있어야합니다. 읽기 동작은 데이터를 생산 하는 것을 의미 합니다. 따라서 <code>T</code>는 이제 <strong>out-position</strong> 에서만 사용이 가능합니다. 이는 <code>T</code>가 제네릭 클래스 내 함수의 리턴 타입 위치, 또는 퍼블릭 속성으로만 사용이 가능하다는 의미입니다.</p><p>이렇게 <code>T</code>가 제네릭 클래스 안에서 <strong>out-position</strong> 에서만 사용이 되는 경우 이 제네릭 클래스는 <code>T</code>의 생산자라고 합니다. 이런 경우 해당 클래스 또는 인터페이스는 <code>T</code>를 소비하지 않고 생산만 하기 때문에 <code>out</code> 키워드를 통해 제네릭 타입의 선언 시점에 공변성 부여가 가능합니다.</p><p>공변성을 말할 때는 아래의 네 가지를 떠올리면 이해가 빠릅니다.</p><ol><li>Upper Bounded Wildcards (<code>&lt;? extends Type&gt;</code>)</li><li>out</li><li>producer</li><li>read</li></ol><h3 id="반공변성-Contravariance">반공변성(Contravariance)</h3><p>반공변성에서는 한 타입이 다른 타입의 서브타입이면, 그 제네릭 타입은 슈퍼타입 관계를 유지합니다. 예를 들어, <code>Dog</code>이 <code>Animal</code>의 서브타입인 경우, <code>List&lt;Animal&gt;</code>은 <code>List&lt;Dog&gt;</code>의 슈퍼타입으로 간주할 수 있습니다.</p><h4 id="반공변성의-조건">반공변성의 조건</h4><blockquote><p>반공변성은 데이터를 소비(쓰기)만 하는 경우 안전하게 사용이 가능합니다. 읽기도 가능은 하지만 이 경우 안전하게 사용하기 위해서는 자바에서는 <code>Object</code>, 코틀린에서는 <code>Any</code>와 같이 가장 범용적인 타입으로 가져와야 안전하게 사용이 가능합니다.</p></blockquote><p>데이터를 쓰는데 사용되기 때문에 이를 소비자 라고 부릅니다.</p><h4 id="자바에서-제네릭-타입에-반공변성-부여하기">자바에서 제네릭 타입에 반공변성 부여하기</h4><p>자바에서는 하한 와일드 카드(Lower bound wild card)를 이용하여 반공변성을 부여할 수 있습니다. 아래 코드에서 보면 <code>&lt;? super E&gt;</code>가 하한 와일드 카드입니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span></span></span><br></pre></td></tr></table></figure><p><code>sort</code> 메서드는 <code>List&lt;T&gt;</code>의 원소들을 정렬하는 데 사용되며, <code>Comparator&lt;? super T&gt;</code> 타입의 <code>Comparator</code>를 인자로 받습니다. <code>Comparator</code>는 리스트의 원소 타입 <code>T</code> 또는 <code>T</code>의 슈퍼타입 객체들을 비교할 수 있습니다.</p><p><code>Comparator&lt;? super T&gt;</code>는 <code>T</code> 타입 또는 <code>T</code>의 어떤 슈퍼타입을 사용하여 두 객체를 비교할 수 있습니다. 이는 Comparator가 반공변적임을 의미하는데, T의 슈퍼타입에 대해 비교 기능을 제공할 수 있기 때문입니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalAgeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Animal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Animal a1, Animal a2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(a1.age, a2.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Dog&gt; dogs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    dogs.add(<span class="keyword">new</span> Dog(<span class="number">5</span>));</span><br><span class="line">    dogs.add(<span class="keyword">new</span> Dog(<span class="number">2</span>));</span><br><span class="line">    dogs.add(<span class="keyword">new</span> Dog(<span class="number">9</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AnimalAgeComparator는 Comparator&lt;Animal&gt;이지만, 여기서는 Dog 리스트를 정렬하는 데 사용됩니다.</span></span><br><span class="line">    Collections.sort(dogs, <span class="keyword">new</span> AnimalAgeComparator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 예제에서 <code>AnimalAgeComparator</code>는 <code>Animal</code> 객체들을 나이에 따라 비교합니다. <code>Collections.sort()</code> 메서드는 이 비교자를 사용하여 <code>Dog</code> 객체의 리스트를 정렬할 수 있습니다. 이는 <code>Comparator&lt;Animal&gt;</code>이 <code>Dog</code>의 슈퍼타입인 <code>Animal</code>을 처리할 수 있기 때문입니다. 이 예제에서 <code>Comparator&lt;? super T&gt;</code>의 반공변성을 통해 <code>Dog</code> 리스트를 정렬하는 데 <code>Animal</code>을 대상으로 하는 <code>Comparator</code>를 사용할 수 있습니다.</p><h4 id="코틀린에서-제네릭-타입에-반공변성-부여하기">코틀린에서 제네릭 타입에 반공변성 부여하기</h4><p>아래 예제는 코틀린의 <code>Comparable</code> 제네릭 인터페이스 입니다. <code>Comparable</code> 은 <code>operator fun compareTo(other: T): Int</code> 메소드만 가지고 있습니다. 이 메소드는 <code>T</code> 타입을 파라미터로 받아서 소비하기만 합니다. 따라서 <code>in</code> 키워드를 통해 <code>Comparable</code>에 반공변성을 부여할 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="type">in T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">T</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">demo</span><span class="params">(x: <span class="type">Comparable</span>&lt;<span class="type">Animal</span>&gt;)</span></span> &#123;</span><br><span class="line">    x.compareTo(Dog())</span><br><span class="line">    <span class="keyword">val</span> y: Comparable&lt;Dog&gt; = x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코드를 보면 <code>x: Comparable&lt;Animal&gt;</code> 를 가지고 <code>Animal</code>의 서브타입인 <code>Dog</code>와 값 비교를 하고, <code>val y: Comparable&lt;Dog&gt; = x</code> 역시 가능함을 볼 수 있습니다.</p><p>반공변성을 말할 때는 아래의 네 가지를 떠올리면 이해가 빠릅니다.</p><ol><li>Lower Bounded Wildcards (<code>&lt;? super Type&gt;</code>)</li><li>in</li><li>consumer</li><li>write</li></ol><h2 id="마치며">마치며</h2><p>변성에 대한 이해가 부족하여 공부를 할겸 작성한 글입니다. 변성이란 개념은 처음에는 다소 이해하기가 어렵지만 잘 이해해둔다면 다른 코드를 읽거나, 제네릭을 이용한 객체지향 설계 능력을 향상 시키는데 큰 도움이 될거라 생각합니다.</p><p>개인적으로는 이 개념을 이해하는게 참 힘들었는데 이 글이 다른 분들에게도 아주 조금이나마 도움이 되었으면 좋겠습니다.</p><h2 id="참고">참고</h2><ul><li><a href="https://kotlinlang.org/docs/generics.html">제네릭(코틀린 공식 문서)</a></li><li><a href="https://youtu.be/6moaoAJui_4?si=iqdBBbm0kPP2kWfB">Variance… without Generics!</a></li></ul>]]></content:encoded>
      
      <comments>https://jeongmin.github.io/2024/04/13/kotlin/variance%20in%20kotlin%20and%20java/#disqus_thread</comments>
    </item>
    
    <item>
      <title>안드로이드에서의 딥링크(Deep links)와 앱링크(App links)</title>
      <link>https://jeongmin.github.io/2023/11/25/android/android-applinks/</link>
      <guid>https://jeongmin.github.io/2023/11/25/android/android-applinks/</guid>
      <pubDate>Fri, 24 Nov 2023 15:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;웹이 지금 처럼 널리 사용되고 강력한 힘을 갖게 된 이유는 &lt;code&gt;링크&lt;/code&gt; 덕분이였다고 해도 과언이 아닐거라고 생각을 합니다. 웹에서 사용되는 HTML(Hypertext Markup Language) 문서는 링크를 통해 서로 연결이 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>웹이 지금 처럼 널리 사용되고 강력한 힘을 갖게 된 이유는 <code>링크</code> 덕분이였다고 해도 과언이 아닐거라고 생각을 합니다. 웹에서 사용되는 HTML(Hypertext Markup Language) 문서는 링크를 통해 서로 연결이 되고 우리는 링크를 타고 정보의 세계를 여행합니다.</p><blockquote><p>안드로이드에서도 앱 내의 컨텐츠에 유저가 쉽게 이동 할 수 있도록 링크를 지원합니다. 우리는 이 링크를 <strong>딥링크</strong>라고 부릅니다.</p></blockquote><h2 id="디지털-세상에서의-링크">디지털 세상에서의 링크</h2><h3 id="URI-Uniform-Resource-Identifier">URI(Uniform Resource Identifier)</h3><p>디지털 세상에서는 웹상의 컨텐츠를 URI라는 포맷으로 표시합니다. 앞에서 설명한 링크 역시 URI 포맷으로 표현됩니다. 그럼 먼저 URI가 어떻게 생겼는지 살펴보도록 하겠습니다.</p><p><code>scheme://username:password@host:port/path?query_string#fragment_id</code></p><ul><li>스킴(scheme): 리소스에 접근하기 위한 프로토콜을 나타냅니다. 예를들어 웹 리소스의 경우 <code>http(Hypertext Transfer Protocol)</code>, 또는 <code>https(HTTP Secure)</code>를 사용합니다.</li><li>유저명 &amp; 비밀번호(Username and Password): 선택 필드로, 인증이 필요한 경우 사용할 수 있습니다. 보안에 취약하기 때문에 사용이 권장되지는 않습니다.</li><li>호스트(Host): 리소스가 존재하는 서버의 도메인 또는 IP 주소 입니다. 도메인은 IP 주소를 사람이 읽기 쉬운 형태로 사용할 수 있도록 해줍니다. <code>www.example.com</code>과 같은 형태의 도메인이 있다면 <code>www</code>는 서브도메인, <code>example.com</code>을 도메인이라고 부릅니다.</li><li>포트(Port): 선택 필드로, 서버 내에서 어떤 컴포넌트가 요청을 처리할지를 표현합니다. 정의가 되어있지 않은 경우 브라우저는 스킴에 주어진 기본 포트를 사용합니다. 예를 들어 <code>http</code>의 경우 <code>80</code>, <code>https</code>의 경우 <code>443</code>이 기본 포트입니다.</li><li>패스(Path): 서버에서의 구체적인 위치를 표현합니다. ex&gt; <code>/path/to/myfile.html</code></li><li>쿼리 스트링(Query String): 서버에 데이터를 전달하기 위해 사용합니다. <code>?</code>로 시작하며 키-값의 쌍을 표현합니다. 여러개의 쿼리 스트링은 <code>&amp;</code>로 구분합니다. ex&gt; <code>?key1=value1&amp;key2=value2</code></li><li>프래그먼트 아이디(Fragment ID): 리소스의 특정 파트를 나타내기 위해 사용되며 <code>#</code>으로 시작합니다. 보통 웹페이지의 특정 섹션으로 바로 이동하기 위해 사용됩니다.</li></ul><h3 id="URI의-예">URI의 예</h3><p><code>https://www.example.com:443/path/to/page?query=123#content</code></p><p>위의 URI의 경우 스킴은 <code>https</code> 프로토콜로 <code>443</code> 포트를 사용하며 서버의 위치는 <code>www.example.com</code> 도메인을 통해 접근합니다. <code>/path/to/page</code>는 접근하려는 자원이고, 키가 <code>query</code> 이고 <code>123</code>인 값을 쿼리 스트링으로 서버에 전달합니다. <code>content</code>는 해당 리소스에서 접근하고자 하는 부분입니다.</p><p>좀 더 이해를 돕기 위해서는 아래처럼 말할 수도 있겠네요. (조금 억지스런 예제일 수 있습니다. ^^;)</p><blockquote><p><code>한국어://경기도용인시XX아파트:관리실/관리비?청구월=11월#전기료</code></p><p>프로토콜은 한국어입니다. 즉 한국어로 클라이언트와 서버가 소통합니다. 리소스를 받을 서버의 주소는 경기도 용인시 XX아파트이고 XX아파트의 관리실에서 요청을 처리합니다. 받고자 하는 리소스 즉 경로는 관리비입니다. 11월 관리비만 궁금하기 때문에 청구월 쿼리스트링으로 11월을 포함하여 관리비를 요청합니다. 그리고 관리비 고지서에서 전기료 파트에 바로 접근합니다.</p></blockquote><h2 id="안드로이드에서-사용할-수-있는-링크의-종류">안드로이드에서 사용할 수 있는 링크의 종류</h2><p>안드로이드는 웹과 유사하게 링크를 통해 유저가 앱에서 제공하는 컨텐츠에 접근할 수 있도록 <code>딥링크(Deep Link)</code>라는 기능을 제공합니다. 접근하려는 컨텐츠가 웹이 아닌 안드로이드 앱 내부에 있지만 안드로이드에서 제공하는 인텐트(Intent)라는 도구를 이용해서 이를 처리 할 수 있습니다.</p><p>아래와 같이 <code>AndroidManifest.xml</code>에 <code>intent-filter</code>를 선언하면 URI를 통해 앱의 컨텐츠를 노출 할 수 있습니다. 눈여겨 봐야할 부분은 <code>data</code> 속성인데요. <code>geo</code>라는 스킴을 정의하고 있습니다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".MyMapActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.VIEW"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.BROWSABLE"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"geo"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>이렇게 하면 이제 <code>geo</code>라는 스킴을 갖는 URI가 안드로이드 단말의 브라우저에서 클릭이 되거나 다른 앱에서 트리거 되면 우리 앱의 <code>MyMapActivity</code> 가 이를 처리 할 수 있게 됩니다.</p><p>위의 인텐트 필터에서 카테고리는 아래와 같은 역할을 합니다.</p><ul><li><code>&lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt;</code><br>웹 브라우저에서의 링크 클릭을 인텐트로 받을 수 있게 합니다.</li><li><code>&lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</code><br>암시적 인텐트를 받을 수 있도록 합니다.</li></ul><p>이제 안드로이드 폰에서 웹브라우저를 통해 <code>geo://</code> 스킴으로 시작하는 링크를 클릭하면 내가 만든 앱의 <code>MyMapActivity</code>가 받아서 처리할 수 있게 되었습니다.</p><h2 id="딥링크의-한계">딥링크의 한계</h2><p>지금까지의 설명만 보면 딥링크 자체는 별 문제가 없어보입니다. 하지만 잘 생각해보면 우리가 받아서 처리하겠다고 <code>AndroidManifest.xml</code>에 선언한 스킴은 우리가 정의한 스킴입니다. 즉 다른 앱에서도 얼마든지 동일한 스킴을 받아서 처리하겠다고 선언할 수 있습니다. 위에서 예를 든 <code>geo</code>라는 스킴을 받아서 처리하는 앱이 스마트폰에 여러 개가 설치되어 있을 수 있습니다. 그런 경우 안드로이드는 아래와 같은 다이얼로그를 띄우게 됩니다.</p><p><img src="https://developer.android.com/static/training/app-links/images/app-disambiguation_2x.png?hl=ko" alt="명확성 대화상자"></p><p><code>geo</code>라는 스킴을 받아서 처리하겠다고 선언되어 있는 앱이 _Maps_와 <em>Chrome</em> 두개가 있으니 둘 중 어디서 이 요청을 처리할지 사용자가 선택하라는 다이얼로그입니다. 하단에 보면 <code>JUST ONCE</code>와 <code>ALWAYS</code> 버튼이 있어서 앞으로 동일한 스킴이 트리거 되었을 때 이번에 선택한 앱이 한번만 실행될지, 항상 실행될지를 결정할 수 있습니다.</p><p>유저 입장에선 선택권이 넓다고 할 수도 있지만 어떤 앱이 이걸 처리해야할지 헷갈릴수도 있고 맞는 앱을 선택 해야하는 것 자체가 어렵습니다. 그리고 앱 개발자 입장에서는 내가 만든 앱의 딥링크가 내 앱이 아닌 엉뚱한 앱에서 실행이 될 수도 있는 문제가 있습니다.</p><h2 id="딥링크-중복-문제-해결">딥링크 중복 문제 해결</h2><p>안드로이드에서는 이러한 문제를 해결하기 위해 <code>앱링크(App Links)</code>라는 해결책을 제공합니다. 이에 대해 알아보기 전에 먼저 <code>웹링크(Web Links)</code>에 대해 알아보도록 하겠습니다.</p><p>웹링크는 스킴이 <code>http</code> 또는 <code>https</code>인 링크를 말합니다. 웹에서 웹브라우저를 통해 인터넷을 할 때 사용되는 프로토콜이 <code>http</code> 또는 <code>https</code> 이기 때문에 이를 웹링크라고 하는 것이죠.</p><p>그럼 안드로이드 앱에서 아까와 같이 처리할 딥링크를 정의할 때 이를 웹링크로, 즉, 스킴에 <code>http</code> 또는 <code>https</code>를 선언하면 어떻게 동작할까요? 이건 안드로이드 OS 버전에 따라 다른데 12 미만에서는 일반 딥링크와 동일하게 처리되고(웹링크를 처리하는 앱으로 연결, 하나 이상이면 다이얼로그로 처리할 앱 선택) 12 이상에서는 단말에 기본으로 설정된 웹브라우저 앱이 뜹니다. 참고로 웹브라우저 앱은 설정 -&gt; 애플리케이션 웹링크를 스킴으로 설정한 앱들 중에 선택이 가능합니다.</p><p>아래는 웹링크의 인텐트 필터 샘플입니다. scheme가 <code>http</code>로 선언된걸 볼 수 있습니다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.VIEW"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.BROWSABLE"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:host</span>=<span class="string">"myownpersonaldomain.com"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="앱링크">앱링크</h2><p>앱링크는 안드로이드 6.0(API Level 23)에서 부터 사용이 가능한 기능입니다. <strong>앱링크는 <code>autoVerify</code>라는 속성을 제공하는데 이 속성은 웹링크를 사용하더라도, 해당 도메인의 소유주가 확인이 되면 웹링크를 사용하는 다른 앱들이 있거나, 기본 브라우저 앱으로 등록이 되어 있지 않더라도 즉시 내가 만든 앱이 링크를 받을 수 있도록 해줍니다.</strong></p><blockquote><p>참고로 iOS에서는 앱링크와 유사한 개념으로 유니버셜 링크(Universal Link)를 제공합니다.</p></blockquote><p>아래는 앱링크를 사용하는 인텐트 필터 샘플입니다. 웹링크와 다른점은 <code>autoVerify</code>속성이 추가되었고 이 값이 <code>true</code>로 세팅되었다는 점입니다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">android:autoVerify</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.VIEW"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.BROWSABLE"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"https"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:host</span>=<span class="string">"myownpersonaldomain.com"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure><p>그럼 이렇게 인텐트 필터만 설정하면 앱링크가 동작할까요? 이것만으로는 부족합니다. 해당 도메인의 소유권이 나에게 있음을 확인할 수 있도록 ‘도메인 소유권 확인’ 처리를 해주어야합니다. 도메인 소유권 확인 절차가 없다면 아무나 동일한 링크를 선언할 수 있으니 딥링크와 다를게 없겠죠.</p><h2 id="도메인-소유권-확인">도메인 소유권 확인</h2><p>도메인 소유권 확인은 디지털 애셋 링크 JSON 파일을 이용합니다. 특정한 포맷으로 구성된 JSON 파일을 아래의 위치에 업로드 하면 되는 방식입니다.</p><p><code>https:///.well-known/assetlinks.json</code></p><p>내가 소유한 도메인에는 나만 파일을 올릴 수 있으니 이를 통해 소유권 확인이 되는 것이죠. 그럼 위에서 언급한 디지털 애셋 링크 JSON(assetlinks.json)은 어떻게 생겼을까요?</p><h3 id="디지털-애셋-링크">디지털 애셋 링크</h3><p>디지털 애셋 링크의 생성은 아래 링크에서 어떻게 만들 수 있는지, 어떤 속성들이 있고 어떤 역할을 하는지에 대해 자세히 설명이 되어 있습니다.</p><p><a href="https://developer.android.com/studio/write/app-link-indexing">https://developer.android.com/studio/write/app-link-indexing</a></p><p>안드로이드 스튜디오의 <strong>Digital Asset Links File Generator</strong>를 이용하면 보다 편리하게 생성이 가능합니다.</p><p><img src="https://developer.android.com/static/studio/images/write/app-links-assistant-dal-file-generator_2x.png" alt="Digital Asset Links File Generator"></p><p>기본적인 형태는 아래와 같습니다.</p><p>앱의 기본 정보와 사이닝 키의 해시 값이 들어갑니다. 업로드한 디지털 애셋 링크 파일에 있는 정보와 앱의 정보가 맞지 않으면 앱링크가 동작하지 않으니 주의깊게 디지털 애셋 링크 파일을 작성하고 테스트를 해야합니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">  <span class="attr">"relation"</span>: [<span class="string">"delegate_permission/common.handle_all_urls"</span>],</span><br><span class="line">  <span class="attr">"target"</span>: &#123;</span><br><span class="line">    <span class="attr">"namespace"</span>: <span class="string">"android_app"</span>,</span><br><span class="line">    <span class="attr">"package_name"</span>: <span class="string">"com.example"</span>,</span><br><span class="line">    <span class="attr">"sha256_cert_fingerprints"</span>:</span><br><span class="line">    [<span class="string">"14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><h2 id="딥링크-vs-웹링크-vs-앱링크">딥링크 vs 웹링크 vs 앱링크</h2><p>지금까지 살펴본 딥링크와 웹링크, 그리고 앱링크의 관계는 아래와 같습니다.</p><p><img src="https://developer.android.com/static/images/training/app-links/link-types-capabilities.svg" alt="링크의 종류"></p><p>딥링크는 앱에서 자유롭게 스킴을 포함한 URI를 정의 할 수 있기 때문에 자유도가 가장 높습니다. 하지만 딥링크가 충돌할 수 있는 위험이 있습니다.</p><p>웹링크는 스킴이 <code>http</code> 이거나 <code>https</code>인 링크를 말합니다. 즉 웹에서 사용되는 링크입니다.</p><p>안드로이드에서도 딥링크를 정의할 때 스킴을 <code>http</code>나 <code>https</code>로 정의함으로써 웹링크의 형태로 정의가 가능합니다. 하지만 이렇게 하면 딥링크가 제대로 동작하지 않습니다. 해당 웹링크가 얼마든지 중복이 될 수 있으니 결국 이것만으로는 딥링크와 다를게 없기 때문입니다.</p><p><strong>이를 해결하기 위해 웹링크에 도메인 소유권 확인 절차를 추가한게 앱링크 입니다.</strong> 앱링크는 사용하고자 하는 도메인에 디지털 애셋 링크 JSON 파일을 업로드 함으로써 해당 도메인이 나의 소유임을 안드로이드 OS에서 알 수 있게 합니다. 그리고 이를 통해 다른 앱에서 동일한 링크를 선언했더라도 내 앱이 해당 링크를 처리할 수 있도록 보장해줍니다.</p><h2 id="앱링크의-장단점">앱링크의 장단점</h2><h3 id="장점">장점</h3><ul><li>도메인 소유권이 확인된 웹링크를 사용하기 때문에 앱 선택 다이얼로그가 뜨지 않아 더 좋은 유저 경험을 제공하고, 다른 앱과 링크가 중복되더라도 내가 만든 앱에서 링크를 받는게 보장됩니다.</li><li>안드로이드 인스턴트 앱 기능의 사용이 가능합니다. 인스턴트 앱은 앱의 설치 없이 앱의 일부 기능을 사용할 수 있도록 하는 기능입니다.</li><li>유저가 모바일 브라우저나, 구글 검색으로 웹링크 클릭으로 바로 앱의 컨텐츠에 접근이 가능하기 때문에 더 많은 유저 유입이 가능해집니다.</li></ul><h3 id="앱링크의-단점">앱링크의 단점</h3><ul><li>도메인 소유권 확인 처리는 디지털 애셋 링크 생성 및 테스트, 파일 업로드의 과정을 걸치기 때문에 불편하고 추가로 시간과 노력이 필요합니다.</li><li>사용하는 도메인의 관리가 중요합니다. 실수로 도메인 연장을 하지 못했다면 해당 앱링크는 사용이 불가능합니다.</li><li>팀으로 작업 하는 경우 개발하는 머신마다 디버그 키가 다르기 때문에 디지털 애셋 링크 파일에 디버그 키의 해시 키 등록이 힘듭니다.</li></ul><h2 id="더-알아볼-것들">더 알아볼 것들</h2><p>딥링크와 웹링크, 그리고 앱링크 까지 알았다면 안드로이드 앱에서의 링크에 대해 어느정도 알게된 것입니다. 하지만 실제 서비스를 개발할 때에는 마케팅이 필요하고 이를 위해 추가로 지연된 <code>딥링크(Deferred Deep Links)</code>와 파이어베이스(Firebase)에서 제공하는 지연된 딥링크 서비스인 <code>다이나믹 링크(Dynamic Links)</code>에 대해 알아두면 많은 도움이 됩니다.</p><h3 id="지연된-딥링크">지연된 딥링크</h3><p>지연된 딥링크는 주로 마케팅에 많이 쓰이는데 마케팅을 통해 제공된 링크를 통해 앱의 설치를 유도하고 이에 대한 성과 측정을 위해 사용됩니다. UTM 코드라는 것과 함께 사용되며 여기에는 앱 설치를 위해 사용된 링크가 어디서 만들어졌는지, 어떤 캠페인에서 사용되었는지, 어떤 매체를 통해 공유되었는지 등의 정보가 들어갑니다. 즉 앱이 설치 되어 있지 않을때 앱의 설치를 유도 할 수 있고 설치 후 지연된 딥링크에 전달된 파라미터를 전달 받을 수 있습니다.</p><h3 id="파이어베이스의-다이나믹-링크">파이어베이스의 다이나믹 링크</h3><p>파이어베이스의 다이나믹 링크는 파이어베이스에서 제공하는 지연된 딥링크 서비스입니다. 하나의 링크로 링크가 실행된 플랫폼에 따라 서로 다른 동작을 할 수 있도록 편리하게 구성할 수 있습니다. 또한 해당 링크를 받아서 처리할 수 있는 앱이 있는지 없는지에 따라 다른 동작을 정의할수도 있습니다.</p><p>예를 들어, 하나의 링크로 안드로이드에서 링크가 클릭되었다면 해당 링크를 실행할 수 있는 앱을 찾고 없다면 앱을 설치할 수 있도록 안드로이드 마켓으로, 있다면 앱으로 링크를 전달할 수 있습니다. 또한 대시보드를 통해 링크의 성과를 바로 볼 수도 있습니다.</p><p>단축 URL 기능도 제공을 하는데 이는 긴 URL을 짧은 URL로 바꿔주는 기능입니다.</p><p>즉 파이어베이스의 다이나믹 링크는 지연된 딥링크에 여러가지 추가 기능을 제공하는 솔루션 이라고 보면 됩니다. 그리고 이 솔루션의 핵심은 사실상 다이나믹 링크의 성과를 볼 수 있는 대시보드 일 것입니다. 즉 마케팅의 성과를 볼 수 있는 기능입니다.</p><p><img src="https://firebase.google.com/static/docs/dynamic-links/images/fdl-analytics.png?hl=ko" alt="Firebase Console"></p><p><img src="https://firebase.google.com/static/docs/dynamic-links/images/analytics.png?hl=ko" alt="Dynamic Links with Analytics"></p><p>결국 지연된 딥링크와 파이어베이스의 다이나믹 링크의 핵심은 마케팅을 위한 추가 기능이라고 보면 됩니다. 당연히 이런 서비스는 파이어베이스에서만 제공하는 것은 아니고, <a href="https://www.appsflyer.com/ko/products/customer-experience-deep-linking/">AppsFlyer</a> 나 <a href="https://www.branch.io/ko/">Branch</a> 같은 다른 마케팅 솔루션 서비스에서도 제공합니다.</p><h2 id="맺음말">맺음말</h2><p>안드로이드 앱 개발을 하다보면 딥링크는 반드시 사용해야 하는 기능입니다. 앱의 초기 세팅이나 기초에 해당하는 부분에 딥링크 처리가 반드시 들어갑니다. 개발자는 웹과의 연동이나, 마케팅을 위해 적절한 링크 기능을 제공해야합니다. 그리고 요구사항에 맞는 선택을 하기 위해서는 각각의 개념과 장단점을 잘 알아야합니다. 이런 개념을 전달하는 것이 이번 글의 목적입니다.</p><p>딥립크가 한계를 가지고 있지만 앱링크를 사용하지 않더라도 스킴을 잘 겹치지 않을만한 걸로 사용한다거나 하면 실제로는 앱링크를 사용하지 않는게 더 좋은 선택일 수도 있습니다. 앱링크는 도메인 소유권 확이이나, 관리, 디버그 모드에서의 불편함 등을 감안하면 공짜가 아닙니다. 물론 이것은 서비스와, 팀의 상황에 따라 달라지며 팀의 상황에 맞게 맞는 선택을 하기 위해서는 각각의 차이가 무엇인지, 어떤 문제점을 해결하기 위해 등장했는지, 장단점이 무엇인지를 잘 알아야합니다.</p><p>마지막으로 서비스를 잘 만드는 것 만큼이나 중요한 것이 마케팅입니다. 모바일 앱의 생태계가 이미 굉장히 성숙해져 있기 때문에 이제는 유저가 스스로 원하는 앱을 찾기보다는 이미 알고 있는 서비스만 사용하는 것이 트렌드입니다. 즉 신규 서비스의 경우 이제는 아무리 잘 만들어도 유저에게 노출 시키기가 굉장히 힘이듭니다.</p><p>따라서 운영중인 앱에 대한 마케팅을 준비하고 있다면 적절한 마케팅 서비스를 선택하고 이를 활용할 수 있도록 지연된 딥링크와 이를 제공하는 서비스에 대해 잘 알고 있는것이 중요합니다.</p><h2 id="참고-자료">참고 자료</h2><ul><li><a href="https://developer.android.com/training/app-links">App Links</a></li><li><a href="https://developer.android.com/studio/write/app-link-indexing">Verify app links</a></li></ul>]]></content:encoded>
      
      <comments>https://jeongmin.github.io/2023/11/25/android/android-applinks/#disqus_thread</comments>
    </item>
    
    <item>
      <title>코틀린에서의 위임(Delegation in Kotlin)</title>
      <link>https://jeongmin.github.io/2023/11/09/kotlin/delegation%20in%20kotlin/</link>
      <guid>https://jeongmin.github.io/2023/11/09/kotlin/delegation%20in%20kotlin/</guid>
      <pubDate>Wed, 08 Nov 2023 15:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;위임-Delegation-의-개념&quot;&gt;위임(Delegation)의 개념&lt;/h2&gt;
&lt;p&gt;위임은 다른 사람에게 나의 일을 맡기는 행위라고 할 수 있습니다.&lt;/p&gt;
&lt;p&gt;제가 까페를 운영한다고 합시다. 까페를 운영하는 일은 매장관리, 재고관리,
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="위임-Delegation-의-개념">위임(Delegation)의 개념</h2><p>위임은 다른 사람에게 나의 일을 맡기는 행위라고 할 수 있습니다.</p><p>제가 까페를 운영한다고 합시다. 까페를 운영하는 일은 매장관리, 재고관리, 홍보, 음료 준비 등 다양한 일을 포함합니다. 이를 혼자 다하는건 아주 힘든 일입니다. 그래서 저는 숙련된 바리스타인 &quot;동동이&quot;를 고용했습니다. 동동이는 손님이 오면 음료 준비와 관련된 모든 업무를 수행합니다. 즉 저는 동동이에게 음료 준비를 <strong>위임</strong> 함으로써 까페 운영을 위한 다른 업무에 집중하고, 좀 더 효율적으로 까페를 운영할 수 있게 되었습니다.</p><h2 id="구성요소">구성요소</h2><p>위의 예제에서 까페 사장인 저는 델리게이터(Delegator), 바리스타로 고용된 동동이는 델리게이트(Delegate)라고 합니다. 델리게이터는 일을 떠넘기는 사람이고, 델리게이트는 일을 대신 받아서 해주는 사람입니다.</p><h2 id="프로그래밍에서의-위임">프로그래밍에서의 위임</h2><p>직관적으로 위임을 잘 사용하면 내가 하려고 하는 일을 좀 더 효율적으로 할 수 있다는 것은 명확합니다. 그럼 프로그래밍의 세계에서는 위임이 구체적으로 어떤 방식으로 우리 일을 효율적으로 할 수 있도록 도와 줄까요?</p><h3 id="위임의-장점">위임의 장점</h3><p>위임의 장점을 코드의 관점에서 바라보면 크게 아래 세 가지로 나눌 수 있습니다.</p><ul><li><p><strong>코드의 재사용성</strong><br>동동이는 바리스타로서 음료 준비의 전문가입니다. 손님으로 부터 주문을 받으면 계속 동동이를 이용해서 음료를 제공할 수 있습니다. 제가 새로운 까페 체인점을 만든다면 다른 체인점에서 동동이를 쓸 수도 있겠죠. 잠시 일을 도우러 온 알바 생이 궁금한게 있으면 동동이에게 도움을 받을 수도 있습니다. 이렇게 바리스타로서 음료의 전문가인 동동이로부터 음료와 완련된 모든 일들에 걸쳐 도움 받을 수 있으니 재사용성이 높습니다.</p></li><li><p><strong>관심사의 분리(SoC - Separation of Concerns)</strong><br>까페의 사장으로서 저는 까페의 운영이라는 작업에 집중하고 음료 준비와 관련된 일들은 전문가인 동동이에게 맡길 수 있습니다. 즉 까페 운영이라는 관심사와 음료 준비라는 관심사가 분리되었습니다.</p></li><li><p><strong>확장성 &amp; 동적 행위 변경</strong><br>음료의 퀄리티나 스타일을 바꾸고 싶으면 동동이를 변경하거나, 동동이를 해고하고 다른 바리스타를 고용하기만 하면 됩니다. 까페의 다른 구성요소의 변경 없이 최소한의 수정으로 런타임에 행위를 변경할 수 있습니다.</p></li></ul><h2 id="기본-사용법-클래스-위임">기본 사용법 - 클래스 위임</h2><p>클래스 위임을 이용하면 인터페이스의 구현을 다른 델리게이트에게 넘길 수 있습니다. 즉 인터페이스의 기능(함수)와 데이터(속성)를 직접 구현할 필요 없이 다른 객체를 이용해서 처리할 수 있습니다.</p><h3 id="인터페이스의-구현을-특정-델리게이트로-위임하기">인터페이스의 구현을 특정 델리게이트로 위임하기</h3><p>아래의 예제를 보면 <code>Barista</code>를 구현하는 클래스를 생성하면서 <code>by</code> 키워드를 이용하여 <code>Barista</code>의 구현을 특정 델리게이트로 넘길 수 있습니다.</p><p>여기서는 <code>Barista</code>를 구현하는 <code>StarbucksBarista</code> 또는 <code>EdiyaBarista</code> 둘 중 하나가 되겠네요.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Barista</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">makeCoffee</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delegate</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StarbucksBarista</span> : <span class="type">Barista &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">makeCoffee</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"Make Starbucks-style coffee"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Delegate</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EdiyaBarista</span> : <span class="type">Barista &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">makeCoffee</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"Make Ediya-style coffee"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delegator: Cafe, Delegate: StarbucksBarista</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StarbucksCafe</span></span>(): Barista <span class="keyword">by</span> StarbucksBarista</span><br><span class="line"><span class="comment">// Delegator: Cafe, Delegate: EdiyaBarista</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EdiyaCafe</span></span>(): Barista <span class="keyword">by</span> EdiyaBarista</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> starbucks = StarbucksCafe()</span><br><span class="line">    starbucks.makeCoffee()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> ediya = EdiyaCafe()</span><br><span class="line">    ediya.makeCoffee()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="인터페이스의-구현을-생성자를-이용하여-특정-델리게이트로-위임-하기">인터페이스의 구현을 생성자를 이용하여 특정 델리게이트로 위임 하기</h3><p>좀 더 유연하게 쓰고 싶다면 아래 처럼 쓸 수 있습니다. 생성자를 통해 <code>Barista</code> 인터페이스를 구현하는 구현체를 넘기는 방식입니다. <code>Cafe</code> 클래스에 <code>Barista</code>만 바꿔서 생성하면 되니 좀 더 유연하다고 할 수 있겠네요. 이 방법은 처음 방식보다 조금 더 유연하지만 여전히 객체의 생성 시 바리스타가 고정되며, 이후 바리스타를 바꾸는 것은 불가능합니다. 까페를 개업할 때 바리스타를 고용해서 평생 함께 가는거네요. 바리스타 입장에선 고용 안정이 되어서 좋지만 사장 입장에선 자유롭게 바리스타를 바꿀 수 있었으면 좋겠습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Barista</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">makeCoffee</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delegate</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StarbucksBarista</span> : <span class="type">Barista &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">makeCoffee</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"Make Starbucks-style coffee"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Delegate</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EdiyaBarista</span> : <span class="type">Barista &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">makeCoffee</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"Make Ediya-style coffee"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delegator: Cafe, Delegate: barista</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cafe</span></span>(barista: Barista): Barista <span class="keyword">by</span> barista</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage of Cafe</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> main &#123;</span></span><br><span class="line">    <span class="keyword">val</span> starbucks = Cafe(StarbucksBarista())</span><br><span class="line">    starbucks.makeCoffee()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> ediya = Cafe(EdiyaBarista())</span><br><span class="line">    ediya.makeCoffee()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="동적으로-델리게이트-변경하기">동적으로 델리게이트 변경하기</h3><p>동적으로 런타임에 새로운 객체 생성 없이 바리스타를 바꾸고 싶다면 이렇게 하면 됩니다. 델리게이터인 <code>Cafe</code> 객체를 생성할 때 델리게이트를 넣어줄 수도 있지만 <code>changeBarista</code>를 이용하여 객체의 재 생성 없이 델리게이트를 변경 할 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Barista</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">makeCoffee</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delegate</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StarbucksBarista</span> : <span class="type">Barista &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">makeCoffee</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"Make Starbucks-style coffee"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Delegate</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EdiyaBarista</span> : <span class="type">Barista &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">makeCoffee</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">"Make Ediya-style coffee"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delegator: Cafe, Delegate: changable in runtime</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cafe</span></span>(b: Barista): Barista <span class="keyword">by</span> b &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> barista: Barista = b</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">makeCoffee</span><span class="params">()</span></span> &#123;</span><br><span class="line">barista.makeCoffee()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">changeBarista</span><span class="params">(newBarista: <span class="type">Barista</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">this</span>.barista = newBarista</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage of Cafe</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> main &#123;</span></span><br><span class="line">    <span class="keyword">val</span> cafe = Cafe(StarbucksBarista())</span><br><span class="line">    cafe.makeCoffee()</span><br><span class="line"></span><br><span class="line">    cafe.changeBarista(EdiyaBarista())</span><br><span class="line">    cafe.makeCoffee()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="기본-사용법-2-프로퍼티-위임">기본 사용법 - 2. 프로퍼티 위임</h2><p>말 그대로 속성의 접근을 다른 객체에 위임하는 방법입니다. 즉 속성의 값을 <strong>읽거나 쓰는 두 가지 동작</strong>을 다른 객체에 위임 할 수 있다는 말이 됩니다.</p><p>코틀린에서는 몇 가지 프로퍼티 위임을 처리하는 델리게이트를 제공합니다.</p><h3 id="코틀린에서-제공하는-내장-Delegate의-종류">코틀린에서 제공하는 내장 Delegate의 종류</h3><h4 id="Lazy-Properties">Lazy Properties</h4><p>속성의 <strong>지연 초기화</strong>를 지원합니다. 아래의 예에서 <code>lazyValue</code>는 최초 접근 시 <code>lazy</code> 함수에 전달되는 객체의 초기화 로직을 수행하는 람다 함수를 호출함으로써 객체를 초기화 합니다. 이 로직은 최초 접근 시 한번만 호출되며 이후에는 초기화 된 값으로 데이터 읽기가 수행됩니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> lazyValue: String <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    println(<span class="string">"Computed!"</span>)</span><br><span class="line">    <span class="string">"Hello"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Observable">Observable</h4><p><code>Delegates.observable</code>는 첫번째 파라미터로 초기값을, 두번째 파라미터로는 람다 함수를 인자로 받습니다. 람다 함수는 <code>old</code>, <code>new</code>로 이전 값과, 새로 바뀐 값을 전달해줍니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name: String <span class="keyword">by</span> Delegates.observable(<span class="string">"&lt;no name&gt;"</span>) &#123; prop, old, new -&gt;</span><br><span class="line">    println(<span class="string">"<span class="variable">$old</span> -&gt; <span class="variable">$new</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">name = <span class="string">"first"</span></span><br><span class="line">name = <span class="string">"second"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// result</span></span><br><span class="line"><span class="comment">// &lt;no name&gt; -&gt; first</span></span><br><span class="line"><span class="comment">// first -&gt; second</span></span><br></pre></td></tr></table></figure><h4 id="Vetoable">Vetoable</h4><p><code>Delegates.vetoable</code>은 <code>Delegates.observable</code>과 다르게 값이 변경되기 전에 콜백이 호출됩니다. 두번째 파라미터에서 <code>Delegates.observable</code>과 다른 점은 <code>Boolean</code>을 반환하는 람다를 파라미터로 받는 다는 점인데 이 값이 <code>true</code>인 경우에만 값이 변경됩니다.</p><p>아래의 예제에서는 새 값이 기존 값보다 클때만 max의 값이 변경됩니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> max: <span class="built_in">Int</span> <span class="keyword">by</span> Delegates.vetoable(<span class="number">0</span>) &#123; prop, old, new -&gt;</span><br><span class="line">    new &gt; old</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(max) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">max = <span class="number">10</span></span><br><span class="line">println(max) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">max = <span class="number">5</span></span><br><span class="line">println(max) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>아래와 같이 사용하면 아예 예외를 던지도록 하는 것도 가능합니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> max: <span class="built_in">Int</span> <span class="keyword">by</span> Delegates.vetoable(<span class="number">0</span>) &#123; property, oldValue, newValue -&gt;</span><br><span class="line">    <span class="keyword">if</span> (newValue &gt; oldValue) <span class="literal">true</span> <span class="keyword">else</span> <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"New value must be larger than old value."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(max) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">max = <span class="number">10</span></span><br><span class="line">println(max) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// max = 5 // will fail with IllegalArgumentException</span></span><br></pre></td></tr></table></figure><h4 id="Map-Delegation">Map Delegation</h4><p>위임을 이용하면 <code>map</code>에 있는 값을 속성으로 사용할 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> properties = mapOf(</span><br><span class="line">    <span class="string">"name"</span> to <span class="string">"jude"</span>,</span><br><span class="line">    <span class="string">"age"</span> to <span class="number">10</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> map: Map&lt;String, Any?&gt;) &#123;</span><br><span class="line">    <span class="keyword">val</span> name: String <span class="keyword">by</span> map</span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span> <span class="keyword">by</span> map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> user = User(properties)</span><br><span class="line">println(user) <span class="comment">// User(map=&#123;name=jude, age=10&#125;)</span></span><br><span class="line">println(user.name) <span class="comment">// jude</span></span><br><span class="line">println(user.age)  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>아래와 같이 <code>mutableMap</code>을 이용하면 속성의 값을 수정 가능하도록 만들 수도 있습니다. 이를 이용하면 <code>JSON</code>을 파싱하는 작업을 아주 편하게 할 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MutableUser</span></span>(<span class="keyword">val</span> map: MutableMap&lt;String, Any?&gt;) &#123;</span><br><span class="line">    <span class="keyword">var</span> name: String <span class="keyword">by</span> map</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span>     <span class="keyword">by</span> map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NotNull">NotNull</h4><p><code>var</code>로 선언된 속성에 값이 설정되기 전에 접근하면 <code>IllegalStateException</code>을 발생 시킵니다. 이를 이용하면 런타임에 예외를 적절히 다뤄줘야하긴 하지만 선언과 값의 설정을 분리 할 수 있습니다. 참고로 코틀린에서는 <code>notNull</code>을 쓰지 않고 <code>var</code>로 변수를 선언하면서 값을 초기화 해주지 않으면 컴파일이 되지 않습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> notNullVar: String <span class="keyword">by</span> Delegates.notNull()</span><br></pre></td></tr></table></figure><h2 id="프로퍼티-위임의-커스텀">프로퍼티 위임의 커스텀</h2><p>코틀린에서는 속성에 대한 위임을 지원합니다. 즉 클래스, 함수, 코드 블럭 안에서 사용하는 변수에 대한 접근을 델리게이트에 위임할 수 있습니다.</p><p>속성에 대한 접근이라고 하면 데이터를 가져오는 동작과, 데이터를 쓰는 동작이 있습니다. 따라서 속성에 대한 델리게이트는 결국 이 두 가지 동작을 커스텀 델리게이트에 구현하는 것 입니다.</p><p>먼저 사용법을 바로 보도록 하겠습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p: String <span class="keyword">by</span> Delegate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 샘플 코드는 아래와 같이 문법적으로 나눠서 볼 수 있습니다. 일반적인 변수 선언 방법에서 뒤에 <code>by &lt;expression&gt;</code> 이 추가된 형태로, by 뒤에 있는 델리게이트에 속성에 대한 읽기, 쓰기를 위임한다는 의미입니다.</p><p><code>val/var &lt;property name&gt;: &lt;Type&gt; by &lt;expression&gt;</code></p><p>코틀린에서의 속성에 대한 델리게이트는 아래와 같은 형태로 구현할 수 있습니다. 아까 언급한 것처럼 읽기와 쓰기를 대신 처리해주기 위해 <code>getValue</code>와 <code>setValue</code>를 구현하고 있는걸 볼 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.reflect.KProperty</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Delegate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"<span class="variable">$thisRef</span>, thank you for delegating '<span class="subst">$&#123;property.name&#125;</span>' to me!"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">"<span class="variable">$value</span> has been assigned to '<span class="subst">$&#123;property.name&#125;</span>' in <span class="variable">$thisRef</span>."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>만약 델리게이트가 읽기 전용으로 <code>val</code>로만 쓰인다면 <code>getValue</code>만 추가하면 됩니다. 수정이 가능한 <code>var</code>로 사용하신다면 델리게이트에 <code>setValue</code>도 추가로 구현이 필요합니다.</p><h3 id="ReadOnlyProperty와-ReadWriteProperty-인터페이스">ReadOnlyProperty와 ReadWriteProperty 인터페이스</h3><p>코틀린 표준 라이브러리에서는 델리게이트를 만들기 위해 구현해야하는 <code>getValue</code>와 <code>setValue</code>를 정의하는 인터페이스를 제공합니다. 이름을 보면 알 수 있듯이 <code>ReadOnlyProperty</code>에서는 <code>getValue</code>만을 정의하고, <code>ReadWriteProperty</code>에서는 getValue와 setValue 둘 다 정의하고 있습니다.</p><p>이를 구현하지 않아도 앞서 설명한 <code>getValue</code>와 <code>setValue</code>를 구현해주면 델리게이트로 동작하지만 <code>ReadOnlyProperty</code>나 <code>ReadWriteProperty</code>를 이용하면 클래스 선언 없이 익명 클래스로 바로 델리게이트를 만들 수도 있습니다. 또한 구현하고 있는 인터페이스를 보면 바로 델리게이트로서 동작이 가능하다는 것을 알 수 있기 때문에 가독성도 올라갑니다. 복잡한 <code>getValue</code>와 <code>setValue</code>의 시그니처를 외울 필요없이 IDE의 도움을 받아 편하게 정의 할 수 있는 점도 장점이겠죠?</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">resourceDelegate</span><span class="params">(resource: <span class="type">Resource</span> = Resource()</span></span>): ReadWriteProperty&lt;Any?, Resource&gt; =</span><br><span class="line">    <span class="keyword">object</span> : ReadWriteProperty&lt;Any?, Resource&gt; &#123;</span><br><span class="line">        <span class="keyword">var</span> curValue = resource</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: Resource = curValue</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">Resource</span>)</span></span> &#123;</span><br><span class="line">            curValue = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> readOnlyResource: Resource <span class="keyword">by</span> resourceDelegate()  <span class="comment">// ReadWriteProperty as val</span></span><br><span class="line"><span class="keyword">var</span> readWriteResource: Resource <span class="keyword">by</span> resourceDelegate()</span><br></pre></td></tr></table></figure><h2 id="실제-코드로-보는-위임의-사용-예-mutableStateOf">실제 코드로 보는 위임의 사용 예(mutableStateOf)</h2><p>안드로이드에서 <code>Jetpack Compose</code>로 UI를 개발하고 있다면 <code>State</code>의 개념은 아주 친숙할 것입니다.</p><p><code>Compose</code>는 데이터를 UI로 그대로 노출하는 선언형 UI 프레임워크 입니다. <code>Compose</code>에서는 UI에 노출할 데이터를 관리하는 특별한 인터페이스를 하나 제공하는데요. 바로 <code>State</code>라는 인터페이스입니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Stable</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">State</span>&lt;<span class="type">out T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> value: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>State</code>안에는 <code>val value: T</code> 형태로 <code>value</code> 속성을 가지고 있습니다. <code>State</code>의 특별함은 <code>Composable function</code>에서 <code>State</code>의 상태 변화를 구독해서 <code>State</code>가 변경되면 자동으로 <code>재구성(Recomposition)</code> 트리거 된다는 점입니다.</p><p>이런 <code>State</code>는 어떤 식으로 사용될까요? 아래는 안드로이드에서 컴포즈로 UI를 개발하고 있다면 아주 친숙한 코드일거라 생각합니다.<br>(<code>Composable</code> 함수가 아닌 <code>ViewModel</code>에서는 <code>mutableStateOf</code>가 아닌 <code>mutableStateFlow</code>의 사용이 권장 되지만 이해를 돕기위한 예제로 이렇게 구성했으니 참고해주세요)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span>: <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> showDialog: MutableState&lt;<span class="built_in">Boolean</span>&gt; = mutableStateOf(<span class="literal">false</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MyScreen</span><span class="params">(viewModel: <span class="type">MyViewModel</span>)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (viewModel.showDialog.value) &#123;</span><br><span class="line">        MyDialog(onDismissRequest = &#123;</span><br><span class="line">            viewModel.showDialog.value = <span class="literal">false</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>showDialog</code>의 <code>value</code>에 따라 <code>MyDialog()</code>를 UI에 노출 합니다. <code>showDialog</code>의 값은 <code>MutableState</code>기 때문에 변경이 가능하구요. 하지만 위의 예를 보고 뭔가 이상함을 느끼신 분들도 계실거 같습니다. 사실 우리가 실제로 <code>MutableState</code>를 쓰는 방식은 대부분 아래와 같습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span>: <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> showDialog: MutableState&lt;<span class="built_in">Boolean</span>&gt; <span class="keyword">by</span> mutableStateOf(<span class="literal">false</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MyScreen</span><span class="params">(viewModel: <span class="type">MyViewModel</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (viewModel.showDialog) &#123;</span><br><span class="line">        MyDialog(onDismissRequest = &#123;</span><br><span class="line">            viewModel.showDialog = <span class="literal">false</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>귀찮거나, 지저분한 코드를 병적으로 싫어하는 개발자 답게 <strong>코틀린의 위임</strong>을 이용해서 조건문에서 <code>showDialog.value</code>로 <code>State</code>에 접근하던걸 <code>showDialog</code>로 단순화 했네요. 위임을 사용했기 때문에 <code>showDialog</code>를 선언할 때 <code>=</code>가 <code>by</code>로 바뀐 것을 볼 수 있습니다.</p><p>그럼 <code>MutableState</code> 부터 차근차근 코드를 따라가 보도록 하겠습니다. 당연히 <code>MutableState</code> 역시 <code>State</code>를 구현하고 있는걸 볼 수 있습니다. 한 가지 눈에 띄는 부분은 <code>State</code>의 <code>value</code>를 오버라이드 하면서 <code>val</code> 키워드로 선언되었던 <code>value</code>가 변경 가능한 변수임을 나타내는 <code>var</code>로 바뀐 점입니다. <code>MutableState</code>라는 이름에서 보이듯이 <code>MutableState</code>는 가지고 있는 <code>value</code>가 변경 가능해야하기 때문입니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Stable</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MutableState</span>&lt;<span class="type">T</span>&gt; : <span class="type">State</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> value: T</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component1</span><span class="params">()</span></span>: T</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component2</span><span class="params">()</span></span>: (T) -&gt; <span class="built_in">Unit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MutableState의-델리게이트-구현">MutableState의 델리게이트 구현</h3><p><code>MutableState</code>와 <code>State</code>가 어떻게 생겼는지 보았는데 이것들이 델리게이트로는 어떻게 구현이 되어있는지를 살펴보도록 하겠습니다.</p><p>먼저 <code>MutableState</code>는 값의 변경이 가능해야합니다. 즉 쓰기 가능해야합니다. 따라서 <code>setValue</code>를 구현해주어야겠죠? 코드를 보면 바로 해당 함수를 찾을 수 있습니다. 아주 심플하게 <code>this.value = value</code> 이렇게 구현이 되어있네요.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> MutableState<span class="type">&lt;T&gt;</span>.<span class="title">setValue</span><span class="params">(thisObj: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그럼 <code>getValue</code> 는 어떻게 구현되어 있을까요? 역시나 간단히 <code>State</code> 인터페이스의 <code>value</code>를 반환하는 단순한 코드로 구현이 되어있습니다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inline operator fun &lt;T&gt; State&lt;T&gt;.getValue(thisObj: Any?, property: KProperty&lt;*&gt;): T = value</span><br></pre></td></tr></table></figure><h2 id="위임의-본질">위임의 본질</h2><h3 id="상속-vs-구성-위임">상속 vs 구성(위임)</h3><p>앞에 설명드린 많은 예제들을 보면 사실 위임이 아닌 다양한 방식으로 구현이 가능합니다. 전 프로그래밍이 결국 글쓰기와 동일하다고 생각합니다. 글쓰기에서는 전하는 핵심 메세지가 동일하더라도 이를 표현하는 문장은 수없이 다양할 수 있습니다.</p><p>다만 제목에 적은 세 가지의 개념을 간단히 한번 짚고 넘어간다면 도움이 될거 같습니다. 위의 세 가지 개념은 객체지향 프로그래밍의 토대가 되는 개념 들이며 대다수의 객체지향 프로그래밍 언어에서 이를 이용하여 코드를 작성할 수 있도록 지원합니다.</p><h4 id="상속">상속</h4><p>먼저 상속은 객체의 관계를 부모-자식 관계로, 또는 is - a 관계로 많이 표현합니다. 당연히 구현하려고 하는 객체 사이의 관계를 이렇게 표현하는게 직관적이라면 상속을 사용할 수 있습니다. 상속을 사용하면 객체간의 관계를 수직적으로 표현하여 사람이 직관적으로 이해하기 좋고 부모의 속성과 기능이 자식에게 모두 전해지기 때문에 잘 모델링 하면 공유되는 기능과 속성을 부모에 두고 코드를 재활용 할 수 있는 장점이 있습니다.</p><h4 id="상속보단-구성-Composition-over-Inheritance">상속보단 구성(Composition over Inheritance)</h4><p>객체 지향 디자인 원칙에서 자주 언급되는 개념입니다. 앞서 상속의 장점들을 이야기 했지만 상속의 장점은 곧 단점이 되기도 합니다. 부모의 속성과 기능이 자식에게 전해지는 것은 얼핏 보면 코드의 재사용성을 높여주기도 하지만 크게 보면 캡슐화가 약해지는 단점과, 부모의 변경에 따라 자식이 영향을 받게 되는 강한 결합이 발생하며, 상속 관계가 깊어지면 자식 객체는 지나치게 비대해 져서 필요없는 기능이나 속성이 늘어나고, 어떤 기능과 속성이 있는지를 파악하는 것도 매우 힘들어집니다.</p><h4 id="구성">구성</h4><p>이에 따라 최근에는 상속 보단 구성을 이용해서 코드를 작성하는걸 권장하고 있습니다. 구성은 has-a 관계로 많이 표현하며 해야하는 작업을 여러 객체로 나누고 합쳐서 원하는 기능을 구현하는 방식입니다. 각각의 객체가 할 일을 나눠서 가지고 있기 때문에 캡슐화가 잘 지켜지며 상속과 같은 복잡한 수직 구조를 갖지 않습니다. 물론 이에 따라 훨씬 더 많은 객체가 생겨나고 이들의 관계가 복잡해 지는 부분은 단점이 될 수도 있습니다.</p><h4 id="위임">위임</h4><p>위임은 객체가 필요한 기능을 다른 객체로 전달하는 방식입니다. 결국 위임은 구성의 한 방법입니다. 구성이 좀 더 강력하고 편리하게 쓰일 수 있도록 도와주는 문법적인 장치라고도 볼 수 있습니다.</p><p>실제로 코틀린에서 <code>by</code> 키워드를 통해 위임을 사용하면 코틀린 컴파일러는 <code>by</code>가 지정하는 객체를 직접 생성해서 해당 객체의 레퍼런스를 갖고 이를 호출 하는 방식으로 위임을 처리합니다. 즉 다른 객체를 생성하고 이를 이용해서 특정 기능을 수행하는 구성과 완전 동일합니다. 다만 코틀린에서 문법적으로 매번 해당 객체의 레퍼런스를 호출하는걸 줄여주는 것일 뿐이죠.</p><p>아래 코드는 코틀린 공식 페이지에 있는 설명으로, 위임이 실제 어떤 식으로 구현이 되는지를 보여줍니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prop: Type <span class="keyword">by</span> MyDelegate()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this code is generated by the compiler instead:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> prop$delegate = MyDelegate()</span><br><span class="line">    <span class="keyword">var</span> prop: Type</span><br><span class="line">        <span class="keyword">get</span>() = prop$delegate.getValue(<span class="keyword">this</span>, <span class="keyword">this</span>::prop)</span><br><span class="line">        <span class="keyword">set</span>(value: Type) = prop$delegate.setValue(<span class="keyword">this</span>, <span class="keyword">this</span>::prop, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="위임의-대표적인-사용-예">위임의 대표적인 사용 예</h2><p>위임이 구성의 한 방법이라고 보면 아래의 일들은 당연히 위임으로 처리하기 아주 좋은 사례라고 할 수 있습니다. 위임을 하면 특정 인터페이스나, 속성의 접근을 내가 통제할 수 있습니다. 즉 프록시나, 훅과 같은 역할을 델리게이트에 구현할 수 있는 것이죠. 결국 아래의 사용 사례들은 프록시나 훅으로 처리하기 좋은 것들이기도 합니다.</p><ul><li>로직의 재사용</li><li>데이터 유효성 검사</li><li>의존성 주입</li><li>동적 행위 변경</li><li>자원 관리</li><li>모니터링 &amp; 로깅</li><li>원래의 기능에 새로운 기능 추가</li></ul><p>이번 포스트에서는 위임에 대해 알아보았습니다. 내용이 좀 많긴 하지만 위임을 활용했을 때 가질 수 있는 많은 장점을 생각하면 여기서 다룬 내용들이 독자에게 많은 도움이 될거라 생각합니다.</p><p>또한 위임을 통해 구현된 코틀린, 안드로이드의 많은 기능들을 직접 코드를 따라가면서 분석해본다면 코드를 이해하는데에도 많은 도움이 될 것입니다.</p>]]></content:encoded>
      
      <comments>https://jeongmin.github.io/2023/11/09/kotlin/delegation%20in%20kotlin/#disqus_thread</comments>
    </item>
    
    <item>
      <title>안드로이드(Android) 뷰모델(ViewModel)</title>
      <link>https://jeongmin.github.io/2020/05/04/android/architecture-components/viewmodel/</link>
      <guid>https://jeongmin.github.io/2020/05/04/android/architecture-components/viewmodel/</guid>
      <pubDate>Sun, 03 May 2020 15:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1&gt;들어가며&lt;/h1&gt;
&lt;p&gt;뷰모델은 안드로이드 AAC(Android Architecture Components)중 하나로 라이브 모델과 함께 굉장히 중요한 역할을 차지합니다. AAC는 구글에서 안드로이드 앱을 좀 더 쉽고 견고하게 개발할 수 있도록
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1>들어가며</h1><p>뷰모델은 안드로이드 AAC(Android Architecture Components)중 하나로 라이브 모델과 함께 굉장히 중요한 역할을 차지합니다. AAC는 구글에서 안드로이드 앱을 좀 더 쉽고 견고하게 개발할 수 있도록 개발자 커뮤니티의 피드백을 받아 만들어지고 있는 라이브러리입니다.</p><p>소프트웨어는 마치 사람처럼 성장합니다. 안드로이드가 1.0이 2008년에 발표되었으니 벌써 12년이 되었습니다. 당연히 안드로이드 API도 초기 설계는 부족한 부분이 많이 있었습니다. 이에 따라 어떤 부분은 개발하기도 어렵고 버그가 발생하기 쉬운 구조적인 문제도 아주 많았죠.</p><p>하지만 구글이 대단하고 잘하고 있는건 이런 부족한 부분을 끊임없이 발견하고 피드백을 받아 개선시켜주고 있다는 점입니다. AAC가 등장한 배경도, 그 AAC의 하나인 뷰모델이 등장하게 된 배경도 결국은 이런 맥락입니다.</p><p>자, 그럼 뷰모델이 해결하고자 하는 문제는 무엇이고, 뷰모델은 이 문제를 어떻게 해결해주고 있을까요? 이번 글에서는 이 두 가지 질문에 대해 알아보도록 하겠습니다.<br><code>(결론을 먼저 말하자면 뷰모델은 액티비티의 재생성 시 UI와 관련된 데이터를 유지하기 위해 사용합니다.)</code></p><h1>뷰모델이 해결하고 싶은 문제</h1><p>안드로이드 앱 개발을 한다고 하면, 가장 많이 부딪히는 개념중에 하나가 액티비티의 생명주기입니다. 안드로이드 앱의 거의 모든 UI 요소들은 액티비티에 속하게됩니다. 그리고 이 액티비티는 생명주기를 가집니다.</p><p>여기서 생명주기라 함은 크게 액티비티의 생성(onCreate)부터 소멸(onDestroy)까지를 말하고 좀 더 디테일하게 보면 유저에게 최초로 보여지는 시점(onStart - onStop), 포커스를 갖게되는 시점(onResume - onPause) 등을 포함합니다.</p><p><img src="/assets/img/android-aac-viewmodel/activity_lifecycle.png" alt="액티비티의 생명주기"></p><h2 id="문제-액티비티는-시스템에-의해-재생성-re-created-될-수-있습니다">문제. 액티비티는 시스템에 의해 재생성(re-created)될 수 있습니다.</h2><p>이런 상황은 단말의 몇몇 설정 변경 시 발생합니다. 가장 흔한 예는 단말의 방향 전환(가로모드, 세로모드), 언어 설정 변경을 생각해 볼 수 있습니다. 이런 시스템 설정 변경은 앱 밖에서 발생하기 때문에 이로 인한 발생되는 액티비티의 재생성은 우리가 제어할 수 없습니다.</p><blockquote><p>그리고 이렇게 액티비티가 재생성이 되면 액티비티가 가지고 있던 데이터는 사라집니다.</p></blockquote><p><code>위와 같은 이유로 액티비티가 재생성 되었을 때, 좋은 유저 경험을 주기 위해서는 마치 아무일도 없었던 것 처럼 UI와 관련된 데이터를 어딘가에 저장해 두었다가 이를 이용해서 다시 화면을 그려줘야합니다.</code></p><h2 id="기존의-해결책-onSaveInstanceState-와-onRestoreInstanceState">기존의 해결책. onSaveInstanceState()와 onRestoreInstanceState()</h2><p>액티비티의 onSaveInstanceState() 콜백을 이용하면 이런 예외적인 상황에서 저장해두고 싶은 데이터를 번들(Bundle)에 저장할 수 있습니다. 그리고 이렇게 저장해둔 데이터는 액티비티가 재생성될 때 onCreate(savedInstanceState: Bundle?)나 onRestoreInstanceState() 콜백을 통해 다시 전달받을 수 있습니다.</p><p>하지만 이 방법은 번들을 사용하기 때문에 저장하고자 하는 데이터의 형태도 제한이 되고, 많은 양의 데이터를 저장하기에는 제한이 있습니다. <a href="https://developer.android.com/guide/components/activities/parcelables-and-bundles">번들의 사용에 대해 가이드 하고 있는 공식 문서</a>에서는 50Kb 미만으로 유지하기를 가이드 하고 있습니다.</p><p>또한 이 방법에서 onSaveInstanceState()는 메인 쓰레드에서 동작해야하기 때문에 여기서 데이터를 저장하는데 시간을 많이 사용하게 되면 그만큼 UI에 버벅거림이 생기게 됩니다.</p><h1>뷰모델은 이 문제를 어떻게 해결 할 수 있을까?</h1><p>뷰모델은 아래와 같이 액티비티가 재생성이 되는 시나리오에서는 액티비티의 onDestroy가 호출되더라도 소멸되지 않습니다. 뷰모델은 액티비티내에서 finish()를 직접 호출하거나 사용자가 액티비티를 닫을 때(백키를 누르거나 히스토리에서 제거해서) 소멸됩니다.</p><p>뷰모델이 액티비티의 재생성시에도 살아 남으니 해결책은 아주 간단합니다. 액티비티가 재생성 되었을 때에도 유지하고 싶은 데이터는 뷰모델에 저장하면 됩니다.</p><p><img src="/assets/img/android-aac-viewmodel/viewmodel-lifecycle.png" alt="뷰모델의 생명주기"></p><h2 id="뷰모델-사용-방법">뷰모델 사용 방법</h2><p>간단히 화면에 게임의 점수를 표시해 준다고 생각해봅시다. 이 점수는 유저에 의해 업데이트가 되고, 가로모드를 지원하기 때문에 화면 방향이 전환되어도 유저에 의해 업데이트된 점수는 유지되어야 합니다.</p><p>이런 요구사항이 있을 때 뷰모델에 저장해야하는 값은 <code>점수</code>가 되어야 합니다. 아래와 같이 score를 저장하는 변수를 뷰모델에 선언해줍니다.</p><figure class="highlight kotlin"><figcaption><span>뷰모델 생성</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> scroe: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 만든 뷰모델은 생성자를 통해 만들지 않고 <code>ViewModelProvider</code>라는 팩토리 객체를 이용해서 만들어줘야합니다. 일단 뷰모델의 인스턴스를 얻었다면 그 이후 사용법은 간단합니다. 일반적인 클래스 객체를 사용하듯이 데이터를 읽고 쓰면 됩니다.</p><figure class="highlight kotlin"><figcaption><span>뷰모델의 사용</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">   <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">   setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Get ViewModel instance</span></span><br><span class="line">   mViewModel = ViewModelProviders.of(<span class="keyword">this</span>).<span class="keyword">get</span>(MyViewModel<span class="class">.<span class="keyword">class</span>);</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Update ui</span></span><br><span class="line">   updateUi(mViewModel.scoreTeamA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">updateScore</span><span class="params">(score: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Read and write data from the ViewModel</span></span><br><span class="line">   mViewModel.score = mViewModel.score + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Update UI</span></span><br><span class="line">   textViewScore.text = mViewModel.score.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>참고로 안드로이드 개발자 페이지에서는 뷰모델과 라이브데이터(LiveData)를 함께 사용하는 예제를 보여주고 있습니다. 그 이유는 뷰모델과 라이브데이터를 함께 사용할 때 그 효용성이 극대화 되기 때문입니다.</p><p>지금은 이해를 돕기위해 라이브데이터에 대한 이야기는 하지 않겠습니다. 하지만 나중에 반드시 라이브데이터에 대해서도 공부해 보기를 권해드립니다.</p><h1>뷰모델에 대해 조금 더 알아보자</h1><p>앞에서 뷰모델이 어떤 문제를, 어떻게 해결 할 수 있는지 알아보았습니다. 이를 바탕으로 뷰모델을 언제, 어떻게 써야할지 조금 더 구체적으로 알아보도록 하겠습니다.</p><h2 id="뷰모델에는-어떤-데이터를-저장해야-할까">뷰모델에는 어떤 데이터를 저장해야 할까?</h2><p>액티비티는 굉장히 다양한 데이터를 가지고 있을 수 있습니다. 그중에 뷰모델에 저장해야할 데이터는 어떤 데이터일까요? <code>정답은 UI와 연관된 데이터입니다.</code> 앞서 뷰모델이 어떤 문제를 해결하고자 하는지를 이해했다면 당연한 이야기겠죠?</p><h2 id="뷰모델을-사용할-때-주의점">뷰모델을 사용할 때 주의점</h2><blockquote><p>뷰모델에는 반드시 액티비티나 프래그먼트(Fragment), 컨텍스트(Context)에 대한 참조를 저장하면 안됩니다. 뷰(Views)도 컨텍스트를 가지기 때문에 뷰에 대한 참조 역시 저장하면 안됩니다.</p></blockquote><p>이에 대한 이유는 뷰모델의 생명주기를 생각해보면 알 수 있습니다. 뷰모델이 액티비티에 대한 참조를 갖고 있다고 생각해봅시다. 이 때 단말의 방향이 변경되어 액티비티가 재생성이 되면 어떻게 될까요?</p><p>현재 액티비티는 종료되고 새로운 액티비티가 생성되지만 뷰모델은 액티비티가 재생성 되어도 살아있기 때문에 종료된 액티비티의 참조를 갖고 있게됩니다. 결국 해당 액티비티는 뷰모델이 종료될 때까지 계속 메모리에 남게 됩니다. 즉 메모리 릭(Memory leak)이 발생합니다.</p><p>다만 여기에 한 가지 예외가 있는데, 어플리케이션의 컨텍스트는 뷰모델에서 가져도 됩니다. 어플리케이션은 액티비티가 아닌 어플리케이션의 생명주기를 따르기 때문입니다. 더해서, 뷰모델에서 시스템 서비스를 사용하기 위해 어플리케이션 컨텍스트가 필요한 경우 AndroidViewModel을 이용하면 됩니다. AndroidViewModel은 이런 경우를 위해 제공되는 뷰모델로 Application에 대한 참조를 가집니다.</p><blockquote><p>뷰모델은 액티비티가 재생성될 때 UI와 관련된 데이터를 저장하기 위해 사용합니다.</p></blockquote><p>또한 뷰모델은 액티비티의 재생성 시 UI 데이터를 저장하는 데 사용합니다. 데이터가 영구히 저장되어야 한다면 프리퍼런스(Preference)나 데이터베이스에 저장해야합니다.</p><h2 id="뷰모델을-사용할-때-얻을-수-있는-추가적인-장점">뷰모델을 사용할 때 얻을 수 있는 추가적인 장점</h2><p>뷰모델을 사용하면 UI와 관련된 데이터를 액티비티나 프래그먼트로부터 분리할 수 있습니다. 일반적으로 UI 개발 시 데이터와, 뷰, 로직을 분리하는 것이 코드의 복잡도를 줄이고 개발을 편하게 해준다는 것은 UI 개발에서 MVC, MVP, MVVM과 같이 다양한 패턴이 존재하는 것을 보아도 알 수 있습니다. 또한 이렇게 데이터와 UI를 분리하면 코드를 테스트 하기도 좋아집니다.</p><p>그리고 뷰모델을 올바르게 사용한다면 코드에 대한 가독성도 높아 질 수 있습니다. 예를 들어 어떤 액티비티의 코드를 분석하는데 여기서 뷰모델을 쓰고 있다면 바로 <code>이 액티비티의 UI 관련 데이터는 이 뷰모델 코드를 보면 되겠구나</code>하고 알 수 있습니다.</p><h1>마무리</h1><p>이번 글에서는 뷰모델의 개념에 대해 알아보았습니다. 뷰모델이 왜 만들어졌고 어떻게 사용하면 되는지만 알고 바로 뷰모델을 사용해도 되지만 뷰모델과 관련된 개념들은 재밌는 부분이 많습니다.</p><p>액티비티의 생명주기, 데이터를 저장하는 다양한 방법들, 라이브데이터, 프래그먼트, 디자인 패턴에서의 뷰모델과, 안드로이드 AAC 뷰모델과의 차이 등이 있는데 이런 개념들을 시간을 두고 하나씩 완전히 익혀두면 굉장히 큰 도움이 될 수 있습니다.</p><blockquote><p>참고로 뷰모델에서 데이터를 저장하는 것은 내부적으로 프래그먼트의 setRetainInstance라는 메커니즘을 사용합니다.</p></blockquote><p>마지막으로 어떤 도구도 상황에 맞게 사용하는 것이 중요합니다. 뷰모델에는 다양한 장점이 있지만 사용해야하는 곳과 주의할 점이 분명합니다. 이런 점들을 잘 알고 필요할 때 사용하는 것이 중요합니다. 이 글이 뷰모델을 사용하는데 조금이라도 도움이 되면 좋겠습니다.</p><h1>참고자료</h1><ul><li><a href="https://developer.android.com/topic/libraries/architecture/viewmodel">ViewModel Overview</a><ul><li>안드로이드 공식 페이지의 뷰모델 사용 가이드</li></ul></li><li><a href="https://developer.android.com/guide/components/activities/activity-lifecycle">Understand the Activity Lifecycle</a><ul><li>안드로이드 공식 페이지의 액티비티 생명주기 가이드</li></ul></li><li><a href="https://developer.android.com/guide/components/activities/parcelables-and-bundles">Parcelables and Bundles</a><ul><li>안드로이드 공식 페이지의 Parcelables과 번들에 대한 설명</li></ul></li><li><a href="https://medium.com/androiddevelopers/viewmodels-a-simple-example-ed5ac416317e">ViewModels : A Simple Example</a><ul><li>구글 Advocator인 Lyla가 쓴 뷰모델의 사용 시 주의할 점과 다른 방식들과의 비교</li></ul></li><li><a href="https://medium.com/androiddevelopers/viewmodels-persistence-onsaveinstancestate-restoring-ui-state-and-loaders-fc7cc4a6c090">ViewModels: Persistence, onSaveInstanceState(), Restoring UI State and Loaders</a><ul><li>구글 Advocator인 Lyla가 쓴 뷰모델에 대한 전반적인 설명</li></ul></li></ul>]]></content:encoded>
      
      <comments>https://jeongmin.github.io/2020/05/04/android/architecture-components/viewmodel/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CSS 글꼴(Font) 이야기</title>
      <link>https://jeongmin.github.io/2020/04/30/web/css-font/</link>
      <guid>https://jeongmin.github.io/2020/04/30/web/css-font/</guid>
      <pubDate>Wed, 29 Apr 2020 15:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1&gt;CSS 글꼴&lt;/h1&gt;
&lt;p&gt;우리는 하루에도 수많은 글을 봅니다. 스마트폰으로 웹서핑을 하거나 책을 볼 때, 우연히 길에서 스쳐간 간판까지, 눈을 뜨고 있다면 의식적으로든, 무의식적으로든 글을 읽는 걸 피할 수 없죠.&lt;/p&gt;
&lt;p&gt;글은 기본적으로
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1>CSS 글꼴</h1><p>우리는 하루에도 수많은 글을 봅니다. 스마트폰으로 웹서핑을 하거나 책을 볼 때, 우연히 길에서 스쳐간 간판까지, 눈을 뜨고 있다면 의식적으로든, 무의식적으로든 글을 읽는 걸 피할 수 없죠.</p><p>글은 기본적으로 정보를 전달하지만 같은 글이라도 다양한 서체로 표현될 수 있습니다. 사람마다 글씨체가 모두 다른 것처럼 말이죠. 이에 따라 세상에는 굉장히 많은 글꼴이 개발되어 사용되고 있습니다. 애플의 스티브 잡스가 글꼴을 굉장히 중요하게 다루었다는건 굉장히 유명한 이야기입니다.</p><p>프로그래머인 저에게도 글꼴을 다룰일은 굉장히 많습니다. 개발하는 서비스에 따라 디자이너가 원하는 글꼴이 다르기 때문에 디자인 팀에서 선정한 글꼴을 적용해야합니다. 또한 개발환경을 세팅할 때 좋아하는 글꼴을 설치하고 이를 IDE에 적용하는 것은 마치 신성한 의식과도 같은 일입니다.</p><p>이번 글에서는 프로그래머로서 글꼴을 다룰 때 자주 마주치는 몇 가지 개념들에 대해 다루도록 하겠습니다.</p><h1>세리프(Serif)와 산 세리프(Sans-Serif)</h1><p><img src="/assets/img/css-font/font-types.gif" alt="출처 https://www.w3schools.com"></p><h2 id="세리프-Serif">세리프(Serif)</h2><p>세리프는 '장식’을 의미합니다. 위에 이미지에서 세리프 글꼴을 보면 선의 끝에 굴림 처리가 되어있고, 선의 굵기도 다른 특징을 가집니다. 한글로 치면 궁서체가, 영어로는 타임즈 뉴 로만(Times New Roman)이 대표적이죠. 보통 인쇄물에 많이 사용됩니다.</p><h2 id="산-세리프-Sans-Serif">산 세리프(Sans-Serif)</h2><p>Sans는 '없음’을 나타냅니다. 즉 세리프가 없다라는 의미가 되니 장식이 없다라고 받아들이면 되겠죠? 위의 이미지에서 산 쉐리프 서체를 보면 선의 굵기가 동일하고 장식이 없습니다. 한글 글꼴에서는 고딕 서체들을 떠올리면 됩니다. 주로 모니터 화면에서 보는 서체에 많이 사용됩니다.</p><p>참고로 디지털 세상에서 산 세리프 글꼴이 자주 쓰이게 된건 과거에는 디스플레이 기능의 제약상 곡선을 매끄럽게 표현하기 어려워 세리프 글꼴을 표현하기 어려웠던 이유가 있었다고 하네요.</p><h2 id="세리프와-산-세리프의-차이">세리프와 산 세리프의 차이</h2><p>둘의 차이를 위에서 간단히 살펴 보았습니다. 표면적으로는 글꼴에 '장식’이 있는지 없는지가 핵심이지만 조금만 더 이 둘의 차이를 알아보도록 하겠습니다.</p><p>먼저 세리프와 산 세리프의 차이는 가독성(readability)과 판독성(legibility)을 가지고 볼 수 있습니다.</p><p>가독성은 많은 양의 글을 볼 때의 읽기 쉬운 정도를 나타내는데 일반적으로 신문과 같은 인쇄물에서는 쉐리프가, 모니터 화면 상에서는 산세리프가 가독성이 높다고 봅니다. 다만 이건 사람에 따라, 익숙한 정도에 따라 달라지는 주관적인 부분입니다.</p><p>판독성은 각각의 글자가 정확히 어떤 글자를 나타내는지를 인식할 수 있는 정도를 나타냅니다. 예를 들어 i와 l은 글꼴에 따라 매우 비슷하게 보일 수 있습니다. 프로그래머가 코딩을 할 때 가장 먼저 프로그래밍 하기 좋은 글꼴을 설정하는데 그 이유가 여기에 있습니다.</p><p>프로그래머가 사용하는 글꼴들은 대부분 이 판독성이 좋은 것들이 많습니다. 아래의 예는 네이버에서 만든 D2Coding 이라는 글꼴입니다. 이미지를 보시면 헷갈리기 쉬운 글자들이 구분되기 쉽도록 신경을 많이 쓴 것이 느껴 지시나요? 그리고 이런 노력들이 앞에서 이야기한 <code>판독성</code>을 높여줍니다.</p><p><img src="/assets/img/css-font/font-for-coding.jpg" alt="d2coding"></p><h1>모노스케이프(Monoscape)</h1><p>앞에서 세리프와 산 세리프에 대해 알아보았습니다. 그럼 두 번째. 글꼴을 이야기 할 때 모노스케이프는 무엇을 의미하는 걸까요?</p><p>답은 간단합니다. 모노스케이프 글꼴을 모든 글자의 가로길이가 같은 글꼴을 이야기합니다. 모노스케이프란 단어 자체가 고정너비라는 뜻이기도 합니다. 그럼 모노스케이프 글꼴은 언제 주로 사용할까요? 바로 프로그래밍을 할 때 가장 많이 선택 합니다. 글꼴이 고정너비여야만 코드가 동일한 간격으로 정렬되어 편집도 쉽고 보기도 좋기 때문이죠. 엄밀히 말하면 보통 모노스케이프이면서 산 세리프인 글꼴을 많이 사용합니다.</p><p>참고로 저는 코딩을 할 때 D2Coding이나 나눔고딕코딩 글꼴을 주로 사용하는데요. 이 두 글꼴은 한국에서 개발된 글꼴이라 한글도 잘 지원이 되고 무료이기까지 합니다.</p><p>아무래도 우린 한국 사람이니 코드를 짜다보면 주석이나, 코드 자체에도 한글이 들어갈 일이 생깁니다. 이럴 때 외국에서 만든 글꼴을 쓰면 한글이 예쁘게 나오지 않는 경우가 많은데(폰트에 한글 자체가 아예 안들어가 있기 때문에) D2Coding이나 나눔고딕코딩을 쓰면 이런 문제가 깨끗이 해결됩니다. 참고로 이 두 글꼴은 네이버에서 만든 글꼴입니다. 한때 제가 몸담았던 회사라 괜히 더 애정이 가네요. :)</p><p><img src="/assets/img/css-font/font-monoscape.jpg" alt="d2coding"></p><h1>폰트 패밀리(Font Families)</h1><p>글꼴은 우리가 글을 사용하며 함께 발전해 왔습니다. 어떤 운영체제를 사용하든 글꼴 설정에 들어가서 내가 사용할 수 있는 글꼴을 확인해 보면 그 숫자에 아마 놀라실겁니다.</p><p>이렇게 많은 글꼴중에 원하는 글꼴을 좀 더 쉽게 적용하려면 어떻게 해야할까요? 그리고 내가 사용하려고 하는 글꼴이 시스템에 설치가 되어있지 않다면 어떻게 해야할까요? 폰트 패밀리는 이런 문제를 해결해 줍니다.</p><p>아래는 CSS에서 폰트 패밀리를 설정하는 예제입니다. 아래 코드는 이렇게 읽을 수 있습니다.</p><blockquote><p>시스템에 Verdana 글꼴이 있으면 Verdana를, 없으면 Arial을, Arial도 없으면 산 세리프 글꼴 중에 하나를 사용해주세요.</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: Verdana, Arial, sans-serif;</span><br></pre></td></tr></table></figure><p>즉 글꼴이 없는 경우를 대비해서 좌측에서부터 순서대로 예비 글꼴을 지정할 수 있는 것이죠. 이때 특정 글꼴을 지정하거나, 앞서 우리가 배웠던 글꼴의 형태를 지정해 줄 수 있습니다. 위의 예에서는 산 세리프(sans-serif) 부분이 이에 해당합니다.</p><h1>마무리</h1><p>이번 글에서는 프로그래머로서 글꼴을 다룰 때 알아야할 아래의 세 가지 주요 개념에 대해 알아보았습니다.</p><ol><li>세리프와 산 세리프</li><li>모노스케이프</li><li>폰트 패밀리</li></ol><p>세리프와 산 세리프, 모노스케이프는 글꼴에 대한 전반적인 개념이고 폰트 패밀리는 CSS에서 글꼴을 지정하는 방식입니다. 폰트 패밀리는 CSS에서 대표적으로 사용되지만 다른 언어나, 툴 등에서도 자주 사용됩니다. 다만 사용되는 곳에 따라 구체적인 사용법은 조금 다를 수 있습니다. 하지만 우리는 개념을 알고 있으니 문서를 보면 금방 이해하고 적용할 수 있겠죠?</p>]]></content:encoded>
      
      <comments>https://jeongmin.github.io/2020/04/30/web/css-font/#disqus_thread</comments>
    </item>
    
    <item>
      <title>테마(Theme)를 이용해서 다양한 모습의 안드로이드 앱 만들기</title>
      <link>https://jeongmin.github.io/2020/03/08/android/styling/android-theming/</link>
      <guid>https://jeongmin.github.io/2020/03/08/android/styling/android-theming/</guid>
      <pubDate>Sat, 07 Mar 2020 15:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;멋쟁이들은 계절이나 분위기에 따라 다양한 색의 옷으로 스스로를 표현합니다. 아름다운 자연도 계절에 따라 완전 다른 모습으로 우리의 눈을 사로잡습니다.&lt;/p&gt;
&lt;p&gt;최근 Android, iOS에 많은 화제가 되고 있는 다크 모드(Dark Mode)
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>멋쟁이들은 계절이나 분위기에 따라 다양한 색의 옷으로 스스로를 표현합니다. 아름다운 자연도 계절에 따라 완전 다른 모습으로 우리의 눈을 사로잡습니다.</p><p>최근 Android, iOS에 많은 화제가 되고 있는 다크 모드(Dark Mode)도 비슷합니다. 모드에 따라 하나의 앱이 밝고, 어두운 두 가지 모습을 자유자재로 오갑니다.</p><p>안드로이드에서는 테마(Theme)를 이용해서 이를 구현할 수 있습니다. 계절에 따라 모습이 바뀌는 자연을 생각하면 테마는 계절이라고 생각할 수도 있고, 기분에 따라 옷의 컬러를 선택하는 사람에겐 기분이 테마가 될 수 있습니다.</p><p>안드로이드의 다크 모드라는 것도 결국은 시스템이 '다크 모드(Dark mode)'일 때 이에 맞는 미리 만들어둔 테마를 적용시켜주는 것에 불과합니다.</p><p>아래 이미지는 안드로이드 공식 페이지에서 테마에 대해 설명하는 이미지입니다. 동일한 액티비티에 서로 다른 테마를 적용한 모습으로, 테마에 따라 액티비티가 완전히 다른 느낌으로 변하는 모습을 볼 수 있죠.</p><p><img src="https://developer.android.com/training/material/images/material-themes_2x.png" alt="Two themes applied to the same activity: Theme.AppCompat (left) and Theme.AppCompat.Light (right)"></p><p>그럼 이번 포스팅에서는 테마에 따라 다양한 모습으로 변신하는 앱을 어떻게 만들 수 있는지에 대해 이야기하도록 하겠습니다.</p><h2 id="테마의-선언과-구성">테마의 선언과 구성</h2><p>앞에서 테마에 대해 개념적으로 설명을 드렸지만 우리는 개발자이니 좀 개발자의 관점에서 테마를 살펴보도록 하겠습니다. 테마는 아래와 같이 res/values/style.xml에 선언합니다. 여기서 파일 명은 원하는 대로 작성하셔도 됩니다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.MaterialComponents.DayNight.NoActionBar"</span>&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorPrimary"</span>&gt;</span>@color/colorPrimary<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorPrimaryDark"</span>&gt;</span>@color/colorPrimaryDark<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorAccent"</span>&gt;</span>@color/colorAccent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorImagePlaceHolder"</span>&gt;</span>@color/GR80<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>일단 기본적으로 테마는 키, 값의 쌍으로 이루어진 맵과 같이 생각할 수 있습니다.</p><p>더 위에 style 태그를 보면 마치 클래스 처럼 parent를 통해 다른 테마를 <strong>상속</strong> 받을 수도 있습니다. 위의 예에서는 AppTheme이라는 테마가 <code>Theme.MaterialComponents.DayNight.NoActionBar</code>라는 테마를 상속받아 선언되고 있습니다. 다른 테마를 상속 받으면 새로 정의한 테마는 parent 테마의 모든 속성을 동일하게 갖게되고 기존의 속성을 오버라이드할 수 있습니다.</p><p><code>&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.MaterialComponents.DayNight.NoActionBar&quot;&gt;</code></p><p>이제 가장 중요한 내용입니다.</p><blockquote><p>테마에 있는 속성들은 컬러와 같은 디자인 리소스에 의미있는 이름을 붙인 것 입니다. 예를 들어 위에 colorAccent은 안드로이드의 뷰가 가진 속성이 아닙니다. 그리고 colorAccent는 이름에서 보이듯이 이름에서 어떤 특정 색을 표현하지 않고 '강조를 나타내는 색’이라는 의미를 더 강조하고 있습니다.</p></blockquote><p><strong>즉 테마에 따라 colorAccent를 다르게 적용할 수 있음을 표현하는 것입니다.</strong> 꼭 인터페이스와 구현체의 관계와 비슷합니다. colorAccent라는 속성(인터페이스)은 서로 다른 테마(구현체)에서 다른 컬러로 표현될 수 있는 것입니다.</p><h2 id="머티리얼-디자인에-포함된-주요-테마-속성">머티리얼 디자인에 포함된 주요 테마 속성</h2><p>테마는 내가 직접 정의해서 사용할 수도 있고 안드로이드 플랫폼에 정의되어 바로 사용할 수 있는 것들도 있습니다. 아래 이미지는 롤리팝과 함께 머티리얼 디자인이 소개되면서 많이 쓰인 이미지입니다.</p><p><img src="/assets/img/android_theming/material_theme_attrs.png" alt="Material theme attributes"></p><p>위에 보이는 <code>colorPrimary</code>, <code>textColorPrimary</code>, <code>colorPrimaryDark</code>, <code>windowBackground</code>, <code>navigationBarColor</code>와 같은 속성들은 머티리얼 테마(Material Theme)에 미리 정의된 것으로 보시는 것처럼 시스템 UI에 미리 사용되고 있고 앱에서 얼마든지 이를 재정의(Override)해서 사용이 가능합니다. 즉 앱에서 사용하는 테마에서 colorPrimaryDark를 노란색으로 적용하면 위에 위에 그림에 있는 상태바(Status bar)의 색은 노란색으로 변경될 것입니다.</p><p>그렇다면 이게 어떻게 가능할까요? 바로 안드로이드도 플랫폼에서 상태바의 색상에 특정 컬러를 하드코딩 한게 아니라 colorPrimaryDark라는 테마의 속성을 참조하도록 해두었기 때문입니다.</p><p>아래는 머티리얼 테마를 상속받아서 앱에서 직접 사용할 테마를 AppTheme라는 이름으로 선언해서 사용하는 예입니다. 아래 예에서 android:windowBackground나 android:windowActivityTransitions와 같은 속성은 안드로이드 프레임워크에 있는 테마이고, colorPrimary, colorPrimaryDark, colorAccent는 머티리얼 테마에 선언된 속성입니다.</p><p>그리고 마지막에 있는 colorImagePlaceHolder는 제가 직접 만든 속성입니다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.MaterialComponents.DayNight.NoActionBar"</span>&gt;</span></span><br><span class="line">        // Attributes from material theme</span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorPrimary"</span>&gt;</span>@color/colorPrimary<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorPrimaryDark"</span>&gt;</span>@color/colorPrimaryDark<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorAccent"</span>&gt;</span>@color/colorAccent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">        // Attributes from android framework</span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowBackground"</span>&gt;</span>#ffffff<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowActivityTransitions"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">        // Attributes that I've defined</span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorImagePlaceHolder"</span>&gt;</span>@color/GR80<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>colorImagePlaceHolder와 같이 기존에 없는 속성을 선언하고 싶으면 res/values/values.xml 파일에 아래와 같은 방식으로 선언하면됩니다. 보시면 좌측에 속성이 가질 리소스 포맷을 적고 name에 사용할 속성 명을 적어주면 됩니다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">format</span>=<span class="string">"color"</span> <span class="attr">name</span>=<span class="string">"colorImagePlaceHolder"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">format</span>=<span class="string">"color"</span> <span class="attr">name</span>=<span class="string">"colorDivider"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">format</span>=<span class="string">"color"</span> <span class="attr">name</span>=<span class="string">"mildBackgroundColor"</span>/&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="테마에-적용된-값을-사용하기">테마에 적용된 값을 사용하기</h2><p>자 이제 테마의 개념부터, 종류, 선언하는 방법까지 알아봤으니 어떻게 사용하는지를 알아봅시다. 테마를 사용하는 가장 기본적인 방법은 <code>?attr/[attributeName]</code> 을 사용하는겁니다. 구체적으로 아래와 같이 사용할 수 있습니다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.appcompat.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/toolbar"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">style</span>=<span class="string">"@style/Toolbar"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:titleTextColor</span>=<span class="string">"?attr/titleTextColor"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:titleTextAppearance</span>=<span class="string">"@style/ToolbarTitle"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:title</span>=<span class="string">"Toolbar"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>툴바의 텍스트 컬러를 지정하는 부분을 보시면 아래처럼 <code>?attr</code>을 사용하고 있죠.</p><blockquote><p>?attr/titleTextColor</p></blockquote><p><code>?attr</code>은 테마에서 attr 뒤에 있는 속성 이름으로 값을 찾아오라는 의미입니다. 예를 들어 위의 예에서는 현재 나에게 적용된 테마에서 titleTextColor라는 이름으로 정되된 컬러값을 가져오라는 뜻입니다.</p><p>앱에 현재 LightTheme과 DarkTheme가 있다고 합시다. 현재 이 툴바가 LightTheme를 적용받고 있고 LightTheme에 titleTextColor가 흰색이라면 툴바의 텍스트는 흰색이 될 것이고, DarkTheme를 적용받고 있고 여기에 titleTextColor가 검정이라면 툴바의 텍스트는 검정이 됩니다.</p><p>결국 테마를 통해 화면의 모습을 다이나믹하게 변경하는 것은 내가 변경하고자 하는 UI 요소의 컬러를 최대한 <code>?attr</code>을 이용해서 테마의 속성을 간접 참조(indirect reference)로 설정하고, 사용자의 선택이나, 환경에 따라 테마를 변경하는 것입니다. <strong>(이 포스팅 전체에서 가장 중요한 내용인거 같네요.)</strong></p><h2 id="테마의-적용">테마의 적용</h2><p>그렇다면 위의 예에서 저 툴바에 적용되는 테마는 어떻게 결정 될까요? <code>테마는 컨텍스트에 적용이 됩니다.</code> 자 그럼 안드로이드 플랫폼에서 컨텍스트를 갖는게 어떤게 있을까요? View, ViewGroup, Activity, Application 등이 있겠죠. 테마는 컨텍스트에 적용이 되기 때문에 여기에 모두 적용이 됩니다.</p><p>또한 테마는 범위를 갖는데 상위레벨에 적용한 테마는 하위 레벨까지 모두 적용이 되고 하위레벨에 적용된 테마가 상위레벨에 적용된 테마에 우선해서 적용됩니다.</p><ol><li>어플리케이션 레벨로 적용하기<br>androidManifest.xml</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>액티비티에 적용하기<br>androidManifest.xml</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">...</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:theme</span>=<span class="string">"@style/SplashTheme"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>뷰그룹 및 뷰에 적용하기</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">"@style/Theme.MaterialComponents.Light"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">...</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">...</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:theme</span>=<span class="string">"@style/ThemeOverlay.MaterialComponents.Dark"</span></span></span><br><span class="line"><span class="tag">            /&gt;</span>         </span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>xml에서 각 테마는 <code>android:theme</code>를 통해 적용이 가능하고 적용하고자 하는 범위에 따라 androidManifest.xml의 application 태그나, activity 태그 또는 레이아웃 파일에서 각 뷰그룹 또는 뷰에 적용이 가능합니다.</p><h2 id="코드에서-테마에-정의된-속성-값-읽어오기">코드에서 테마에 정의된 속성 값 읽어오기</h2><p>앞서 테마는 컨테스트에 적용이 된다고 이야기했습니다. 그럼 테마에 엮여있는 특정 속성의 값을 코드에서 가져오려면 어떻게 할까요?<br>(xml이였다면 <code>?attr/[attributeName]</code>을 썼겠죠)</p><p>아래는 컨텍스트에 엮여있는 컬러값을 가져오는 예제입니다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@ColorInt</span><br><span class="line">fun Context.getThemeColor(@AttrRes themeAttrId: Int): Int &#123;</span><br><span class="line">    return obtainStyledAttributes(</span><br><span class="line">            intArrayOf(themeAttrId)</span><br><span class="line">    ).use &#123;</span><br><span class="line">        it.getColor(0, Color.TRANSPARENT)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>현재 액티비티의 테마에 있는 colorPrimary를 가져오려면 액티비티 내에서 <code>getThemeColor(R.attr.colorPrimary)</code>와 같이 할 수 있을 것이고 특정 뷰그룹에 적용된 테마에 대한 컬러를 가져오려면 <code>targetViewGroup.getContext().getThemeColor(R.attr.colorPrimary)</code>와 같이 사용할 수 있겠죠.</p><h2 id="테마의-사용">테마의 사용</h2><p>자 그럼 위에서 알아본 테마의 개념이 어떤식으로 사용될 수 있을까요? 아래의 UI를 예로 들어 봅시다. 이 앱의 처음 디자인은 좌측의 밝은 색 위주의 디자인이였는데 어떤 과정을 거쳐서 우측과 같이 어두운 테마를 적용할 수 있었을까요?</p><p><img src="/assets/img/android_theming/light_dark.png" alt="Android Theming"></p><p>이를 위해서는 아래와 같은 단계를 밟아가면 됩니다.</p><ol><li>테마에 따라 색상이 변하는 부분과 변치 않을 부분을 나눠봅니다.</li><li>UI에서 컬러가 하드코딩 되어있는 부분을 찾고 테마의 어떤 속성을 사용할지 결정합니다. 이때는 이미 시스템에 정의된 테마의 속성을 사용할지, 새로운 속성을 만들지 결정합니다.</li><li>새로운 테마를 만들고 이 테마에서 변화를 줄 속성을 오버라이드합니다.</li><li>UI에서 변경이 필요한 부분의 컬러를 테마의 속성을 참조하도록 <code>?attr/</code>을 이용하여 변경합니다.</li></ol><h2 id="테마에-따라-색상이-변하는-부분과-변치-않을-부분을-나눠보기">테마에 따라 색상이 변하는 부분과 변치 않을 부분을 나눠보기</h2><p>위의 예제에서 변하는 부분과 변치 않는 부분을 나눠봤습니다.</p><p>변하는 것</p><ul><li>화면의 배경</li><li>툴바의 배경</li><li>쿨바의 텍스트</li><li>리스트 내의 카드 배경</li><li>리스트 내의 카드 텍스트</li><li>바텀네비게이션 배경</li><li>바컴네비게이션 아이콘</li><li>탭레이아웃 배경</li></ul><p>변하지 않는 것</p><ul><li>탭레이아웃 인디케이터 및 선택된 탭의 텍스트</li><li>리스트 내 카드의 재생시간 뱃지</li></ul><p>변하는 부분과 변치 않는 부분을 나눴으면 각각에 어떤 테마의 속성을 사용할 수 있을까요? 모두 새로 선언해도 되지만 이미 선언돼있는 다양한 속성들이 있으니 이것들을 먼저 확인해봅니다.</p><p>아래 링크에는 머티리얼 디자인 시스템에 이미 선언돼있는 다양한 속성들에 대한 설명이 있습니다.</p><p><a href="https://medium.com/androiddevelopers/android-styling-common-theme-attributes-8f7c50c9eaba">Android Styling: Common Theme Attributes</a></p><p>이 글에서는 컬러에 대한 내용을 주로 다루고 있으니 몇 가지 컬러 관련 속성을 보겠습니다.</p><ul><li>?attr/colorPrimary : 앱의 메인 브랜딩 컬러</li><li>?attr/colorSecondary : 앱의 세컨 브랜딩 컬러로 주로 메인 브랜딩 컬러를 보완하는 좀 더 밝은 색상으로 사용</li><li>?attr/colorOn[Primary, Secondary, Surface etc] : 각 컬러에 대한 대비를 이루는 색입니다. 예를 들어 배경에 ?attr/colorPrimary를 쓰고, 여기위에 다른 UI 컴포넌트를 올릴 때 colorOnPrimary를 사용하면 이 컴포넌트를 좀 더 눈에 띄게 강조 할 수 있겠죠.</li><li>?attr/colorSurface : 카드(cards), 시트(sheets), 메뉴(menues)와 같은 컴포넌트의 표면 색을 나타냅니다.</li><li>?attr/colorBackground : 스크린의 백그라운드 색</li><li>?attr/colorError : 에러를 표시할 때 사용할 색</li></ul><p>아래 이미지는 <a href="http://material.io">material.io</a> 페이지에 있는 <code>The baseline Material color theme</code>로, 위의 컬러를 보통 어떤식으로 선택하는지에 대한 예시를 보여주고 있습니다. 참고로 <a href="http://material.io">material.io</a> 페이지에 가면 대비가 되는 색을 선택하거나, 위에 있는 머티리얼 테마에 사용되는 속성값들을 어떤 식으로 결정하면 좋을지에 대한 가이드와 툴이 잘 나와있습니다.</p><p><img src="/assets/img/android_theming/material_theme_attrs_of_colors.png" alt="The baseline Material color theme"></p><p>다시 아래 목록으로 돌아와서 위에 있는 속성들을 참고하면 저는 아래와 같이 테마의 속성을 정의할 수 있을거 같습니다. 이걸 바탕으로 각 UI 컴포넌트에 하드코딩 되어있던 컬러를 <code>?attr</code>를 이용해서 바꿔줍니다.</p><p><img src="/assets/img/android_theming/theme-colors.png" alt="Choosing theme attributes"></p><p>이제 위의 속성들을 각 테마에 따라 정의합니다.</p><p>밝은 테마</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"LightTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.MaterialComponents.DayNight.NoActionBar"</span>&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorSurface"</span>&gt;</span>@android:color/white<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"backgroundColor"</span>&gt;</span>@android:color/white<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowBackground"</span>&gt;</span>@color/gray_bg<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"titleTextColor"</span>&gt;</span>@android:color/black<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line">        ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>어두운 테마</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"DarkTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.MaterialComponents.DayNight.NoActionBar"</span>&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorSurface"</span>&gt;</span>@color/gray_900<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"backgroundColor"</span>&gt;</span>@android:color/black<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowBackground"</span>&gt;</span>@android:color/black<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"titleTextColor"</span>&gt;</span>@android:color/white<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line">        ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>이제 감이 오시나요? 위의 속성들을 재정의 하는 테마를 추가하기만 하면 이제 얼마든지 분위기가 확 다른 앱을 만들 준비가 된 것이죠.</p><p>그럼 이제 이런 테마를 어떻게 적용하면 될까요? 아까 위에 기술 했던대로 activity 또는 application 단위로 androidManifest의 android:theme 태그를 이용해 정의하면 됩니다. 이걸 동적으로 하고 싶다구요? 그럼 간단히 테마를 선택할 수 있는 다이얼로그를 하나 만들고 테마를 선택하면 이걸 Preference 같은 곳에 저장하고, 액티비티가 시작 시 setContentView 이전에 테마를 설정해주면 됩니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="keyword">val</span> userSelectedPref = getThemeFromPref()</span><br><span class="line">        <span class="keyword">when</span>(userSelectedPref) &#123;</span><br><span class="line">            <span class="string">"light"</span> -&gt; setTheme(R.style.LightTheme)</span><br><span class="line">            <span class="string">"pink"</span> -&gt; setTheme(R.style.PinkTheme)</span><br><span class="line">            <span class="string">"dark"</span> -&gt; setTheme(R.style.DarkTheme)</span><br><span class="line">            <span class="keyword">else</span> -&gt; setTheme(R.style.LightTheme)</span><br><span class="line">        &#125;</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>테마는 뷰가 인플레이트 되기 전에 설정이 되고 인플레이트 후에는 변경해도 UI에 업데이트가 반영이 되지 않기때문에 setOntentView 이전에 해주어야합니다.</p><h2 id="다크-모드">다크 모드</h2><p>그럼 다크모드는 뭘까요? 다크모드는 안드로이드 9에서부터 지원되는 시스템 설정입니다. 즉 앱이 아니라 안드로이드 시스템에서 설정 가능한 모드입니다. 앱에서 다크모드를 지한한다는 것은, 사용자가 시스템의 다크모드를 적용하면 이에 따른 어두운 테마를 만들어 두었다가 이게 적용되도록 해주면 됩니다. 간단하죠?</p><p>이 부분은 이 글의 내용을 이해했다면 간단히 적용이 가능하지만 이 글에서 다루면 너무 길어질 것 같아서 다음 포스팅에서 따로 다루도록 하겠습니다.</p><h2 id="마무리">마무리</h2><p>저는 디자인과는 좀 거리가 있어보이는 개발자입니다. 노트북이 들어간 백팩과 체크무늬 셔츠가 가장 편안합니다. 하지만 그럼에도 제가 만든 앱은 어디서나 돋보였으면 좋겠고 보기에 좋았으면 좋겠습니다. 또한 저는 잘 다듬어진 디자인은 그 자체로 유저에게 큰 가치를 준다고 생각합니다. 이 글을 보신 분들도 테마를 이용해서 보다 다양한 느낌의 앱을 앱을 만드는데 도움이 되셨으면 합니다.</p><h1>참고</h1><p>테마에 관련된 글들은 주로 안드로이드 엔지니어인 Nick Butcher의 유튜브 영상과 미디엄 글을 많이 참고했습니다. 또한 material.io에 있는 페이지들도 개발자에게 디자인과 관련된 컴포넌트나 개념을 잡는데 도움이 많이 되었습니다.</p><p>마지막으로 안드로이드의 테마를 이야기하면 항상 스타일(Style)에 대한 이야기를 보통 함께 합니다. 이 둘은 상당히 비슷하면서 다른데 개인적으로는 두개를 같이 다루면 오히려 개념을 잡는데 헷갈리기 때문에 스타일에 대한 이야기는 최대한 배제하였습니다. 하지만 테마를 이해했다면 스타일에 대한 부분도 꼭 짚고 넘어가면 좋을 것 같습니다.</p><ul><li><a href="https://developer.android.com/guide/topics/ui/look-and-feel/darktheme">Dark theme</a></li><li><a href="https://developer.android.com/guide/topics/ui/look-and-feel/themes">Styles and Themes</a></li><li><a href="https://material.io/design/color/the-color-system.html#color-theme-creation">Material io</a></li><li><a href="https://medium.com/androiddevelopers/android-styling-themes-vs-styles-ebe05f917578">Android Styling: Themes vs Styles</a></li><li><a href="https://medium.com/androiddevelopers/android-styling-common-theme-attributes-8f7c50c9eaba">Android Styling: Common Theme Attributes</a></li><li><a href="https://medium.com/androiddevelopers/android-styling-prefer-theme-attributes-412caa748774">Android Styling: Prefer Theme Attribute</a></li><li><a href="https://medium.com/androiddevelopers/android-styling-themes-overlay-1ffd57745207">Android Styling: Themes Overlay</a></li></ul>]]></content:encoded>
      
      <comments>https://jeongmin.github.io/2020/03/08/android/styling/android-theming/#disqus_thread</comments>
    </item>
    
    <item>
      <title>안드로이드의 프로세스, 쓰레드 이해하기</title>
      <link>https://jeongmin.github.io/2018/06/28/android/android-process-thread/</link>
      <guid>https://jeongmin.github.io/2018/06/28/android/android-process-thread/</guid>
      <pubDate>Wed, 27 Jun 2018 15:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;안드로이드 앱을 사용해봤거나 개발해봤다면 누구나 한번씩은 ANR 다이얼로그나 버벅거림, 혹은 크래시로 앱이 비정상 종료되는 상황을 겪어봤을 겁니다. 이런 현상들은 사용자에게 안좋은 경험을 주고 심한 경우 앱을 지워버리게 만드는 요인이 되기도 합니
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>안드로이드 앱을 사용해봤거나 개발해봤다면 누구나 한번씩은 ANR 다이얼로그나 버벅거림, 혹은 크래시로 앱이 비정상 종료되는 상황을 겪어봤을 겁니다. 이런 현상들은 사용자에게 안좋은 경험을 주고 심한 경우 앱을 지워버리게 만드는 요인이 되기도 합니다. 반대로 빠르고 부드러운 앱은 사용자에게 좋은 인상을 줍니다.</p><p>그렇다면 빠르고 크래시 없는 앱을 개발하기 위해서는 어떻게 해야할까요?</p><p>여러가지가 있겠지만 가장 중요한 것 중 하나는 안드로이드의 프로세스와 쓰레드를 잘 이해하고, 올바르게 다루는 것일 겁니다.</p><p>이번 글에서는 안드로이드의 프로세스와 쓰레드의 개념에 대해 정리하고 이를 다룰 때 주의할 점에 대해 다루도록 하겠습니다.</p><h2 id="1-안드로이드-앱의-실행과-프로세스">1. 안드로이드 앱의 실행과 프로세스</h2><p>안드로이드는 리눅스 기반의 OS입니다. 리눅스 커널위에 라이브러리와 런타임이 있고 그 위에 어플리케이션 프레임워크가 존재합니다. 안드로이드 앱 개발자는 어플리케이션 프레임워크에서 제공하는 컴포넌트와 이를 사용하기 위한 API를 이용해서 안드로이드 앱을 개발합니다.</p><p>안드로이드 앱은 앱 컴포넌트를 통해 실행됩니다. 앱 컴포넌트는 <strong>액티비티, 서비스, 컨텐츠 프로바이더, 브로드캐스트 리시버</strong> 이렇게 네 가지입니다.  앱 컴포넌트 중 하나를 실행 시켰는데 이미 실행 중인 컴포넌트가 있으면 안드로이드 시스템은 해당 컴포넌트를 기존 프로세스 내에서 실행 시키고, 없는 경우 새 리눅스 프로세스를 생성하고 여기서 컴포넌트를 실행 시킵니다.</p><p><img src="/assets/img/android-thread/android-components.png" alt="App Components"></p><h3 id="1-1-앱의-실행-경로">1.1. 앱의 실행 경로</h3><p>가장 기본적인 실행 경로는 안드로이드 런쳐, 즉 홈 화면이나 앱 메뉴에서 앱 아이콘을 클릭해서 실행 시키는 방법이 있습니다. 이 경우 앱은 AndroidManifest.xml에 정의한 런쳐 액티비티를 실행합니다. 이 방식은 앱 컴포넌트 중 액티비티를 통해 앱이 실행되는 경우입니다.</p><p>두 번째로 앱에서 알람을 등록했다고 합시다. 지정한 시간이 되면 알람을 받는 앱의 브로드캐스트 리시버가 호출이 됩니다. 이 경우는 브로트캐스트 리시버를 통해 앱이 실행되는 케이스입니다. 같은 방식으로 서비스, 컨텐츠 프로바이더를 통해 동일하게 앱이 실행되는 시나리오가 있을 수 있습니다.</p><p><img src="/assets/img/android-thread/launch-process-from-appcomponent.png" alt="App Launches from Components"></p><h3 id="1-2-프로세스와-메인-쓰레드">1.2. 프로세스와 메인 쓰레드</h3><p>위에 설명한 실행 경로를 통해 앱이 실행되면 하나의 리눅스 프로세스가 생성되고 프로세스 안에는 하나의 쓰레드가 기본으로 생성됩니다. 이 쓰레드가 바로 메인 쓰레드입니다. 메인 쓰레드는 아주 중요하기 때문에 어떤 일을 하고 어떻게 동작하는지 잘 이해해야 좋은 앱을 만들 수 있습니다.</p><p>먼저 앱의 네 가지 컴포넌트는 메인 쓰레드에서 실행됩니다. 따라서 앱 컴포넌트 중 하나인 액티비티의 라이프사이클 관련 콜백이나, 브로드캐스트 리시버의 onReceive()등도 모두 메인 쓰레드에서 실행됩니다.</p><p>두 번째로 UI 위젯을 통한 사용자 이벤트와 드로잉 이벤트가 메인 쓰레드에서 실행됩니다. 즉 안드로이드 UI toolkit에 있는 android.widget, android.view의 사용자 이벤트 처리나 드로잉 관련 메소드가 여기 해당됩니다.</p><p>조금 이해가 가지 않는 다면, onClick, onKeyDown, onDraw 같은 콜백들을 생각하면 됩니다.</p><p>이렇게 사용자 이벤트와 드로잉 이벤트가 메인 쓰레드에서 처리되기 때문에 메인 쓰레드를 UI 쓰레드라고도 합니다. 하지만 엄밀히 말하면 둘은 서로 같은게 아닙니다. 메인 쓰레드가 UI 쓰레드를 포함 하는 개념으로 보시는게 좋습니다.</p><h3 id="1-3-부드러운-UI-개발을-위해-알아야-하는-것">1.3. 부드러운 UI 개발을 위해 알아야 하는 것</h3><p>앱개발을 좀 해봤다면 메인쓰레드 내에서 16ms 이상 걸리는 작업을 하면 안된다는 얘기를 많이 들어보셨을 겁니다. 우리가 보는 화면의 움직임은 결국 프레임의 연속입니다. 조금씩 변하는 프레임이 연속으로 빠르게 이어지면 사람의 뇌는 이걸 움직임으로 인식합니다.</p><p>이 프레임이 너무 낮거나 불규칙하게 이어지면 사용자는 UI가 부드럽지 않다고 느끼게 됩니다. 안드로이드는 초당 60 프레임, 즉 60fps을 유지하도록 권장합니다. 60fps가 사람이 인지할 수 있는 선에서 가장 부드러운 수치이기 때문입니다. 1초는 1000ms 이기 때문에 60fps를 달성하려면 1000/60, 즉 프레임이 16ms당 한번씩 새로 그려질 수 있어야 60fps가 유지됩니다. 이에 대한 이야기는 아래 유튜브 영상에서 보실 수 있습니다.</p><p><a href="https://youtu.be/CaMTIgxCSqU">PerfMatter Why 60fps</a><br><img src="https://i3.ytimg.com/vi/CaMTIgxCSqU/maxresdefault.jpg" alt="PerfMatter Why 60fps"></p><p>여기서 이제 가장 중요한 개념이 등장합니다. 앞서 메인 쓰레드는 UI 업데이트 즉 드로잉 작업도 처리한다고 언급하였습니다. 그래서 메인 쓰레드를 UI 쓰레드라고 부르기도 한다고 했죠. 즉 이 메인 쓰레드에서 16ms 이상 걸리는 작업을 하면 메인 쓰레드는 16ms 간격으로 프레임을 업데이트 할 수 없게 됩니다. 즉 프레임 드랍이 일어납니다.</p><p>우리가 리사이클러뷰에서 스크롤을 하거나 화면에 애니메이션이 그려지고 있는 도중에 이런 프레임 드랍이 생기면 화면이 뚝뚝 끊기겠죠? 이러한 화면 끊김을 안드로이드에서는 <strong>Jank</strong> 라고도 부릅니다.</p><blockquote><p>결국 부드러운 UI 개발을 위해 가장 중요한 것은 메인쓰레드에서는 16ms 이상 걸리는 작업은 하지 않는 것이라고도 볼 수 있습니다.</p></blockquote><h3 id="1-4-워커-쓰레드-백그라운드-쓰레드">1.4. 워커 쓰레드(백그라운드 쓰레드)</h3><p>앞에서 설명한 대로 메인쓰레드는 사용자 이벤트와 드로잉 이벤트를 처리하기 위해 사용되기 때문에 메인 쓰레드에서 시간이 오래걸리는 작업을 하는것은 금물입니다. 좀 더 엄밀히 말하면 16ms을 넘기지 않는게 좋습니다.</p><p>그럼 시간이 오래 걸리는 작업들은 어떻게 처리해야 할까요? 답은 간단합니다. 다른 쓰레드를 만들어서 메인 쓰레드가 아닌 곳에서 작업을 처리하면 됩니다. 이렇게 시간이 오래 걸리는 작업을 처리하기 위해 생성한 쓰레드를 워커 쓰레드 또는 백그라운드 쓰레드라고 부릅니다.</p><p>자바에서는 쓰레드를 생성하기 위해 Runnable과 Thread, Executors 클래스를 제공합니다. 이것들을 이용해서 시간이 오래 걸리는 작업을 처리해도 되고 안드로이드에서 편의를 위해 제공하는 AsyncTask, AsyncTaskLoader, ThreadHandler, ThreadPoolExecutor 등을 사용할 수도 있습니다.</p><h3 id="1-5-워커-쓰레드의-기본적인-사용-패턴">1.5. 워커 쓰레드의 기본적인 사용 패턴</h3><p>기본적으로 16ms 이상 걸릴 수 있는 무거운 일들은 메인 쓰레드에서 처리하면 안됩니다. 따라서 이러한 작업들은 보통 위에서 언급한 다양한 클래스를 이용해 워커 쓰레드를 생성하고 여기서 처리합니다. 또한 메인 쓰레드는 쓰레드 세이프 하지 않습니다. 따라서 메인 쓰레드가 아닌 워커 쓰레드에서 UI를 조작하면 정상적으로 반영이 되지 않을 수 있고 비정상적인 동작을 초래할 수 있습니다.</p><p>그런데 워커 쓰레드에서 작업을 하고 이를 UI에 업데이트 하려면 어떻게 해야할까요? 워커 쓰레드에서 시간이 오래걸리는 작업을 하고 그 결과를 UI에 반영해서 사용자에게 결과를 보여주는 것은 앱 개발에서 가장 많이 보이는 패턴중에 하나입니다. 서버에 데이터를 요청하고 이를 화면에 보여주거나 이미지를 가공해서 이를 사용자에게 보여주는 경우 등, 사실 대부분의 경우 워커 쓰레드는 UI 업데이트를 동반하는 경우가 많습니다.</p><p>이를 위해 워커 쓰레드와 메인 쓰레드 간에 통신하는 가장 기본적인 방법은 핸들러(Handler)를 이용하는 방법입니다.</p><p>두 번째로, 안드로이드는 이를 좀 더 간편하게 할 수 있도록 AsyncTask라는 유틸 클래스를 제공합니다. AsysncTask는 워커 쓰레드에서 처리할 일을 doInBackground()에 작성하고 진행 사항이나 결과를 UI에 반영 하는 코드는 onProgressUpdate(), onPostExecute()에 작성하여 메인 쓰레드에서 이를 간편히 실행 시킬 수 있습니다.</p><p>이 외에도 액티비티의 runOnUiThread(), 뷰의 post(), postDelayed()를 이용할 수도 있습니다.</p><p><img src="/assets/img/android-thread/worker-thread.png" alt="Worker thread"></p><h2 id="2-메인-쓰레드와-워커-쓰레드를-잘못-다루었을-때-생길-수-있는-일들">2. 메인 쓰레드와 워커 쓰레드를 잘못 다루었을 때 생길 수 있는 일들</h2><h3 id="2-1-ANR-Application-Not-Responding">2.1. ANR(Application Not Responding)</h3><p>메인 쓰레드는 이름처럼 아주 중요합니다. 앞서 말했던 것처럼 사용자 이벤트와 드로잉 이벤트를 처리하기 때문이죠. 때문에 메인 쓰레드에서 시간이 오래 걸리는 작업을 하면 그만큼 메인 쓰레드는 사용자 이벤트와 드로잉 이벤트를 처리할 수 없게 됩니다.</p><p>즉 메인 쓰레드 내에서 시간이 오래 걸리는 작업을 하게 되면 사용자가 앱의 버튼을 클릭하거나 키보드 입력도 할 수 없고, 앱의 UI도 업데이트가 되지 않아 멈춘 것처럼 보이게 됩니다. 이것이 바로 ANR입니다.</p><p>그럼 ANR을 한번 직접 만들어볼까요? 아주 간단합니다. onClick()과 같은 사용자 인풋 이벤트는 메인 쓰레드에서 실행된다고 언급하였습니다. 그럼 여기서 5초 이상 걸리는 작업을 하도록 하면 바로 ANR을 발생 시킬수 있겠죠?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">override fun <span class="title">onCreate</span><span class="params">(savedInstanceState: Bundle?)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        button.setOnClickListener &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>안드로이드 시스템은 안드로이드 버전에 따라 다르지만 약 5초 이상 UI 쓰레드가 차단되면 ANR 대화 상자를 띄움으로써 사용자가 앱을 강제로 종료할 수 있게합니다.</p><p><img src="https://developer.android.com/topic/performance/images/anr-example-framed.png" alt="ANR"></p><h3 id="2-2-워커-쓰레드와-UI-처리">2.2 워커 쓰레드와 UI 처리</h3><p>앱 개발을 하다보면 워커 쓰레드의 작업 결과를 메인 쓰레드에서 UI에 반영하는 경우가 많은데 이 때 자주 하는 실수가 있습니다.</p><p>하나는 워커 쓰레드에서 작업을 끝내고 이를 UI에 반영할 때 해당하는 View가 View hierachy에서 제거 되었거나 객체 자체가 삭제 되었을 수 있습니다. 안드로이드에선 네트워크 호출은 워커 쓰레드에서 호출하도록 하고 있는데 서버로 API 호출을 한 후 이 응답값을 이용해서 UI를 수정하는 경우 흔히 발생 할 수 있는 경우입니다.</p><p>좀 더 구체적인 예를 들면 액티비티 위에 프레그먼트가 있고 여기서 네트워크 콜을 합니다. 이후 네트워크 응답이 오기 전에 사용자가 백키를 눌러서 프레그먼트를 프레그먼트 스택에서 제거합니다. 이렇게 되면 프레그먼트는 액티비티의 View hierachy에서 제거 됩니다. 이제 네트워크 응답이 오고 액티비티의 View hierachy에서 제거된 프레그먼트의 UI를 수정합니다. 생각해보면 특별한 경우가 아니고 앱 개발 시 굉장히 자주 있는 시나리오입니다.</p><p>두 번째는 워커 쓰레드에서 액티비티의 레퍼런스를 갖고 있는 경우 입니다. 이렇게 되면 해당 액티비티는 워커 쓰레드가 종료될 때까지 가비지 컬렉터에 의해 제거 될 수 없습니다. 워커 쓰레드가 종료되기 전에 configuration change 이벤트가 발생하거나 하면 동일한 액티비티가 여러개 생길 수도 있는 상황이 발생합니다.</p><p>워커 쓰레드에서 액티비티의 레퍼런스를 직접 갖고 있지 않은 경우에도 문제가 생길 수 있습니다. 액티비티에 내부 클래스로 AsyncTask를 선언하고 사용하는 경우입니다. 내부 클래스는 외부 클래스에 대한 암시적 참조를 갖기 때문에 위의 상황처럼 AsyncTask가 종료 될 때가지 액티비티는 가비지 컬렉터에 의해 제거되지 않습니다.</p><p>여기서 암시적 참조라는 말이 조금 어렵게 느껴질 수 있는데, 내부 클래스는 외부 클래스의 멤버 변수를 참조 할 수 있습니다. 어떻게 이게 가능할까요? 직접 내부 클래스에 외부 클래스의 레퍼런스를 참조하는 코드를 작성하지 않더라도 자바는 내부 클래스에 대한 참조를 생성하기 때문입니다. 이것을 바로 암시적 참조라고 합니다.</p><p>아래 예제 코드는 암시적 참조에 의한 메모리 릭의 예를 보여줍니다. 아래 코드에서, doInBackground()에서 어떤 작업을 하고 있는 동안은 MyActivity는 메모리에 계속 남아있게 됩니다. 또한 화면 방향 전환이나 단말의 언어설정 변경 등에 의해 액티비티가 재시작이 되면 동일한 액티비티가 여러 개 생성될 수도 있으며, 액티비티가 종료된 후에 onPostExecute()에서 유효하지 않은 액티비티내의 객체나 UI 요소에 대한 상태를 변경하면 예기치 못한 동작이 발생할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView mText;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        mText = findViewById(R.id.text);</span><br><span class="line">        <span class="keyword">new</span> MyAsyncTask().execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyAsyncTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Void</span>, <span class="title">Void</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mText.setText(<span class="string">"MyAsyncTask.onPreExecute()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> String <span class="title">doInBackground</span><span class="params">(Void... voids)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"MyAsyncTask.doInBackground() is finished"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            mText.setText(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>마지막으로 안드로이드 개발을 시작한지 얼마 안된 사람들이 쉽게 착각하는 것 중 하나는 액티비티와 쓰레드의 생명주기가 동일하다고 착각하는 것입니다. 하지만 액티비티의 생명주기와 쓰레드의 생명주기는 관계가 없습니다. 쓰레드가 특정 액티비티에서 생성이 되고 해당 액티비티가 종료되어도 이 쓰레드는 이와 상관없이 실행됩니다.</p><p>이를 제대로 이해하지 못하면 첫 번째로 언급한 이슈가 발생하기 쉽습니다. 이런 실수를 하게되면 결국 앱은 비정상 종료를 하게 됩니다.</p><p><img src="https://developer.android.com/topic/performance/images/crash-example-framed.png" alt="Crash"></p><h2 id="3-마무리">3. 마무리</h2><p>이번 포스팅에서는 안드로이드의 프로세스와 쓰레드에 대해 개념적인 내용들을 정리해 보았습니다.</p><p>이를 정리하자면 아래와 같습니다.</p><ol><li>메인 쓰레드는 사용자 이벤트, 드로잉 이벤트 등을 처리하는 매우 중요한 쓰레드이며 여기서 시간이 오래 걸리는 일을 하면 앱이 끊기거나 먹통이 될 수 있다.</li><li>1과 같은 이유로 많은 시간이 걸리는 작업은 새로 쓰레드를 만들어서 처리해주어야 하며 이를 워커 쓰레드라 부른다.</li><li>사람이 느낄 수 있는 가장 부드러운 수치는 60fps 정도 이기 때문에 안드로이드에서도 앱 개발 시 60fps를 유지하도록 권장한다. 이를 위해 메인 쓰레드에서는 16ms 이상 걸리는 작업을 하지 않는다.</li><li>워커 쓰레드에 액티비티나 View의 레퍼런스를 갖는 것은 메모리 릭과 앱의 비정상 종료를 일으킬 수 있기 때문에 매우 위험하다.</li></ol><p>개인적으로 안드로이드 앱 개발 시 가장 중요하다고 생각하는 부분이기도 합니다. 다음에는 좀 더 구체적으로 쓰레드에 대해 자세히 알아보고 상황에 따라 어떤 방식으로 쓰레드를 사용해야 하는지 다뤄보도록 하겠습니다.</p><h2 id="참고자료">참고자료</h2><ul><li><a href="https://developer.android.com/topic/performance/vitals/anr">ANRs</a></li><li><a href="https://developer.android.com/topic/performance/vitals/crash">Crashes</a></li><li><a href="https://developer.android.com/guide/platform/">Platform architecture</a></li><li><a href="https://developer.android.com/guide/components/fundamentals">App components</a></li><li><a href="(https://developer.android.com/guide/components/processes-and-threads)">Process and thread</a></li><li><a href="https://youtu.be/0Z5MZ0jL2BM">Perfmatter - Understanding Android Threading</a></li><li><a href="https://developer.android.com/topic/performance/vitals/render">Slow rendering</a></li></ul>]]></content:encoded>
      
      <comments>https://jeongmin.github.io/2018/06/28/android/android-process-thread/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이맥스(Emacs) Org 모드 - 1. 시작하기</title>
      <link>https://jeongmin.github.io/2017/11/15/emacs/emacs-org-mode-introduction/</link>
      <guid>https://jeongmin.github.io/2017/11/15/emacs/emacs-org-mode-introduction/</guid>
      <pubDate>Tue, 14 Nov 2017 15:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;https://orgmode.org/img/main.jpg&quot; alt=&quot;Preview of Org mode&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;들어가며&quot;&gt;들어가며&lt;/h2&gt;
&lt;p&gt;Org 모드는 이맥스를 이용해 문서를 작성하거나 일정관리를 할 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="https://orgmode.org/img/main.jpg" alt="Preview of Org mode"></p><h2 id="들어가며">들어가며</h2><p>Org 모드는 이맥스를 이용해 문서를 작성하거나 일정관리를 할 수 있도록 도와주는 모드입니다. 위의 그림과 같이 생각을 구조적으로 정리하고 타임스탬프를 이용해 일정을 관리할 수 있습니다.</p><p>또한 이렇게 작성된 문서는 다양한 형태의 포맷으로 변환이 가능합니다.</p><p>Org 모드의 기능은 아주 많기 때문에 이번 포스팅에서는 Org 모드의 가장 기본이 되는 요소들에 대해 먼저 알아보고 이어지는 포스팅을 통해 점차 Org 모드의 세부 기능에 대해 알아보도록 하겠습니다.</p><p>이 포스팅에 있는 내용은 대부분 <a href="https://orgmode.org/">Org 모드 공식 페이지</a>의 메뉴얼과 가이드를 가지고 정리한 것으로, 자세한 내용은 공식 홈페이지를 참고하시면 됩니다.</p><h2 id="이맥스의-Org-모드가-갖는-장점">이맥스의 Org 모드가 갖는 장점</h2><h5 id="1-문서작성">1. 문서작성</h5><p>이맥스 자체는 텍스트 편집기이기 때문에 사람이 보기 좋게 서식을 갖추어 바로 보기는 어렵습니다. 하지만 이렇게 서식을 신경쓰지 않아도 되기 때문에 문서의 외형보다는 __내용__에 집중해서 문서를 작성할 수 있도록 해줍니다.</p><p>게다가 이렇게 Org 모드를 통해 작성한 문서는 HTML, PDF, LaTeX, Markdown, OpenDocument 등 다양한 형식으로 변환이 가능하기 때문에 결국 서식에 있어서도 워드프로세서에 비해 훨씬 확장성이 크다 할 수 있습니다.</p><p>데이터와 모양(서식)을 분리한게 마치 HTML과 CSS 관계랑 비슷하죠? 또한 문서 자체가 텍스트 이기 때문에 용량도 작고 OS나 특정 워드프로세서와 같은 소프트웨어 종속적이지 않다는 장점도 가집니다.</p><h5 id="2-일정관리">2. 일정관리</h5><p>일정 관리에 있어서도 Org 모드는 할 일 목록(ToDO), 타임스탬프, 링크, 아젠다 뷰, 달력 등을 이용해 손쉽게 일정을 관리 할 수 있는 다양한 기능을 제공합니다. 이런 기능들은 이맥스 특유의 단축키 시스템과 결합되어 사용자에게 엄청난 생산성을 가져다 줍니다.</p><h2 id="시작하기">시작하기</h2><p>Org 모드는 확장자가 .org인 파일을 열면 자동으로 활성화 되는 메이저 모드입니다. 직접 Org 모드를 활성화 시키고 싶으면 <code>M-x org-mode&lt;RET&gt;</code> 키를 입력하면 됩니다.</p><p>만약 Org 모드가 설치되어 있지 않다면 아래와 같이 org 모드를 설치합니다.<br><br><code>M-x package-install RET org RET</code></p><h3 id="헤드라인-Headlines">헤드라인(Headlines)</h3><p>Org 모드의 시작은 헤드라인과 함께 합니다. 헤드라인은 위의 스크린 샷에서 <code>*</code>로 시작하는 줄입니다. 헤드라인은 단락과도 비슷합니다. 들여쓰기와 <code>*</code>의 개수는 단락의 레벨을 나타냅니다. 헤드라인을 이용해서 __트리 구조__로 문서를 작성할 수 있습니다. <code>M-RET</code>를 통해 헤드라인을 추가할 수 있으며, 헤드라인이 있는 줄에서 <code>M-방향키</code>를 입력하면 레벨과 위치를 조절 할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* Top level headline</span><br><span class="line">    ** Second level</span><br><span class="line">    *** 3rd level</span><br><span class="line">        some text</span><br><span class="line">    *** 3rd level</span><br><span class="line">        more text</span><br><span class="line">     </span><br><span class="line">    * Another top level headline</span><br></pre></td></tr></table></figure><h3 id="할-일-목록-TODO-Items">할 일 목록(TODO Items)</h3><p>헤드라인은 모두 할 일이 될 수 있습니다. 할 일이 되기 위해서는 헤드라인이 __TODO__로 시작하면 됩니다. 헤드라인에서 <code>S-&lt;LEFT&gt;</code> 또는 <code>S-&lt;RIGHT&gt;</code>를 입력하면 <code>헤드라인 -&gt; TODO -&gt; DONE</code> 세 가지 상태로 쉽게 전환할 수 있습니다.</p><h3 id="플레인-리스트-Plain-lists">플레인 리스트(Plain lists)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">** Lord of the Rings</span><br><span class="line">   My favorite scenes are (in this order)</span><br><span class="line">   1. The attack of the Rohirrim</span><br><span class="line">   2. Eowyn&#39;s fight with the witch king</span><br><span class="line">      + this was already my favorite scene in the book</span><br><span class="line">      + I really like Miranda Otto.</span><br><span class="line">   3. Peter Jackson being shot by Legolas</span><br><span class="line">      - on DVD only</span><br><span class="line">      He makes a really funny face when it happens.</span><br><span class="line">   But in the end, no individual scenes matter but the film as a whole.</span><br><span class="line">   Important actors in this film are:</span><br><span class="line">   - Elijah Wood :: He plays Frodo</span><br><span class="line">   - Sean Astin :: He plays Sam, Frodo&#39;s friend.  I still remember</span><br><span class="line">     him very well from his role as Mikey Walsh in The Goonies.</span><br></pre></td></tr></table></figure><p>헤드라인이 단락과 같은 역할을 한다면 플레인 리스트는 단락에서 리스트를 표현하는데 사용됩니다. 또한 플레인 리스트는 이후 설명할 체크박스(Checkboxes)에도 사용됩니다.</p><p>플레인 리스트는 크게 순서가 있는 리스트, 순서가 없는 리스트, 디스크립션 리스트로 나눌 수 있습니다.</p><ul><li><p>순서가 없는 리스트<br><code>-</code>나 <code>+</code>, <code>*</code>로 시작합니다. 여기서 <code>*</code>는 위치에 따라 헤드라인이 되기도 하고 플레인 리스트가 되기도 하기 때문에 혼동을 줄이기 위해 <code>-</code>나 <code>+</code>를 사용하는게 좋습니다.</p></li><li><p>순서가 있는 리스트<br><code>1.</code> 이나 <code>1)</code> 처럼 숫자에 <code>.</code>이나 <code>)</code>를 붙여서 표현합니다. 만약 20과 같은 숫자로 시작하고 싶다면 <code>[@20]</code>과 같이 사용하면 됩니다.</p></li><li><p>디스크립션 리스트<br>디스크립션 리스트는 정의를 표현하기 위해 사용며 순서가 없는 리스트에 <code>::</code>를 이용해서 표현합니다… 사전을 생각하면 쉬운데, <code>::</code>를 기준으로 왼쪽에는 단어, 오른쪽에는 설명을 적는다고 생각하면 쉬울 것 같습니다.</p></li></ul><p>플레인 리스트에서 <code>S-&lt;LEFT&gt;</code> 또는 <code>S-&lt;RIGHT&gt;</code> 키를 입력하면 리스트의 형태가 바뀌고 <code>M-&lt;RET&gt;</code>를 입력하면 새로운 플레인 리스트 아이템을 추가할 수 있습니다.</p><h3 id="체크박스-Checkboxes">체크박스(Checkboxes)</h3><p>플레인 리스트 안에 있는 아이템은 체크박스를 가질 수 있습니다. 체크박스를 사용하는건 간단합니다. 아이템의 맨 앞에 <code>[ ]</code>를 삽입하면 됩니다. 단축키로는 <code>M-S-&lt;RET&gt;</code>를 사용합니다.</p><p>체크박스에 체크를 하거나 체크를 해제하는건 <code>C-c C-c</code> 단축키를 사용합니다.</p><p>또한 체크박스가 있는 아이템의 부모는 진행 사항을 알 수 있습니다. 부모 아이템의 마지막 줄에 <code>[/]</code>을 넣으면 <code>[2/4]</code>와 같은 형태로, <code>[%]</code>를 넣으면 <code>[50%]</code>와 같은 형식으로 진행 사항을 보여줍니다.</p><p>아래는 체크박스의 예입니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* TODO Organize party [2&#x2F;4]</span><br><span class="line">  - [-] call people [1&#x2F;3]</span><br><span class="line">    - [ ] Peter</span><br><span class="line">    - [X] Sarah</span><br><span class="line">    - [ ] Sam</span><br><span class="line">  - [X] order food</span><br><span class="line">  - [ ] think about what music to play</span><br><span class="line">  - [X] talk to the neighbors</span><br></pre></td></tr></table></figure><h3 id="접기-펼치기-Folding-and-Expanding">접기/펼치기(Folding and Expanding)</h3><p>헤드라인이나 플레인 리스트는 <code>&lt;TAB&gt;</code>키를 통해 접기와 펼치기가 가능합니다.</p><h2 id="마무리">마무리</h2><p>이번 포스팅에서는 간단히 Org 모드에 대한 설명과 기본 구성요소에 대해 정리 알아 보았습니다. 다음 포스팅에서는 Org 모드를 이용한 일정관리에 대해 조금 더 자세히 알아보도록 하겠습니다.</p><h2 id="참고자료">참고자료</h2><p><a href="https://orgmode.org/">Org 모드 공식 페이지</a><br><br>Org 모드의 기능에 대한 모든 설명을 볼 수 있습니다.</p>]]></content:encoded>
      
      <comments>https://jeongmin.github.io/2017/11/15/emacs/emacs-org-mode-introduction/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이맥스(Emacs) Org 모드</title>
      <link>https://jeongmin.github.io/2017/11/15/emacs/emacs-org-mode-intro/</link>
      <guid>https://jeongmin.github.io/2017/11/15/emacs/emacs-org-mode-intro/</guid>
      <pubDate>Tue, 14 Nov 2017 15:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;이맥스는 쓰면 쓸수록 매력있는 텍스트 에디터입니다. 이맥스로 할 수 있는게 아주 많습니다. 대부분의 사람들이 이맥스를 프로그래밍 할 때 사용하지만 &lt;strong&gt;Org 모드를 이용하면 일정관리, 메모, 문서작성에도 요긴하게 쓸 수 있습니다.&lt;/s
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>이맥스는 쓰면 쓸수록 매력있는 텍스트 에디터입니다. 이맥스로 할 수 있는게 아주 많습니다. 대부분의 사람들이 이맥스를 프로그래밍 할 때 사용하지만 <strong>Org 모드를 이용하면 일정관리, 메모, 문서작성에도 요긴하게 쓸 수 있습니다.</strong> 이 글에서는 Org 모드 중 일정관리에 대한 부분을 중점적으로 살펴보도록 하겠습니다.</p><h2 id="들어가며">들어가며</h2><p>아래는 Org 모드가 어떤 것인지 한눈에 볼 수 있는 이미지입니다.</p><p><img src="https://orgmode.org/img/main.jpg" alt="Preview of Org mode"></p><h2 id="시작하기">시작하기</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">global-set-key</span> <span class="string">"\C-c l"</span> 'org-store-link)</span><br><span class="line">(<span class="name">global-set-key</span> <span class="string">"\C-c a"</span> 'org-agenda)</span><br><span class="line">(<span class="name">global-set-key</span> <span class="string">"\C-c c"</span> 'org-capture)</span><br><span class="line">(<span class="name">global-set-key</span> <span class="string">"\C-c b"</span> 'org-iswitchb)</span><br></pre></td></tr></table></figure><h3 id="헤드라인">헤드라인</h3><p>Org 모드의 시작은 헤드라인과 함께 합니다. 헤드라인은 위의 스크린 샷에서 <code>*</code>로 시작하는 줄입니다. 헤드라인은 단락과도 비슷한데, 들여쓰기와 함께 문서를 __트리 구조__로 작성할 수 있게 합니다. <code>M-RET</code>를 통해 추가할 수 있으며 헤드라인이 있는 줄에서 <code>M-방향키</code>를 입력하면 레벨과 위치를 조절 할 수 있습니다.</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* Top level headline</span><br><span class="line">    ** Second level</span><br><span class="line">    *** <span class="number">3</span>rd level</span><br><span class="line">        some text</span><br><span class="line">    *** <span class="number">3</span>rd level</span><br><span class="line">        more text</span><br><span class="line">     </span><br><span class="line">    * Another top level headline</span><br></pre></td></tr></table></figure><h3 id="할-일-목록-TODO-Items">할 일 목록(TODO Items)</h3><p>헤드라인은 모두 할 일이 될 수 있습니다. 할 일이 되기 위해서는 헤드라인이 _TODO_로 시작하면 됩니다. 헤드라인에서 <code>S-&lt;LEFT&gt;</code> 또는 <code>S-&lt;RIGHT&gt;</code>를 입력하면 헤드라인 -&gt; TODO -&gt; DONE의 세 가지 상태로 쉽게 전환할 수 있습니다.</p><h3 id="시간과-날짜-Date-and-Times">시간과 날짜(Date and Times)</h3><p>일정관리에는 시간이 중요합니다. 일정은 특정한 날까지 수행해야 하는 일, 일정한 주기로 반복적으로 일어나는 일, 언제부터 언제까지와 같은 일정 날짜 사이에 해야하는 일 등 시간 엮이는 경우가 많습니다.</p><p>Org 모드에서 각각의 할 일은 타임스탬프 레이블을 통해 관리 할 수 있습니다. 타임스탬프는 할 일 목록에만 붙는게 아니라 Org 트리에 있는 엔트리에 모두 붙을 수 있습니다.</p><h4 id="일반-시간-이벤트-일정">일반 시간, 이벤트, 일정</h4><p>특정한 이벤트나 일정이 열시는 시간을 나타냅니다.</p><pre>     * Meet Peter at the movies       <2006-11-01 Wed 19:15>     * Discussion on climate change       <2006-11-02 Thu 20:00-22:00></pre><h4 id="반복되는-시간">반복되는 시간</h4><p>일정한 주기로 반복되는 일을 나타냅니다.</p><pre>     * Pick up Sam at school       <2007-05-16 Wed 12:30 +1w></pre><h4 id="Diary-style-sexp-entries">Diary-style sexp entries</h4><pre>     * The nerd meeting on every 2nd Thursday of the month       <%%(diary-float t 4 2)></pre><h4 id="시간-범위">시간 범위</h4><p>시간 범위를 나타냅니다. '–'로 두 타임스탬프를 연결하는 형태로 표현합니다.</p><pre>     ** Meeting in Amsterdam        <2004-08-23 Mon>--<2004-08-26 Thu></pre><h4 id="비활성-타임스탬프">비활성 타임스탬프</h4><p>아젠다에 나타나지 않는 시간입니다. ‘[’ ~ ']'로 표현되며 할 일을 완료해서 DONE이 되면 나타나는 시간입니다.</p><pre>     * Gillian comes late for the fifth time       [2006-11-01 Wed]</pre><h3 id="태그-Tags">태그(Tags)</h3><p>헤드라인에 서로 연관있는 정보나 추가 정보를 기입하기 위해 태그를 사용할 수 있습니다. 태그는 헤드라인의 끝에 들어가며 여러 태그를 같이 달 수 있습니다. 태그는 문자와 숫자,  <code>_</code>, <code>@</code>로 구성되며 <code>:</code>와 <code>:</code>로 감싸야합니다. 아래는 태그의 예 입니다.</p><p>또한 태그는 상속이 됩니다. 아래 예에서 두 번째 레벨의 헤드라인은 :work:boss:notes: 태그를 갖게 되고 세 번째 레벨의 헤드라인은 :work:boss:notes:action: 태그를 갖게 됩니다.</p><pre>     * Meeting with the French group      :work:     ** Summary by Frank                  :boss:notes:     *** TODO Prepare slides for him      :action:</pre><p>태그는 파일 단위로도 달 수 있습니다. 아래와 같이 문서에 <code>#+FILETAGS:</code>를 이용하면 파일 전체에 태그가 적용됩니다.</p><blockquote><p>#+FILETAGS: :Peter:Boss:Secret:</p></blockquote><p>Enter new tags for the current headline. Org mode will either offer completion or a special single-key interface for setting tags, see below. After pressing <RET>, the tags will be inserted and aligned to org-tags-column. When called with a C-u prefix, all tags in the current buffer will be aligned to that column, just to make things look nice.</p><h3 id="아젠다-Agenda">아젠다(Agenda)</h3><h2 id="기능">기능</h2><p><a href="https://orgmode.org/features.html">Feature list</a></p><h2 id="일정관리-Todo">일정관리(Todo)</h2><h2 id="팁">팁</h2><p>C-c C-c<br>When the cursor is in a headline, this does the same as C-c C-q.</p><ul><li>헤드라인에서 입력하는 경우 : 태그 입력</li><li>타임스탬프에서 입력하는 경우 : 타임스탬프 수정</li></ul><p>org-support-shift-select</p><h2 id="자주쓰는-단축키">자주쓰는 단축키</h2><h6 id="태그-단축키">태그 단축키</h6><p>단축키    | 명령어               | 설명<br>—       | —                 |<br>C-c C-q | C-c C-q | 현재 엔트리에 태그를 추가합니다</p><h6 id="할-일-목록-단축키">할 일 목록 단축키</h6><p>단축키    | 명령어               | 설명<br>—       | —                 |<br>C-c C-t | org-todo | 헤드라인을 할일, 완료, 상태없음(unmarked)로 변경<br>S-<right>/<left> | org-shift-right / org-shift-left | 헤드라인을 할일, 완료, 상태없음(unmarked)로 변경<br>C-c / t  |       | 모든 할일 목록을 보여준다<br>S-M-<RET> | org-insert-todo-heading | 현재 헤드라인과 동일한 레벨에 할일 목록을 추가한다.</p><h6 id="아젠다-단축키">아젠다 단축키</h6><p>단축키    | 명령어               | 설명<br>—       | —                 |<br>C-c [ | org-agenda-file-to-front | 현재 파일을 아젠다 목록에 추가<br>C-c ] | org-remove-file | 현재 파일을 아젠다 목록에서 제거<br>C-,  |org-cycle-agenda-files | org-agenda-files 목록에 있는 아젠다 파일 순회<br>C-c C-d  |org-deadline | 데드라인 타임스탬프 추가</p>]]></content:encoded>
      
      <comments>https://jeongmin.github.io/2017/11/15/emacs/emacs-org-mode-intro/#disqus_thread</comments>
    </item>
    
    <item>
      <title>이맥스(Emacs) 패키지 관리</title>
      <link>https://jeongmin.github.io/2017/11/09/emacs/emacs-package/</link>
      <guid>https://jeongmin.github.io/2017/11/09/emacs/emacs-package/</guid>
      <pubDate>Wed, 08 Nov 2017 15:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1&gt;이맥스 설정&lt;/h1&gt;
&lt;h2 id=&quot;개요&quot;&gt;개요&lt;/h2&gt;
&lt;p&gt;이맥스가 실행되면 이맥스는 초기화 파일로부터 Lisp 프로그램들을 로드합니다. 초기화 파일은 아래 세 가지 중에 하나를 선택해서 사용하면 됩니다.&lt;br&gt;
&lt;code&gt;~/.emacs,
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1>이맥스 설정</h1><h2 id="개요">개요</h2><p>이맥스가 실행되면 이맥스는 초기화 파일로부터 Lisp 프로그램들을 로드합니다. 초기화 파일은 아래 세 가지 중에 하나를 선택해서 사용하면 됩니다.<br><code>~/.emacs, ~/.emacs.el, or ~/.emacs.d/init.el</code></p><h2 id="패키지">패키지</h2><p>이맥스 24 이후부터 패키지 설치는 거의 ELPA를 사용합니다. 기존에 직접 패키지를 다운받아서 설치하던 방식에서 패키지 매니저를 통해 패키지들을 간편하게 설치 할 수 있게 된거죠.</p><p>여기서 ELPA는 이맥스 패키지들이 올라가있는 저장소입니다. 따로 설정을 해주지 않아도 이맥스 버전 24부터는 기본으로 ELPA 패키지 저장소가 설정되어있습니다.</p><p>패키지 저장소는 ELPA외에 다른 것들도 있는데 보통 MELPA를 많이 사용합니다. 저장소를 추가로 세팅하는 방법은 아래와 같습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(require &#39;package)</span><br><span class="line">(add-to-list &#39;package-archives &#39;(&quot;melpa&quot; . &quot;https:&#x2F;&#x2F;melpa.org&#x2F;packages&#x2F;&quot;))</span><br></pre></td></tr></table></figure><h3 id="패키지-설치">패키지 설치</h3><p><code>M-x list-package</code> 명령어를 입력하면 아래와 같이 패키지 목록을 볼 수 있습니다. 여기에 있는 패키지 목록이 바로 ELPA에 등록된 패키지입니다. 만약 MELPA와 같은 저장소를 위와 같은 방법으로 추가했다면 해당 저장소에 있는 패키지도 함께 보여집니다.</p><p><img src="/assets/img/emacs/emacs-packages.png" alt="list of packages"></p><h3 id="패키지-로딩">패키지 로딩</h3><p><code>load-path</code> 변수에는 이맥스가 설치된 패키지를 로드할 때 패키지를 검색하는 디렉토리 목록이 저장됩니다. <code>M-x describe-variable</code> 명령어를 통해 <code>load-path</code> 변수의 값을 볼 수 있습니다.</p><p>사용하려고 하는 패키지가 <code>load-path</code>에 포함되어 있지 않으면 로딩을 실패합니다.</p><h3 id="패키지-커스터마이징">패키지 커스터마이징</h3><p>패키지를 설치 했으면 이제 내 손맛에 맞게 커스터마이징을 합니다. 커스터마이징이라 하면 단축키, 자동 로딩 등이 있겠죠. 자동 로딩은 설치한 패키지가 이맥스가 시작 될 때 자동으로 로딩되도록 해주는 것입니다. 설치한 패키지가 필요할 때 마다 매번 패키지를 로드하는건 너무 불편하겠죠? :)</p><h2 id="유용한-함수">유용한 함수</h2><table><thead><tr><th>함수</th><th>단축키</th><th>설명</th></tr></thead><tbody><tr><td>describe-function</td><td>-</td><td>elisp 함수의 설명을 보여줌</td></tr><tr><td>describe-key</td><td>-</td><td>현재 맵핑된 단축키에 대한 설명을 보여줌</td></tr><tr><td>describe-mode</td><td>-</td><td>현재 모드의 키바인딩 목록을 볼 수 있음</td></tr><tr><td>describe-variable</td><td>-</td><td>elisp 변수에 대한 설명을 보여줌</td></tr></tbody></table><h2 id="단축키">단축키</h2><p>이맥스 커맨드는 Lisp 함수입니다. 보통 소문자와 하이픈으로된 이름을 가집니다. 이맥스는 이런 커맨드를 다양한 단축키로 제공합니다. 단축키가 잘 정의되어 있고 이를 잘 사용하면 엄청난 생산성을 가질 수 있습니다. 그리고 이는 곧 사람들이 이맥스를 사용하는 가장 큰 이유가됩니다.</p><p>따라서 단축키를 익히고 커스터마이징 하는건 이맥스 사용자에게 가장 중요한 일중에 하나입니다.</p><h3 id="키맵-Keymaps">키맵(Keymaps)</h3><p>이맥스의 단축키는 키맵을 통해 제공됩니다. 키맵은 전역 키맵(Global keymap) XXX 키맵으로 구성됩니다. 전역 키맵은 이맥스의 기본 모드(Fundamental mode)의 키맵을 정의합니다.</p><p>이맥스의 단축키는 키(keys)와 문자(characters)로 구성됩니다. 여기서 키는 컨트롤(Ctrl), 메타(Alt or Meta), 펑션키(<HOME>, <INSERT>, …)를 말하고 문자는 알파벳과 특수문자들을 생각하면 됩니다.</p><p>또한 이맥스에는 메이저 모드와 마이너 모드가 있는데요. 각 모드는 자신만의 키맵을 정의해서 사용할 수 있습니다.</p><h3 id="키맵-커스터마이징">키맵 커스터마이징</h3><h4 id="글로벌-키맵-Global-Keymap">글로벌 키맵(Global Keymap)</h4><p><code>M-x global-set-key</code>를 이용해 글로벌 키맵의 키를 재정의 할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(global-set-key [f9] &#39;gud-break)</span><br></pre></td></tr></table></figure><h4 id="로컬-키맵-Local-Keymaps">로컬 키맵(Local Keymaps)</h4><h4 id="미니버퍼-맵">미니버퍼 맵</h4><h2 id="마크다운-모드">마크다운 모드</h2><p>링크 : <a href="https://jblevins.org/projects/markdown-mode/">https://jblevins.org/projects/markdown-mode/</a><br>메뉴얼 : <a href="https://leanpub.com/markdown-mode">https://leanpub.com/markdown-mode</a></p><p>외부 모듈로 <a href="http://Markdown.pl">Markdown.pl</a>, MultiMarkdown, Pandoc 중 하나를 설치해야한다.</p><h3 id="프리뷰-모드">프리뷰 모드</h3><p>마크다운 문서를 웹브라우저를 통해 바로 보려면 markdown-preview 모드를 사용하면 된다. 다만 마크다운 문서는 기본적으로 html로 변환을 거쳐야 하기 때문에 이 작업을 해줄 프로그램이 필요하다. 마크다운 모드에서는 <a href="http://Markdown.pl">Markdown.pl</a>, MultiMarkdown, Pandoc 중 하나를 사용한다고 한다.</p><p>Debian 계열의 리눅스에서는 MultiMarkdown을 아래와 같이 설치 할 수 있다.</p><blockquote><p>sudo apt-get install libtext-multimarkdown-perl</p></blockquote><h2 id="모드">모드</h2><p>이맥스는 다양한 편집 모드를 가집니다. 모드는 메이저 모드와 마이너 모드로 나눠집니다.</p><h3 id="메이저-모드-Major-mode">메이저 모드(Major mode)</h3><p>메이저 모드는 C 소스파일과 같이 특정한 파일 타입을 편집할 때나 쉘 버퍼와 같은 특정 타입의 버퍼에 대해 동작합니다. 메이저 모드는 한번에 하나의 모드만 동작할 수 있습니다.</p><p>모든 버퍼는 하나의 메이저 모드를 가집니다. 현재 메이저 모드는 아래 그림과 같이 이맥스 창 하단에서 확인 할 수 있습니다.</p><p><img src="/assets/img/emacs/mode.png" alt="mode line"></p><p>가장 기본적인 최소한의 메이저 모드는 펀드멘털 모드로 불립니다. 이 모드는 특정 모드에 한정된 재정의나 변수 설정을 갖지 않기 때문에 가장 기본적인 이맥스의 상태로 동작합니다.</p><p>대부분의 메이저 모드는 세개의 메이저 그룹으로 나눌 수 있습니다. 첫 번째 그룹은 플레인 텍스트나 마크업 텍스트를 가집니다. 여기에는 텍스트 모드, HTML 모드, SGML 모드, TeX 모드, 아웃라인 모드가 있습니다. 두 번째 그룹은 프로그래밍 언어들을 포함합니다. Lisp, C, Fortran 등등의 모드를 갖습니다. 세 번째 그룹은 파일의 형식과 관련이 없는 모드들을 갖습니다. Dired, Message, Shell 모드 등입니다.</p><p>메이저 모드는 보통 이맥스에 의해 파일이나 버퍼가 생성될 때 자동으로 설정됩니다. 모드를 바꾸고 싶을때는 <code>M-x</code> 뒤에 <code>-mode</code>를 붙여서 변경할 수 있습니다. (ex&gt; `M-x lisp-mode). 모든 버퍼는 하나의 메이저 모드를 갖기 때문에 메이저모드를 다른걸로 바꿀 수는 있어도 끌 수는 없습니다.</p><p>각 버퍼의 로컬 변수인 <code>major-mode</code>는 메이저 모드의 커맨드를 이름으로 갖습니다. 예를 들어 <code>M-x lisp-mode</code>를 통해 Lisp 메이저 모드를 선택했다면 <code>major-mode</code> 변수에는 <code>list-mode</code>가 자동으로 설정됩니다.</p><p><code>major-mode</code>의 기본 값은 정해진 메이저 모드가 없는 버퍼에 대해 설정되는 모드입니다. 보퐁 이 기본 값은 <code>fundamental-mode</code>입니다. 이 기본 값을 변경하고 싶으면 아래와 같이 하면 됩니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(setq-default major-mode &#96;text-mode)</span><br></pre></td></tr></table></figure><p>만약 <code>major-mode</code>의 기본값이 nil이면 메이저 모드는 이전 버퍼의 모드를 따라갑니다.</p><p>특정 메이저 모드는 보통 모드에 맞게 특정 키, 사용자 옵션, 변수 등을 변경합니다. 예를 들면 보통 프로그래밍 언어 모드에서는 <TAB>을 해당 언어의 가이드에 맞추어 들여쓰기 해주도록 합니다. 그리고 버퍼 로컬 변수인 <code>comment-start</code>를 수정하기도 합니다. 이 변수는 언어에 따른 주석의 형태를 정의합니다.</p><blockquote><p>*현재 설정된 메이저 모드에 대한 문서를 보려면 <code>M-x describe-mode</code>를 사용합니다. 모드에 대한 자세한 설명과 키 바인딩을 모두 확인할 수 있습니다.</p></blockquote><p>기본 모드를 제외한 모든 메이저 모드는 모드가 활성화 될 때마다 실행되는 커스터마이징이 가능한 List 함수의 목록을 모드 훅(mode hook)으로 정의합니다.</p><p>아래는 c+±mode의 훅입니다. 훅의 이름은 <code>모드명-hook</code>입니다. 또한 모든 텍스트 기반의 메이저 모드는 <code>text-mode-hook</code>을, 많은 수의 프로그래밍 언어 모드는 <code>prog-mode-hook</code>을 각각의 메이저 모드가 갖는 훅을 실행 시키기 전에 실행합니다.</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">add-hook</span> 'c++-mode-hook</span><br><span class="line">  '(lambda ()</span><br><span class="line">     (c-set-style <span class="string">"linux"</span>)))</span><br></pre></td></tr></table></figure><p>메이저 모드의 훅은 마이너 모드의 훅들을 활성화 시키기 위해 자주 사용됩니다. 아래의 코드는 <code>text-mode</code>에 진입할 때 <code>flyspell-mode</code> 마이너 모드를 활성화 시키고 있습니다.</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">add-hook</span> 'text-mode-hook 'flyspell-mode)</span><br></pre></td></tr></table></figure><h3 id="마이너-모드-Minor-mode">마이너 모드(Minor mode)</h3><p>마이너 모드는 내가 원할때 켜고 끌 수 있습니다. 또한 특정한 타입의 파일이나 버퍼에 구분없이 동작 할 수 있습니다. 마이너 모드는 다른 메이저 모드나 마이너 모드에 대해 독립적입니다.</p><p>버퍼 로컬 마이너 모드는 활성화 된 버퍼에서만 동작합니다. 반면 글로벌 마이너 모드는 모든 버퍼에서 동작합니다.</p><h2 id="자동완성">자동완성</h2><p>설치 : <a href="https://github.com/auto-complete/auto-complete">https://github.com/auto-complete/auto-complete</a><br>메뉴얼 : <a href="https://github.com/auto-complete/auto-complete/blob/master/doc/manual.md">https://github.com/auto-complete/auto-complete/blob/master/doc/manual.md</a></p><h2 id="참고자료">참고자료</h2><p><a href="https://www.emacswiki.org/emacs?SiteMap">EmacsWiki</a><br><br>이맥스 영문 위키 페이지입니다. 이맥스 사용자에겐 여기가 보물 창고!</p>]]></content:encoded>
      
      <comments>https://jeongmin.github.io/2017/11/09/emacs/emacs-package/#disqus_thread</comments>
    </item>
    
    <item>
      <title>안드로이드 ENUM과 Typedef 어노테이션(Annotation)</title>
      <link>https://jeongmin.github.io/2017/10/08/android/android-enum-intdef/</link>
      <guid>https://jeongmin.github.io/2017/10/08/android/android-enum-intdef/</guid>
      <pubDate>Sat, 07 Oct 2017 15:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;이 글은 ENUM 사용 시 주의할 점과 어노테이션을 통해 이를 보완할 수 있는 방법에 대해 정리한 글입니다.&lt;/p&gt;
&lt;p&gt;주로 참고한 자료는 유튜브 perfmatter 시리즈 중 &lt;a href=&quot;https://youtu.be/Hzs6OBcvNQE
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>이 글은 ENUM 사용 시 주의할 점과 어노테이션을 통해 이를 보완할 수 있는 방법에 대해 정리한 글입니다.</p><p>주로 참고한 자료는 유튜브 perfmatter 시리즈 중 <a href="https://youtu.be/Hzs6OBcvNQE">The price of ENUMs (100 Days of Google Dev)</a> 영상과 <a href="https://developer.android.com/studio/write/annotations.html">Improve Code Inspection with Annotations</a> 문서입니다.</p><h2 id="안드로이드-앱-실행-시-메모리-할당">안드로이드 앱 실행 시 메모리 할당</h2><p>ENUM 사용 시 주의점을 알기 전에 먼저 안드로이드 앱 실행 시 메모리가 어떻게 할당되는지 간단히 짚고 넘어가겠습니다.</p><p>앱을 실행시키면 안드로이드는 시스템 메모리 곁에 앱을 위한 메모리를 할당합니다. 이렇게 할당된 메모리는 앱의 코드와 실행중에 동적으로 할당하는 메모리를 위해 사용됩니다. 여기서 앱의 코드는 안드로이드 앱을 빌드할 때 생성되는 DEX 파일입니다.</p><p>아래는 <em>The price of ENUMs</em> 영상에서 캡쳐한 이미지입니다.</p><p><img src="http://anitoy.pe.kr/assets/img/enum_typedef/android_memory_alloc.png" alt="Android Memory Allocation"></p><h2 id="ENUM-사용-시-주의점">ENUM 사용 시 주의점</h2><blockquote><p>ENUM은 앱의 코드(DEX) 크기와 런타임 메모리 사용량을 증가시킵니다.</p></blockquote><p>앱의 DEX 크기가 증가된다는건 APK 파일도 커지고 앱이 실행됐을 때 사용하는 메모리의 양도 그만큼 늘어난다는걸 의미합니다. 또한 ENUM은 Integer나 String에 비해 더 많은 메모리를 런타임에 사용합니다.</p><h2 id="ENUM은-얼마나-DEX-크기를-더-증가-시킬까">ENUM은 얼마나 DEX 크기를 더 증가 시킬까?</h2><p><code>The price of ENUMs (100 Days of Google Dev)</code> 영상을 보면 그 차이를 분명히 알 수 있습니다.</p><p>먼저 상수를 아래와 같이 Integer로 선언한 경우, DEX의 크기는 124 bytes가 늘어납니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALUE1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALUE2 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALUE3 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span>(value) &#123;</span><br><span class="line"><span class="keyword">case</span> VALUE1:</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">case</span> VALUE2:</span><br><span class="line"><span class="keyword">return</span> -<span class="number">2</span>;</span><br><span class="line"><span class="keyword">case</span> VALUE3:</span><br><span class="line"><span class="keyword">return</span> -<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>반면에 이를 ENUM으로 선언하면 DEX의 크기는 1,632 bytes가 증가합니다. 무려 13배나 차이가 납니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> Value &#123;</span><br><span class="line">VALUE1,</span><br><span class="line">VALUE2,</span><br><span class="line">VALUE3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(Value value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span>(value) &#123;</span><br><span class="line"><span class="keyword">case</span> VALUE1:</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">case</span> VALUE2:</span><br><span class="line"><span class="keyword">return</span> -<span class="number">2</span>;</span><br><span class="line"><span class="keyword">case</span> VALUE3:</span><br><span class="line"><span class="keyword">return</span> -<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 바로 ENUM을 사용할 때 왜 주의해야 하는지를 알 수 있습니다. ENUM 사용으로 인한 DEX의 크기가 커지면 앱과 시스템이 사용하는 메모리는 줄어들게 됩니다.</p><p>ENUM을 사용함으로써 증가하는 메모리의 양은 어찌보면 그리 크지 않다 여길 수 있습니다. 하지만 ENUM을 무심코 사용하다보면 그 크기는 결코 무시할 수 없게 됩니다.</p><h2 id="해결방법-첫-번째-Proguard-사용">해결방법 첫 번째, Proguard 사용</h2><p>프로가드를 사용하면 빌드 시 enum을 Integer로 바꾸는 최적화를 수행해 줍니다.</p><h2 id="해결방법-두-번째-Typedef-어노테이션-사용">해결방법 두 번째, Typedef 어노테이션 사용</h2><p>위의 예제처럼 ENUM의 대안으로 간단히 Integer를 사용함으로써 위의 이슈를 피해갈 수 있습니다. 하지만 ENUM이 괜히 있는게 아닙니다. ENUM을 사용하면 컴파일 및 런타임에 타입 및 값을 체크할 수 있습니다.</p><p>API의 인자나 반환 값에 제약을 줌으로써 API가 오동작을 일으킬 여지를 최대한 줄이는 것은 좋은 코드 작성하는 원칙중에 하나입니다. 하지만 단순히 Integer로 상수를 만들어 사용하는 것 만으로는 이런 제약을 줄 수 없습니다.</p><p>하지만 Typedef 어노테이션을 사용하면 컴파일 시에 warning을 통해 이를 미리 확인할 수 있게됩니다.</p><h2 id="Typedef-어노테이션이란">Typedef 어노테이션이란?</h2><p>Typedef 어노테이션은 어노테이션을 통해 특정 값의 유효성을 컴파일 시 확인할 수 있는 기능입니다. 자세한 사용법은 <a href="https://developer.android.com/studio/write/annotations.html">Improve Code Inspection with Annotations</a> 이 곳에서 확인 할 수 있습니다.</p><p>여기서는 간단한 예제를 가지고 사용법을 확인해보도록 하겠습니다.</p><p>먼저 어노테이션을 사용하기 위해 build.gradle 파일에 서포트 라이브러리를 추가해줍니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123; compile &#39;com.android.support:support-annotations:24.2.0&#39; &#125;</span><br></pre></td></tr></table></figure><p>그리고 아래와 같이 Typedef 어노테이션을 사용합니다. 아래의 예제는 실제 안드로이드 ActionBar 코드 중 일부입니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.support.annotation.IntDef;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionBar</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Define the list of accepted constants and declare the NavigationMode annotation</span></span><br><span class="line">    <span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line">    <span class="meta">@IntDef</span>(&#123;NAVIGATION_MODE_STANDARD, NAVIGATION_MODE_LIST, NAVIGATION_MODE_TABS&#125;)</span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> NavigationMode &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Declare the constants</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NAVIGATION_MODE_STANDARD = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NAVIGATION_MODE_LIST = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NAVIGATION_MODE_TABS = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decorate the target methods with the annotation</span></span><br><span class="line">    <span class="meta">@NavigationMode</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getNavigationMode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Attach the annotation</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setNavigationMode</span><span class="params">(@NavigationMode <span class="keyword">int</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p>NavigationMode라는 Typedef 어노테이션을 생성합니다. NavigationMode에는 <strong>@IntDef</strong>를 통해 <code>NAVIGATION_MODE_STANDARD, NAVIGATION_MODE_LIST, NAVIGATION_MODE_TABS</code> 세 가지 값만 들어올 수 있음을 명시하고 있고, 각 상수는 아래 public static final int로 선언이 되어 있습니다. **@Retention(RetentionPolicy.SOURCE)**는 컴파일러가 .clss에 <strong>@NavigationMode</strong>의 데이터를 저장하지 않도록 합니다.</p><p>이제 <code>NavigationMode</code>는 함수의 반환값이나 인자, 객체의 필드에 사용될 수 있습니다. 코드에서 보면 getNavigationMode() 함수의 반환값과 setNavigationMode() 함수의 인자에 @NavigationMode 어노테이션이 붙어있습니다.</p><p>이를 통해 getNavigationMode()의 반환값이나 setNavigationMode()의 mode 인자에 <code>NAVIGATION_MODE_STANDARD, NAVIGATION_MODE_LIST, NAVIGATION_MODE_TABS</code> 외의 값이 들어가면 warning이 발생합니다.</p><p>이렇게 생성한 Typedef 어노테이션은 안드로이드 스튜디오의 코드 완성에도 적용되어 간편하게 사용할 수 있습니다.  <strong>@StringDef</strong>를 통해 문자열도 동일하게 사용이 가능합니다.</p><h2 id="Typedef-어노테이션-사용-시-주의점">Typedef 어노테이션 사용 시 주의점</h2><p>Typedef 어노테이션을 사용한다 해도 빌드는 정상적으로 수행됩니다. 따라서 반드시 IDE 자체에서 실시간으로 보여주는 warning을 확인하거나, 안드로이드 스튜디오의 <code>Analyze -&gt; Code Infection</code>을 통해 warning을 확인 하는 것이 중요합니다.</p><h2 id="마무리">마무리</h2><p><strong>이 글은 ENUM 사용 시 주의할 점을 정리한 글이지만 ENUM을 사용하지 말라는 글은 절대 아닙니다.</strong></p><p>ENUM이 DEX의 크기를 증가시키는 문제는 있지만 ENUM을 사용하면 코드의 가독성과 타입의 값에 대한 유효성(Type safety)이 좀 더 보장됩니다.</p><p>이는 굉장한 장점입니다. 따라서 가독성이나 안정성이 중요시 되는 코드에는 ENUM을 사용하는게 맞습니다.</p><p>비슷한 예로 C언어의 매크로 함수가 있습니다. 매크로 함수는 함수처럼 사용할 수 있지만 컴파일 시에 직접 코드로 치환되어 실행파일에 삽입됩니다. 따라서 매크로 함수를 사용하면 함수 호출의 부하를 줄일 수 있습니다.</p><p>하지만 매크로 함수도 잘 못 사용하면 오히려 성능을 저하시킵니다. 가령 코드의 너무 많은 곳에서 매크로 함수를 호출하게되면 호출 부에 모두 코드로 치환되기 때문에 코드 영역의 크기가 매우 커질 수 있습니다. 즉 경우에 따라 오히려 성능을 떨어뜨릴 수 있습니다.</p><p>ENUM과 Typedef 어노테이션 역시 비슷합니다. 각각의 장단점을 보고 필요한 곳에 잘 사용하는 것이 중요합니다. 또한 Proguard를 사용하면 위의 최적화를 대부분 알아서 수행해 줍니다. 어찌보면 굳이 Typedef 어노테이션을 사용할 필요가 없을지도 모릅니다.</p><p>이런 관점에서보면 안드로이드 플랫폼 코드에 Typedef 어노테이션을 권장하는 이유를 알 수 있습니다. 안드로이드 플랫폼 코드는 프로가드를 적용하지 않고, 전체 코드의 크기가 굉장히 크기 때문에 ENUM의 사용을 제한하지 않으면 플랫폼 코드가 대책없이 커질 수 있으니 딱 Typedef 어노테이션을 사용하기 좋은 곳이겠죠.</p><h2 id="참고-자료">참고 자료</h2><p><a href="https://youtu.be/Hzs6OBcvNQE">The price of ENUMs (100 Days of Google Dev)</a><br><br>Perfmatter 시리즈 영상 중 ENUM 사용 시 주의점에 대해 설명하는 영상입니다.</p><p><a href="https://developer.android.com/studio/write/annotations.html">Improve Code Inspection with Annotations</a><br><br>구글 개발자 페이지 문서입니다. 어노테이션을 이용해서 빌드 시 코드의 잠재적인 이슈를 미리 확인하는 방법을 다룹니다.</p>]]></content:encoded>
      
      <comments>https://jeongmin.github.io/2017/10/08/android/android-enum-intdef/#disqus_thread</comments>
    </item>
    
    <item>
      <title>안드로이드 그래들 빌드 속도 올리기</title>
      <link>https://jeongmin.github.io/2017/09/21/android/android-speeding-up-build-speed/</link>
      <guid>https://jeongmin.github.io/2017/09/21/android/android-speeding-up-build-speed/</guid>
      <pubDate>Wed, 20 Sep 2017 15:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;이 글은 2017년 5월 구글I/O의 &lt;a href=&quot;https://youtu.be/7ll-rkLCtyk&quot;&gt;Speeding Up Your Android Gradle Builds (Google I/O &#39;17&lt;/a&gt; 세션 중 일부를 정리한 내용입니다
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>이 글은 2017년 5월 구글I/O의 <a href="https://youtu.be/7ll-rkLCtyk">Speeding Up Your Android Gradle Builds (Google I/O '17</a> 세션 중 일부를 정리한 내용입니다.</p><p><a href="http://www.youtube.com/watch?v=7ll-rkLCtyk"><img src="http://img.youtube.com/vi/7ll-rkLCtyk/0.jpg" alt="IMAGE ALT TEXT HERE"></a></p><p>발표 영상, 슬라이드는 맨 아래 <a href="#reference">참고 링크</a>에서 확인 할 수 있습니다. 발표자는 안드로이드 스튜디오 팀의 <em>James Lau</em> 입니다.</p><p>영상을 보면, 산타트래커란 샘플 프로젝트에 하나씩 최적화를 적용하면서 어느정도 최적화가 되었는지 보여주는 방식으로 진행됩니다. 빌드속도는 당연히 프로젝트의 구성과 환경에 영향을 받습니다. 발표자가 테스트에 사용한 산타트래커는 아래와 같이 구성되었습니다.</p><ul><li>안드로이드 웨어를 포함한 9개의 모듈</li><li>500개의 자바 파일</li><li>1700개의 xml</li><li>3500개의 PNG</li><li>멀티덱스</li><li>60MB 정도의 apk를 크기</li><li>어노테이션프로세서는 사용치 않음</li></ul><p>벤치마크는 아래 세 가지 경우로 보여줍니다. incremental build는 구글 개발자 페이지에 증분 빌드로 번역하고 있어서 그대로 사용했습니다. <a href="https://developer.android.com/studio/run/index.html">참고 링크</a></p><ul><li>전체 빌드(Full build)<ul><li>Clean, assemble debug</li></ul></li><li>증분 빌드(Incremental build - Java change)<ul><li>한 메소드 안에 한줄의 자바코드 수정</li></ul></li><li>증분 빌드(Incremental build - resource changing)<ul><li>스트링 리소스 한 개를 추가하거나 제거</li></ul></li></ul><h2 id="빠른-빌드를-위한-10가지-팁">빠른 빌드를 위한 10가지 팁</h2><p>세션에서 소개된 팁은 총 10개로 아래 목차와 같습니다.</p><ol><li><a href="#use-lastest-android-gradle-plugin">최신 안드로이드 그래들 플러그인을 쓸 것</a><ul><li>Use lastest Android Gradle Plugin</li></ul></li><li><a href="#avoid-legacy-multidex">레거시 멀티덱스를 피할 것</a><ul><li>Avoid legacy multidex</li></ul></li><li><a href="#disable-multi-apk">멀티 APK를 사용하지 말 것</a><ul><li>Disable multi-APK</li></ul></li><li><a href="#include-minimal-resources">최소한의 리소스만 포함 시킬 것</a><ul><li>Include minimal resources</li></ul></li><li><a href="#disable-png-crunching">PNG 최적화 설정을 사용하지 말 것</a><ul><li>Disable PNG crunching</li></ul></li><li><a href="#use-instant-run">인스턴트 런을 사용할 것</a><ul><li>User Instant Run</li></ul></li><li><a href="#avoid-inadvertent-changes">의도치 않은 수정은 피할 것</a><ul><li>Avoid inadvertent changes</li></ul></li><li><a href="#do-not-use-dynamic-version">다이나믹 버전은 사용하지 말 것</a><ul><li>Don’t use dynamic version</li></ul></li><li><a href="#watch-the-memory">메모리를 확인할 것</a><ul><li>Watch the memory</li></ul></li><li><a href="#use-gradle-cache">그래들 캐시를 사용할 것</a><ul><li>Use Gradle Cache</li></ul></li></ol><h3 id="a-name-use-lastest-android-gradle-plugin-1-최신-안드로이드-그래들-플러그인을-쓸-것-a"><a name="use-lastest-android-gradle-plugin">1. 최신 안드로이드 그래들 플러그인을 쓸 것</a></h3><p>안드로이드 스튜디오 팀에서는 빌드 속도와 버그수정을 위해 그래들 플러그인을 계속 업데이트 하고 있습니다. 그래들 3.0부터는 구글 메이븐 저장소를 통해 그래들이 배포됩니다. 따라서 메이븐 구글 저장소를 추가해주고, dependency에 gradle 3.0.0을 추가해줍니다. 발표 영상에는 alpha1인데 오늘(2017.09.20일) 확인해본 바로는 beta4까지 나왔네요.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">repository &#123;</span><br><span class="line">jcenter()</span><br><span class="line">maven &#123; url <span class="string">'https://maven.google.com'</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">dependency &#123;</span><br><span class="line">classpath <span class="string">'com.android.tools.build:gradle:3.0.0-alpha1'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>결과를 보니 단순히 그래들 버전을 3.x대로 올리는 것만으로 속도가 아래와 같이 엄청나게 향상됩니다. 아래 결과는 발표자 영상에 있는걸 그대로 옮긴거구요, 대강 어느정도 향상되는지 참고 하시면 될 것 같습니다.</p><p>빌드 타입 | 속도 차이(초) | 속도 차이(백분율)<br>— | — |<br>전체 빌드 | -15s | -25%<br>증분 빌드(자바) | -10s | -38%<br>증분 빌드(리소스) | -2.5s | -16%</p><h3 id="a-name-avoid-legacy-multidex-2-레거시-멀티덱스를-피할-것-a"><a name="avoid-legacy-multidex">2. 레거시 멀티덱스를 피할 것</a></h3><p>멀티덱스 사용 시 minSdkVersion &lt; 21인 경우 레거시 멀티덱스가 적용됩니다. 그리고 이 레거시 멀티덱스는 빌드 속도를 심각하게 다운 시킵니다. 안드로이드 스튜디오 2.3+에서부터는 런 버튼을 클릭해서 앱을 실행하면, 연결된 디바이스나 에물레이터의 API 버전을 감지해서 가능하면 네이티브 멀티덱스를 적용해준다고 합니다. 참고로 커맨드라인으로 빌드하는 경우엔 이렇게 자동으로 버전을 감지해서 최적화 해주는 기능은 동작하지 않습니다.</p><p>만약 프로덕트가 api 레벨 21 미만의 단말도 지원해야 한다면 아래와 같이 <a href="https://developer.android.com/studio/build/build-variants.html">빌드 변형 구성</a>을 이용해 개발 용 빌드의 minSdkVersion을 21로 설정할 수 있습니다.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">productFlavors &#123;</span><br><span class="line">development &#123;</span><br><span class="line">minSdkVersion <span class="number">21</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>결과는 아래와 같습니다. 이것도 성능 향상이 꽤 크네요.</p><p>빌드 타입 | 속도 차이(초) | 속도 차이(백분율)<br>— | — |<br>전체 빌드 | -5.5s | -12%<br>증분 빌드(자바) | -8s | -53%<br>증분 빌드(리소스) | same | same</p><h3 id="a-name-disable-multi-apk-3-멀티-APK를-사용하지-말-것-a"><a name="disable-multi-apk">3. 멀티 APK를 사용하지 말 것</a></h3><p>멀티 APK는 ABI나 density에 따라 apk를 다르게 빌드하는 기능입니다. 한 프로젝트에 대해 여러 APK가 생성되지만, 각 빌드의 결과물로 나오는 APK 크기가 작아지는 장점이 있습니다. 하지만 개발환경에선 필요없는 기능이죠. 따라서 개발 용 빌드인 경우에는 멀티 APK 기능을 아래와 같이 꺼줍니다.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line"><span class="keyword">if</span> (project.hasProperty(<span class="string">'devBuild'</span>)) &#123;</span><br><span class="line">splits.abi.enable = <span class="literal">false</span></span><br><span class="line">splits.density.enable = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 그래들 빌드 스크립트를 보면 'devBuild’란 속성을 확인하는데 저 속성은 커맨드라인 빌드 시 아래와 같이 넘겨줍니다.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew santa-<span class="string">tracker:</span>assembleDevelopmentDebug -PdevBuild</span><br></pre></td></tr></table></figure><p>이걸 안드로이드 스튜디오에 적용한다면 preference -&gt; Build, Execution, Deployment -&gt; Compiler -&gt; Command-line Option 에 -P<strong>devBuild</strong>을 적어주면 됩니다.</p><p>결과는 아래와 같습니다. 리소스에 대한 증분 빌드 시에 많은 속도 향상이 있네요.</p><p>빌드 타입 | 속도 차이(초) | 속도 차이(백분율)<br>— | — |<br>전체 빌드 | -4.8s | -12%<br>증분 빌드(자바) | -0.5s | -6%<br>증분 빌드(리소스) | -3s | -26%</p><h3 id="a-name-include-minimal-resources-4-최소한의-리소스만-포함시킬-것-a"><a name="include-minimal-resources">4. 최소한의 리소스만 포함시킬 것</a></h3><p>앱이 다국어를 지원한다면 여러 스트링 리소스를 포함합니다. 다국어를 지원하지 않더라도 대부분의 앱은 하나 이상의 스크린 density를 지원하는 경우가 많습니다. 안드로이드의 빌드 시 기본 설정은 모든 버전의 리소스를 빌드에 포함시키도록 되어있습니다. 하지만 아래와 같이 특정 버전의 리소스들만 포함시키도록 할 수 있습니다. 아래는 개발용 빌드에 특정 리소스만 포함 시키도록 하는 그래들 설정 예시입니다.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">productFlavor &#123;</span><br><span class="line">developement &#123;</span><br><span class="line">minSdkVersion <span class="number">21</span></span><br><span class="line">resConfigs (<span class="string">"en"</span>, <span class="string">"xxhdpi"</span>)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>적용 결과입니다.</p><p>빌드 타입 | 속도 차이(초) | 속도 차이(백분율)<br>— | — |<br>전체 빌드 | -6s | -17%<br>증분 빌드(자바) | -1.5s | -24%<br>증분 빌드(리소스) | -2s | -21%</p><h3 id="a-name-disable-png-crunching-5-개발-빌드에는-PNG-최적화를-끄자-a"><a name="disable-png-crunching">5. 개발 빌드에는 PNG 최적화를 끄자</a></h3><p>안드로이드 빌드 툴은  PNG 크기 최적화를 기본으로 수행합니다. 최적화라면 PNG 파일들을 압축하는 거겠죠. 당연히 PNG 파일이 많으면 빌드 시 많은 시스템 자원을 사용하게 됩니다. 릴리즈 시에는 APK 크기를 줄여주므로 중요한 기능이지만 개발 시에는 별 필요 없는 기능입니다. 역시나 아래와 같이 그래들 빌드 스크립트를 이용해 설정을 살포시 꺼줍니다.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">productFlavor &#123;</span><br><span class="line">developement &#123;</span><br><span class="line">minSdkVersion <span class="number">21</span></span><br><span class="line">resConfigs (<span class="string">"en"</span>, <span class="string">"xxhdpi"</span>)</span><br><span class="line">aaptOptions.cruncherEnabled = <span class="literal">false</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>아니면 아예 webP 포맷을 사용하는 것도 좋은 방법입니다. webP는 PNG 파일보다 최대 25% 작은 크기를 갖는 포맷입니다. 안드로이드 스튜디오 2.3+ 부터는 IDE에서 PNG를 webP로 변환하는 기능을 지원합니다. 불투명 이미지는 안드로이드 API 15+, 투명도를 갖는 이미지는 API 18+부터 지원합니다. 또한 애초에 최적화된 PNG를 사용하면 최적화가 수행되어도 실제 APK의 크기는 별 차이가 없습니다. 그냥 시간만 잡아 먹는 거죠.</p><p>아래는 위의 PNG 최적화 기능을 끈 결과입니다.</p><p>빌드 타입 | 속도 차이(초) | 속도 차이(백분율)<br>— | — |<br>전체 빌드 | -9s | -33%<br>증분 빌드(자바) | same | same<br>증분 빌드(리소스) | same | same</p><h3 id="a-name-use-instant-run-6-인스턴트-런을-사용할-것-a"><a name="use-instant-run">6. 인스턴트 런을 사용할 것</a></h3><p>인스턴트 런은 안드로이드 스튜디오 2.0 때 런칭된 기능입니다. 발표자 말로는 런칭 이후 인스턴트 런의 신뢰성(reliability)를 위해 많은 노력을 기울였다고 합니다. 바꿔말하면 그동안에 인스턴트 런은 문제가 많았다는 뜻이겠죠. 저 역시도 인스턴트 런을 사용하지 않는데 이유는 수정한 코드가 실제로 빌드에 적용이 되지 않아 삽질을 한 기억이 많기 때문입니다. 수정한 코드가 빌드에 적용이 안된다면 빌드가 아무리 빨리 된들 무슨 소용이 있을까요.</p><p>하지만 안드로이드 스튜디오 3.0에 적용된 인스턴트 런은 2.0과 매우 다르다 합니다. 한번 믿어보는것도 좋을것 같습니다. 참고로 플랫폼의 한계에 따라 적용했던 많은 핵들을 신뢰성을 위해 과감히 제거하고 대신 안드로이드 스튜디오 3.0부터의 인스턴트 런은 API 레벨 21 이상에서만 동작한다고 합니다. (minSdk가 21 이상이여야 한다는게 아니라 연결된 단말의 버전이 21 이상이면 된다는 얘기입니다!)</p><p>안드로이스 스튜디오 3.0 이상에서는 인스턴트 런과 일반 빌드를 쉽게 구분하기 위해 런 버튼을 Run과 Apply Changes 두 개로 분리 했습니다.</p><p>Run 버튼을 클릭하면 콜드 스왑을 시도하고 앱은 재실행 됩니다. 반면 Apply Changes 버튼을 클릭하면 hot or warm swap을 시도합니다.  <a href="https://developer.android.com/studio/run/index.html">Cold, hot, warm swap</a>에 대한 내용은 이 링크에서 자세히 알 수 있습니다.</p><p>인스턴트 런을 실행하면 연결된 디바이스의 API, 스크린 density등을 분석해서 자동으로 필요한 최적화를 수행해 줍니다. 즉 앞서 얘기했던 특정 버전의 리소스만 포함하는 빌드를 생성한다거나 멀티 APK등에 대한 최적화 들을 알아서 해준다는 것 같습니다.</p><p>아래는 인스턴트 런을 적용한 결과입니다.</p><p>빌드 타입 | 속도 차이(초) | 속도 차이(백분율)<br>— | — |<br>전체 빌드 | +7s | +37%<br>증분 빌드(자바) | -3s | -54%<br>증분 빌드(리소스) | -3s | -42%</p><p>특이한게 인스턴트 런을 적용 했을 때, 풀빌드의 경우 오히려 빌드 시간이 증가했습니다. 이는 인스턴트 런이 sharding을 APK에 적용해야하기 때문이라 합니다. 이 sharding은 swap(cold, hot, warm)을 하기 위해 필요한 미리 수행되어야 하는 작업으로 발표자는 풀빌드에서 시간이 더 걸리지만 이후의 증분 빌드에서 시간을 줄일 수 있다고 이야기합니다. 간단히 위의 결과를 가지고  생각해보면 풀빌드 한번 후 증분 빌드를 2번만 하면 거의 동일하고 2번 이상부터는 매번 3초가량 시간을 벌 수 있겠네요.</p><h3 id="a-name-avoid-inadvertent-changes-7-의도치-않은-수정은-피할-것-a"><a name="avoid-inadvertent-changes">7. 의도치 않은 수정은 피할 것</a></h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> buildDateTime = <span class="keyword">new</span> Date().format(<span class="string">'yyMMddHHmm'</span>).toInteger()</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">defaultConfig &#123;</span><br><span class="line">versionCode buildDateTime</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드는 매 빌드가 유일한 버전코드를 갖도록 시간을 가지고 버전 코드를 설정하고 있습니다. 별거 아닌것 같은 코드이지만 이 코드는 매번 빌드를 할때마다 AndroidManifest를 변경합니다. 자세히 얘기하면 versionCode같은 값들은 그래들 빌드 스크립트에 기술되어 있지만 실제 빌드가 되는 과정에서 AndroidManifest.xml에 합쳐(merge)집니다.<a href="https://developer.android.com/studio/publish/versioning.html#appversioning">참고</a>.</p><p>위의 코드를 보면 매번 빌드 할때마다 versionCode가 변경되는데 이는 곧 매 빌드 마다 AndroidManifest의 <code>uses-sdk</code> 속성이 변경 되는 것이죠.<a href="https://developer.android.com/guide/topics/manifest/uses-sdk-element.html">참고</a>. 아무튼 위의 코드가 적용된 후 결과는 아래와 같습니다.</p><p>빌드 타입 | 속도 차이(초) | 속도 차이(백분율)<br>— | — |<br>증분 빌드(자바) | +3s | +130%<br>증분 빌드(리소스) | +3.6s | +90%</p><p>이런 문제를 개선하기 위해서는 앞서 개발 빌드 시에 멀티 APK를 적용하지 않았던 방법을 이용하면 됩니다.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> buildDateTime = project.hasProperty(<span class="string">'devBuild'</span>)? 100: <span class="keyword">new</span> Date().format(<span class="string">'yyMMddHHmm'</span>).toInteger()</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">...</span><br><span class="line">defaultConfig &#123;</span><br><span class="line">...</span><br><span class="line">versionCode buildDateTime</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="a-name-do-not-use-dynamic-version-8-다이나믹-버전은-사용하지-말-것-a"><a name="do-not-use-dynamic-version">8. 다이나믹 버전은 사용하지 말 것</a></h3><p>다이나믹 버전은 아래와 같이 그래들에 외부 라이브러리를 임포트 할 때, 뒤에 +를 붙여서 가장 최근 버전의 라이브러리를 가져올 수 있게하는 기능입니다.</p><p>발표자의 설명에 의하면 이 기능이 라이브러리의 새 버전을 추가로 확인하게 만들기 때문에 의존성 결정(dependency resolution) 시간을 증가시킨다고 합니다.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">dependencies &#123;</span><br><span class="line">compile <span class="string">'com.android.support:appcompat-v7:+'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>또 하나의 문제는 이게 앱을 nondeterministic하게 만든다는 겁니다. 코드의 수정이 전혀 없더라도 라이브러리의 새 버전이 나오면 빌드가 달라진다는 겁니다. 이거는 앱의 형상관리랑도 연관이 있는 부분입니다.</p><p>대부분의 프로젝트는 git같은 형상관리 툴을 이용해서 관리합니다. 형상관리 툴의 핵심기능이자 키포인트 중에 하나는, 특정 시점의 빌드를 내가 원할때 빌드해 낼 수 있고 이 빌드는 항상 동일해야 한다는 겁니다. 바이너리 수준에서 완전히 동일하진 않을 수도 있겠지만 적어도 라이브러리가 바뀌면 안되겠죠.</p><p>오래 전 내보낸 빌드에 핫픽스가 필요해서 코드의 특정 부분만 고쳐 새로 빌드를 했는데 임포트하는 라이브러리중에 업데이트가 된게 있다면? 최악의 경우 업데이트 된 라이브러리가 하위호환성을 지켜주지 않는다면? 꽤 골치아픈 상황이 되겠죠.</p><h3 id="a-name-watch-the-memory-9-메모리를-확인할-것-a"><a name="watch-the-memory">9. 메모리를 확인할 것</a></h3><h4 id="그래들에-할당하는-메모리">그래들에 할당하는 메모리</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#gradle.property 파일</span><br><span class="line">org.gradle.jvmargs=-Xmx1536m</span><br></pre></td></tr></table></figure><h4 id="덱스-처리-시-사용하는-메모리">덱스 처리 시 사용하는 메모리</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#build.gradle 파일</span><br><span class="line">dexOptions &#123;</span><br><span class="line">javaMaxHeapSize = <span class="string">"4g"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그래들에 할당하는 메모리의 적정량은 프로젝트 마다 다르니 메모리를 잘 조절하면서 최적의 값을 찾으라고 합니다. 한가지 주의할 점은 무작정 메모리를 많이 할당하면 오히려 성능이 떨어질 수도 있습니다. 본인 시스템의 메모리 용량에 따라 잘 맞춰서 설정해야합니다.</p><p>두번째는 덱스 프로세스의 자바 힙 크기를 설정하는 방법입니다. 덱스 프로세스가 기존에는 out-process로 동작했으나 안드로이드 스튜디오 2.1 부터 기본값이 in-process로 변경되어 저 설정은 이제 의미가 없다고 합니다. 있으면 그냥 지워버리라네요. 근데 여기서 out-process랑 in-process가 뭔지 조금 애매합니다. 기존에는 별도의 프로세스로 처리하다가 2.1부터는 안드로이드 스튜디오 프로세스 내에서 처리한다는 걸로 이해했는데 맞는지 모르겠네요. 안드로이드 스튜디오에서 빌드 한번 돌리면 램을 2기가 넘게 써대던데 이것 때문일지도 모르겠습니다.</p><h3 id="a-name-use-gradle-cache-10-그래들-캐시를-사용할-것-a"><a name="use-gradle-cache">10. 그래들 캐시를 사용할 것</a></h3><p>그래들의 새 캐싱 메카니즘 설정이라는데 모든 작업 결과를 캐시할 수 있다고 합니다. 안드로이드 스튜디오 2.3에 소개됐던 빌드 캐시랑 다른 점은 빌드 캐시는 pre-dexed external libararies만 캐시하는데 요건 가장 최근 빌드 뿐만 아니라 이전 빌드에 대한 캐시도 있다고 합니다. 또한 브랜치를 오가며 빌드하는 경우에도 캐시가 되고 캐싱된걸 배포할수도 있다고 하는데… 뭔 말인지는 잘 모르겠는데 어쨌든 안드로이드 스튜디오 3.0에 제대로 들어갈거라 하니 안드로이드 스튜디오 3.0이 정식 릴리즈 되면 그때 지켜봐야겠습니다.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Set this in gradle.properties</span><br><span class="line">org.gradle.caching=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="마무리">마무리</h2><p>위의 최적화를 모두 마친 결과가 아래와 같습니다.</p><ul><li>전체 빌드 : 59s -&gt; 19s로 3배 빨라짐</li><li>증분 빌드(자바) : 24s -&gt; 2s로 12배 빨라짐</li><li>증분 빌드(리소스): 15s -&gt; 4.5s로 3배 빨라짐</li></ul><p>팁들을 대강 살펴보면 개발 빌드에 필요 없는 항목들은 빌드를 하지 않는데 초점이 맞쳐져 있는걸 알 수 있습니다. <strong>즉 개발 중에는 위의 팁들을 이용해 빌드 속도가 많이 향상될 수 있지만 릴리즈 빌드 시에는 결국 비슷한 속도로 빌드가 진행되게 됩니다.</strong></p><p><strong>또한 위의 팁들은 빌드 툴의 영향을 받는 것들이 대부분입니다.</strong> 즉 발표자의 발표 시점과 실제 적용 시에는 차이가 있을 수 있습니다. 따라서 위의 결과들은 앞으로 안드로이드 스튜디오나 빌드 툴이 변해가며 계속 변할 수 있는 것들이라는 점을 유념해야 합니다.</p><p>어쨋거나 개발 과정에 빌드 속도는 생산성에 큰 영향을 미치는 요소입니다. 빌드 속도가 빠르면 코드 수정 후 결과를 빠르게 확인 할 수 있고 그만큼 집중력을 유지할 수 있겠죠. 개인적으로는 아주 재미있었던 세션이였습니다. 시간이 되시는 분들은 원래 영상을 꼭 직접 보시면 좋을 것 같습니다.</p><h2 id="번외-직접-테스트">번외(직접 테스트)</h2><p>참고로 제가 개발하는 회사 프로젝트에 간단히 적용할 수 있는 최적화를 몇개 해보았는데 <code>전체 빌드 기준</code> 1분41초 -&gt; 56초의 개선이 있었습니다.</p><p>적용한 최적화 팁</p><ul><li>그래들 버전업(2.2.2 -&gt; 3.0.0-beta6)</li><li>레거시 멀티 덱스 우회(개발 빌드 시 minSdk 16 -&gt; 19)</li><li>PNG Crunch 모드 끄기</li><li>필요한 리소스만 빌드(xhdpi만 빌드)</li></ul><table><thead><tr><th>최적화 전</th><th>최적화 후</th></tr></thead><tbody><tr><td>101초</td><td>56초</td></tr></tbody></table><h2 id="참고-링크-a-name-reference-a">참고 링크<a name="reference"></a></h2><p><a href="https://youtu.be/7ll-rkLCtyk">Speeding Up Your Android Gradle Builds (Google I/O '17</a><br><br>구글 I/O의 ‘Speeding Up Your Android Gradle Builds’ 세션 영상입니다.</p><p><a href="https://speakerdeck.com/jmslau/speeding-up-android-gradle-builds">Slide for the speech(Spddeing Up Your Android Gradle Build)</a><br><br>발표자의 발표자료입니다.</p><p><a href="https://developer.android.com/studio/build/optimize-your-build.html">Optimize Your Build Speed</a><br><br>안드로이드 개발자 사이트의 <code>Optimize Your Build Speed</code> 문서입니다. 발표 영상에 나오는 대부분의 내용들을 볼 수 있습니다.</p><p><a href="https://developer.android.com/studio/run/index.html">Build and Run Your App</a><br><br>안드로이드 빌드 및 실행에 대한 전반적인 설명이 있는 페이지입니다.</p><p><a href="https://developer.android.com/studio/run/index.html">Cold, hot, warm swap</a><br><br>콜드, 핫, 웜 스왑에 대한 설명입니다.</p><p><a href="https://developer.android.com/studio/publish/versioning.html#appversioning">Version Your App</a><br><br>안드로이드 버전 설정에 대한 내용입니다.</p><p><a href="https://developer.android.com/guide/topics/manifest/uses-sdk-element.html">AndroidManifest uses-sdk property</a><br><br>그래들에 명시한 sdk 관련 설정들이 빌드 과정에서 AndroidManifest에 병합되어 처리된다는 걸 알 수 있습니다.</p><p><a href="https://developer.android.com/studio/build/gradle-plugin-3-0-0.html">About Android Plugin for Gradle 3.0.0</a><br><br>그래들 3.0.0 버전에 대한 설명 페이지입니다.</p>]]></content:encoded>
      
      <comments>https://jeongmin.github.io/2017/09/21/android/android-speeding-up-build-speed/#disqus_thread</comments>
    </item>
    
    <item>
      <title>홈스크린에 뷰 띄우기</title>
      <link>https://jeongmin.github.io/2016/04/11/android/android-floating_widget/</link>
      <guid>https://jeongmin.github.io/2016/04/11/android/android-floating_widget/</guid>
      <pubDate>Sun, 10 Apr 2016 15:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;안드로이드를 쓰다보면 홈화면에 뷰를 띄우는걸 종종 볼 수 있습니다. 대표적으로 네이버앱의 퀵메뉴나 페이스북 메신저의 챗헤드가 있죠. 퀵메뉴는 네이버앱의 각 메뉴로 바로갈 수 있는 런처 역할을, 챗헤드는 앱으로 진입하지 않고 홈화면에서 바로 대화를
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>안드로이드를 쓰다보면 홈화면에 뷰를 띄우는걸 종종 볼 수 있습니다. 대표적으로 네이버앱의 퀵메뉴나 페이스북 메신저의 챗헤드가 있죠. 퀵메뉴는 네이버앱의 각 메뉴로 바로갈 수 있는 런처 역할을, 챗헤드는 앱으로 진입하지 않고 홈화면에서 바로 대화를 이어갈 수 있도록 해줍니다. 이처럼 홈화면은 사용자가 홈버튼을 누르거나 단말을 켰을때 가장 먼저 보는 기본 화면이기에 접근성이 높아 이를 잘 이용하는 것은 매우 중요합니다.</p><p><img src="/assets/img/floating_widget/quickmenu.png" alt="quickmenu"></p><p>오늘은 이렇게 홈스크린에 직접 뷰를 띄우는 방법에 대해 공유하려고 합니다. 이 방식은 __윈도우(Window)__를 직접 생성하고 여기에 뷰를 넣는 방식입니다. 안드로이드에서는 홈 화면을 이용할 수 있도록 위젯을 제공하지만 기본으로 제공하는 위젯은 크기와 위치가 제한됩니다. 하지만 이 방법은 위젯과는 달리 위치와 크기를 자유롭게 조절할 수 있기 때문에 활용도가 매우 높습니다.</p><h1>윈도우란</h1><p>아까 잠시 언급했듯이 이 방법은 직접 윈도우를 생성하고 뷰를 넣는 방식입니다. 그래서 자세한 방법을 설명하기 전에 윈도우에 대해 간단히 알고 넘어가야합니다.</p><p>윈도우는 화면에 UI를 그리기 위한 Surface를 갖습니다. 즉 화면에 뭔가 그려지고 있다는 것은 윈도우가 있는 것입니다. 또한 윈도우는 사용자와의 인터렉션을 위한 키, 터치 이벤트 등을 처리할 수 있는 컴포넌트입니다.</p><p>기본적으로 액티비티를 생성하면 액티비티는 윈도우를 갖습니다. 또한 아래 그림과 같이 토스트, 스테이터스 바, 다이얼로그등도 개별적인 윈도우를 가집니다.</p><table><thead><tr><th>토스트, 스테이터스바</th><th>다이얼로그</th><th>액티비티</th></tr></thead><tbody><tr><td><img src="/assets/img/floating_widget/ex_window_1.png" alt="ex1"></td><td><img src="/assets/img/floating_widget/ex_window_2.png" alt="ex2"></td><td><img src="/assets/img/floating_widget/ex_window_3.png" alt="ex3"></td></tr></tbody></table><h3 id="윈도우-타입과-이벤트-처리">윈도우 타입과 이벤트 처리</h3><p>윈도우의 목적과 종류에 따라 윈도우는 서로 다른 타입을 가집니다. 예를들어 액티비티에 주로 사용되는 타입(TYPE_BASE_APPLICATION)의 윈도우는 키, 터치 이벤트를 받지만 토스트에 사용되는 타입(TYPE_TOAST)의 윈도우는 키, 터치 이벤트를 받지 못합니다. 이러한 이벤트는 윈도우의 타입에 따라 다르고 윈도우 생성 시 플래그를 통해 어느정도 제어가 가능합니다.</p><h3 id="우선순위">우선순위</h3><p>윈도우의 타입에 따라 우선순위가 달라집니다. 우선순위는 화면에 그려지는 순서를 결정하는데 우선순위가 높을수록 나중에 그려져서 우선순위가 낮은 윈도우를 덮을 수 있습니다. 가령 토스트의 윈도우 타입인 TYPE_TOAST는 액티비티가 사용하는 TYPE_BASE_APPLICATION보다 우선순위가 높기때문에 액티비티에서 토스트를 띄우면 토스트가 액티비티 위에 그려지게 됩니다. 우선순위는 안드로이드 버전에 따라 조금씩 다릅니다.</p><h1>구현하기</h1><p>홈스크린에 뷰를 넣는 방법은 아래와 같습니다.</p><ol><li>원하는 뷰를 생성한다.</li><li>적절한 타입과 속성을 갖는 윈도우 레이아웃 파라미터(WindowManager.LayoutParam)을 생성한다.</li><li>윈도우 매니저의 addView(View, ViewGroup.LayoutParams params)을 이용하여 윈도우를 생성한다.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 뷰 생성</span></span><br><span class="line">ImageView floatingView = <span class="keyword">new</span> ImageView(<span class="keyword">this</span>);</span><br><span class="line">floatingView.setImageResource(R.drawable.ic_pholar);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 윈도우 레이아웃 파라미터 생성 및 설정</span></span><br><span class="line">mWindowLp = <span class="keyword">new</span> WindowManager.LayoutParams(WindowManager.LayoutParams.TYPE_PHONE);</span><br><span class="line">mWindowLp.width  = WindowManager.LayoutParams.WRAP_CONTENT;</span><br><span class="line">mWindowLp.height = WindowManager.LayoutParams.WRAP_CONTENT;</span><br><span class="line">mWindowLp.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 윈도우 생성</span></span><br><span class="line">mWindowManager = (WindowManager) getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">mWindowManager.addView(floatingView, mWindowLp);</span><br></pre></td></tr></table></figure><p>홈화면과 일반 액티비티는 윈도우 타입이 TYPE_BASE_APPLICATION 입니다. 반면 위 코드에서 사용한 TYPE_PHONE은 TYPE_BASE_APPLICATION이기 때문에 홈화면이나 액티비티 보다 우선순위가 높아 홈 또는 액티비티 위에 그려집니다. 또한 TYPE_PHONE는 status_bar위로 올라갈 수는 없으며 터치 이벤트를 받을 수 있습니다.</p><p>TYPE_PHONE은 아래 권한이 필요합니다.</p><p><code>android.permission.SYSTEM_ALERT_WINDOW</code></p><p>WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE는 현재 윈도우보다 하위 윈도우가 터치 이벤트를 받을 수 있도록 하는 플래그 입니다. 이걸 세팅하지 않으면 생성한 윈도우보다 낮은 순위를 갖는 홈이나 액티비티가 터치 이벤트를 받을 수 없습니다.</p><p>마지막에 보면 윈도우 매니저를 통해 윈도우를 생성하고 있습니다. 윈도우는 안드로이드의 윈도우매니저를 통해서 접근이 가능합니다. addView()를 통해 윈도우를 추가하였지만 삭제할때는 removeView()를 하면됩니다. 윈도우의 크기나 위치가 변경 되었다면 updateViewLayout()를 통해 변경사항을 적용해줍니다.</p><blockquote><p>윈도우의 라이프사이클이 생성한 곳에 따라 달라집니다. 액티비티에서 생성하면 액티비티가 종료될때 사라지므로 서비스에서 생성하도록 합니다. 또한 서비스가 종료될때는 윈도우를 제거하도록 처리해주는 것도 중요합니다.</p></blockquote><p>아래 이미지는 위의 코드로 생성한 홈 위젯입니다.</p><p><img src="/assets/img/floating_widget/ex_window_4.png" alt="ex4"></p><h3 id="드래깅-구현하기">드래깅 구현하기</h3><p>여기에 퀵메뉴나 챗헤드 처럼 자유롭게 움직일 수 있도록 하고 싶다면 아래와 같이 터치 이벤트를 처리해줍니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">floatingView.setOnTouchListener(<span class="keyword">new</span> OnTouchListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ev.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">             mStartingX = ev.getRawX();</span><br><span class="line">               mStartingY = ev.getRawY();</span><br><span class="line"></span><br><span class="line">               mWidgetStartingX = mWindowLp.x;</span><br><span class="line">               mWidgetStartingY = mWindowLp.y;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">             <span class="keyword">float</span> deltaX = mStartingX - ev.getRawX();</span><br><span class="line">               <span class="keyword">float</span> deltaY = mStartingY - ev.getRawY();</span><br><span class="line">               mWindowLp.x = (<span class="keyword">int</span>) (mWidgetStartingX - deltaX);</span><br><span class="line">               mWindowLp.y = (<span class="keyword">int</span>) (mWidgetStartingY - deltaY);</span><br><span class="line">               mWindowManager.updateViewLayout(floatingView, mWindowLp);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>이벤트 처리시에 ev.getRawX(), ev.getRawY()를 사용했는데 이렇게 하면 스크린에서의 터치 위치를 가져올 수 있습니다. 이 뷰는 스크린내에서 움직여야 하기때문에 getRawX, getRawY를 사용합니다.</p><h3 id="생성-및-제거-애니메이션-처리하기">생성 및 제거 애니메이션 처리하기</h3><p>윈도우가 생성되고 제거될때의 애니메이션은 시스템에서 제공하는 애니메이션만 적용이 가능합니다. 적용하는 방법은 아래와 같이 WindowManager.LayoutParam을 이용합니다.</p><p><code>mWindowLp.windowAnimations = android.R.style.Animation_Toast;</code></p><p>생성 및 제거 시 애니메이션만 위와 같은 제약이 있고 뷰나 레이아웃 자체에 주는 애니메이션은 자유롭게 적용이 가능합니다.</p><h1>그 외 재미있는 것들</h1><h3 id="스테이터스바-높이-구하기">스테이터스바 높이 구하기</h3><p>안드로이드 개발자 페이지에 가면 다른 튜토리얼이나 가이드는 굉장히 잘 되어있는데 이상하게 윈도우에 대한 설명은 매우 적습니다. 그래서 윈도우에 대해 제대로 이해하기가 어려웠는데요. 윈도우에 대해 앞서 설명한 정도의 배경만 알아도 많은 도움이 되는 것 같습니다. 가령 개발을 하다보면 스테이터스 바의 높이를 구하고 싶을때가 있는데요. 스택 오버플로우에서 찾아보면 아래와 같은 코드가 나옵니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Rect rectangle= <span class="keyword">new</span> Rect();</span><br><span class="line">Window window= getWindow();</span><br><span class="line">window.getDecorView().getWindowVisibleDisplayFrame(rectangle);</span><br><span class="line"><span class="keyword">int</span> statusBarHeight= rectangle.top;</span><br></pre></td></tr></table></figure><p>처음에는 이 코드를 이해를 못하고 그냥 가져다 썼는데요. 위에 정리한 내용을 보고 다시 보면…먼저 현재 액티비티의 윈도우를 가져오고 윈도우의 Rect를 가져옵니다. 일반적인 윈도우는 스테이터스 바 아래 위치하기 때문에 액티비티 윈도우의 top이 바로 스테이터스바의 높이가 됩니다.</p><h3 id="키보드가-올라왔는지-체크하기">키보드가 올라왔는지 체크하기</h3><p>또 아래 코드는 키보드가 현재 올라와 있는지를 체크하는 코드입니다. 안드로이드는 키보드가 올라와 있는지 내려가 있는지 알 수 있는 API를 제공해주지 않기 때문에 여러가지 꼼수를 써서 이를 체크해야하는데요. 가장 많이 사용되는 것이 아래의 코드입니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">contentView.getViewTreeObserver().addOnGlobalLayoutListener(<span class="keyword">new</span> ViewTreeObserver.OnGlobalLayoutListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGlobalLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   Rect r = <span class="keyword">new</span> Rect();</span><br><span class="line">   contentView.getWindowVisibleDisplayFrame(r);</span><br><span class="line">   <span class="keyword">int</span> screenHeight = contentView.getRootView().getHeight();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// r.bottom is the position above soft keypad or device button.</span></span><br><span class="line">   <span class="comment">// if keypad is shown, the r.bottom is smaller than that before.</span></span><br><span class="line">   <span class="keyword">int</span> keypadHeight = screenHeight - r.bottom;</span><br><span class="line"></span><br><span class="line">   Log.d(TAG, <span class="string">"keypadHeight = "</span> + keypadHeight);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (keypadHeight &gt; screenHeight * <span class="number">0.15</span>) &#123; <span class="comment">// 0.15 ratio is perhaps enough to determine keypad height.</span></span><br><span class="line">        <span class="comment">// keyboard is opened</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// keyboard is closed</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>이것도 앞서 윈도우에 대해 정리한걸 바탕으로 보면 아주 간단합니다. 현재 액티비티 윈도우의 높이를 구하고, 이 높이와 스크린의 높이를 대강 비교해서 액티비티의 높이가 키보드가 올라왔다고 판단할 수 있을만큼 작아졌다면 키보드가 올라왔다고 판단하는 것입니다.(키보드가 올라오면 액티비티의 윈도우는 그만큼 줄어듭니다)</p><h1>마무리</h1><p>사실 예전에 네이버 퀵메뉴를 만들때는 온전히 이해하지 못하고 적용을 했었는데 핑퐁을 하면서 정리하다보니 이제서야 오히려 더 이해를 깊게 하게 된것 같습니다. 정리하는 내내 재미있었네요. 윈도우 타입과 속성을 잘 조합하면 재미있는 것들을 많이 해볼 수 있을 것 같습니다.</p>]]></content:encoded>
      
      <comments>https://jeongmin.github.io/2016/04/11/android/android-floating_widget/#disqus_thread</comments>
    </item>
    
    <item>
      <title>웹링크 미리보기 화면 보여주기(OGTag)</title>
      <link>https://jeongmin.github.io/2016/03/30/web/web-ogtag/</link>
      <guid>https://jeongmin.github.io/2016/03/30/web/web-ogtag/</guid>
      <pubDate>Tue, 29 Mar 2016 15:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;웹서핑을 하다보면 재미있는 글이나 자료들을 URL 링크 형태로 공유하는 경우가 많이 있습니다. 하지만 단순히 URL만 보게되면 보는 사람 입장에서는 해당 링크가 어떤 웹페이지인지 알기가 어렵죠. 그래서 많은 앱과 서비스에서 아래와 같이 해당 페이
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>웹서핑을 하다보면 재미있는 글이나 자료들을 URL 링크 형태로 공유하는 경우가 많이 있습니다. 하지만 단순히 URL만 보게되면 보는 사람 입장에서는 해당 링크가 어떤 웹페이지인지 알기가 어렵죠. 그래서 많은 앱과 서비스에서 아래와 같이 해당 페이지에 대한 미리보기(제목, 설명, 이미지)를 제공합니다.</p><p><img src="/assets/img/ogtag/ogtag.png" alt="OGTag"></p><p>이런 화면을 보여주기 위해 사용되는 가장 기본적인 방법은 OGTag(Open Graph Meta Tag)를 이용하는 방법입니다. OGTag는 웹페이지에 대한 간단한 정보를 html에 입력해두고 이 페이지를 보여주는 앱이나 서비스에서 이를 이용해 위의 스크린 샷과 같이 페이지에 대한 간략한 정보를 보기 쉽게 보여줄 수 있도록 하는 것입니다. 아래는 html에 OGTag를 입력하는 예입니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">......</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">"og:title"</span> <span class="attr">content</span>=<span class="string">"test"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">"og:type"</span> <span class="attr">content</span>=<span class="string">"article"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">"og:url"</span> <span class="attr">content</span>=<span class="string">"https://rootree.net"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">"og:description"</span> <span class="attr">content</span>=<span class="string">"This is a description."</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">"og:image"</span> <span class="attr">content</span>=<span class="string">"https://img.jpg"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">"og:image:width"</span> <span class="attr">content</span>=<span class="string">"1200"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">"og:image:height"</span> <span class="attr">content</span>=<span class="string">"627"</span> /&gt;</span></span><br><span class="line">......</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>보시면 property가 og:xxx인 메타 태그들이 있는데요. 이것들이 바로 OGTag 입니다. 메타 태그는 본래 해당 페이지를 설명하는 정보들을 넣기위한 태그입니다. 검색엔진이 웹페이지를 검색하거나 웹브라우저가 해당 페이지를 정확하게 보여주기 위해 도움이 되는 정보 등으로 사용됩니다. 이중에서도 Open Graph Meta Tag는 사용자가 웹사이트를 페이스북에 공유하기 좋게 하기 위한 목적으로 만들어졌습니다. 이와 유사한 걸로는 트위터의 card 태그가 있습니다.</p><p>위와 같이 og:xxx 태그를 입력해둔 웹페이지를 페이스북에 공유하면 페이스북에서는 이 태그들을 이용해서 해당 페이지의 링크를 마치 페이스북의 오브젝트처럼 다루어서 보다 예쁘게 보여줍니다. 아래 이미지는 페이스북에 링크를 공유했을때 보여지는 화면인데요. 이걸 보시면 바로 이해가 가실겁니다. 제가 공유한건 단순히 <a href="https://naver.com">https://naver.com</a> 이란 URL인데 아래와 같이 페이스북에서 자체적으로 예쁘게 보여주죠. 지금은 페이스북이 아니라 밴드, 라인, 카톡등 다른 서비스에서도 이를 이용해서 비슷하게 미리보기를 해주고 있습니다.</p><p><img src="/assets/img/ogtag/ogtag_facebook.png" alt="OGTag_Facebook"></p><p>Open Graph Meta Tag는 페이스북의 Open Graph Protocol에 정의가 되어있습니다. 이에 대한 자세한 설명은 아래 링크에서 확인 가능합니다. 지금까지 소개에선 타이틀, 설명, 썸네일 이미지 정도의 정보를 보여줄 수 있다는 정도였지만 실제로는 OGTag를 이용해 동영상, 음악 같은 것들도 표현할 수 있습니다. 또한 아래의 Open Graph Protocol 페이지에 가면 언어별 파서 및 플러그인, 개발 도구 등도 보실 수 있습니다.</p><ul><li><a href="https://ogp.me/">Open Graph Protocol</a></li><li><a href="https://developers.facebook.com/docs/sharing/opengraph">Open Graph API</a></li></ul><p>그럼 안드로이드 앱에서 OGTag를 이용하려면 어떻게 하면 될까요? 아주 간단합니다.</p><ol><li>링크를 입력 받는다.</li><li>해당 링크의 html을 가져와 OGTag를 파싱한다.</li><li>2에서 파싱된 OGTag 정보를 가지고 원하는 UI로 예쁘게 보여준다.</li></ol><p>위의 과정을 간단히 코드로 구현해 보았습니다. Jsoup를 통해 html을 가져오고 여기서 OGTag를 파싱하는 코드입니다. 간단히 위의 로직만 옮긴 코드라서 슈도코드 정도 느낌으로 참고만 하면 될 것 같습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getOGTag</span><span class="params">(String url, <span class="keyword">final</span> OGTag ret)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 입력받은 url에 해당하는 html을 요청하고 OGTag들을 가져온다.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Connection con = Jsoup.connect(url);</span><br><span class="line">        Document doc = con.get();</span><br><span class="line">        Elements ogTags = doc.select(<span class="string">"meta[property^=og:]"</span>);</span><br><span class="line">        <span class="keyword">if</span> (ogTags.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 필요한 OGTag를 추려낸다</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ogTags.size(); i++) &#123;</span><br><span class="line">            Element tag = ogTags.get(i);</span><br><span class="line"></span><br><span class="line">            String text = tag.attr(<span class="string">"property"</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"og:url"</span>.equals(text)) &#123;</span><br><span class="line">                ret.setOgUrl(tag.attr(<span class="string">"content"</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"og:image"</span>.equals(text)) &#123;</span><br><span class="line">                ret.setOgImageUrl(tag.attr(<span class="string">"content"</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"og:description"</span>.equals(text)) &#123;</span><br><span class="line">                ret.setOgDescription(tag.attr(<span class="string">"content"</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"og:title"</span>.equals(text)) &#123;</span><br><span class="line">                ret.setOgTitle(tag.attr(<span class="string">"content"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="조금-더-생각해볼-것들">조금 더 생각해볼 것들</h3><h4 id="서비스-적용하기">서비스 적용하기</h4><p>위의 예는 아주 간단한 구현이지만 실제로 서비스에 적용하려면 성능과 네트워크 사용에 대한 부분도 생각해봐야합니다. 링크가 PC 페이지인 경우 html 자체도 상당한 크기를 가질 수 있기때문에 이 자체도 부담이 될 수 있습니다. 따라서 매번 URL을 통해 OGTag를 파싱하는 건 쓸데없이 네트워크 트래픽 및 성능 상 낭비가 될 수 있습니다. 이를 피하기 위해서는 중간에 서버를 두거나, 캐싱을 사용하는 건데요. 서버를 두는건 OGTag를 통해 얻을 수 있는 장점에 비해 너무 큰 리소스가 들어가는 문제가 있습니다.</p><p>또한 서버를 두든 앱에서 로컬 캐싱을 하든 웹페이지의 OGTag를 실시간으로 반영하기 어렵다는 이슈가 있습니다. 따라서 서비스에 따라 상황에 맞춰 적절히 적용하는 센스가 필요합니다. 앱개발자 입장에서는 며칠 단위의 로컬 캐시를 만들어서 서버없이 간단히 구현하는 방식도 좋을것 같습니다.</p><h4 id="OGTag가-없는-경우">OGTag가 없는 경우</h4><p>OGTag를 사용자가 넣어두지 않은 경우에도 URL미리보기를 적용하고 싶다면 html내에서 적당한 이미지와 타이틀, 설명을 뽑아서 사용하면 됩니다. 가령 타이틀은 메타 태그의 title을, 설명은 description을 사용한다든지, 아니면 본문의 텍스트 중 앞부분에서 적당히 잘라서 쓴다든지 하는 것이죠. 이미지 역시 div 또는 body안에서 첫번째 이미지를 찾아서 가져 올 수 있겠죠. 이런 부분은 정답이 없기에 성능이나 정책을 적당히 고려해서 적용하면 될 것 같습니다.</p><h4 id="페이스북의-OGTag-처리">페이스북의 OGTag 처리</h4><p>참고로 페이스북은 서버단에서 OGTag를 처리하고 자체적으로 캐싱도 해주고 있습니다. 사용자의 포스팅을 피드 형식으로 보여주니 당연한거 같기도 합니다. 사용자가 포스팅에 URL을 첨부하면 페이스북 크롤러가 해당 페이지의 OGTag를 캐싱해서 피드에 내려주는 방식입니다. 성능 이슈 때문인지 캐싱된 OGTag는 크롤링 될 때의 스냅샷이 저장되고 개발자 콘솔에서 캐시를 초기화 해주지 않으면 OGTag가 수정되어도 반영이 되지 않습니다. 폴라에는 각 엔드나 프로필등의 주요화면에 URL 공유하기 기능이 있는데요. 위와 같은 이슈때문에 공유하기 URL을 생성할때 앱에서 URL 뒤에 타임스탬프를 붙여서 이를 회피하고 있습니다(캐싱이 되지 않도록).</p><p>그리고 OGTag가 없더라도 타이틀, 설명, 이미지를 적당히 가져와서 보여줍니다. 페이스북 크롤러가 미리보기에 사용할 값을들 파싱할때 OGTag가 있으면 OGTag를, 없으면 다른 곳에서 데이터를 가져오도록 구현되어 있는듯 하네요. <a href="http://develope.android.com">http://develope.android.com</a> 페이지를 가지고 테스트 해봤더니(ogtag가 없는 페이지) 타이틀은 title, 설명은 description을 가져옵니다. 이미지는 첫번째 이미지가 아니고 중간에 있는걸 가져오는데 뭘 기준으로 고르는지는 잘 모르겠네요.</p><h4 id="마무리">마무리</h4><p>폴라에서 공유하기 기능을 개발하면서 단순히 URL링크만 공유했는데 어떻게 다른 서비스에서는 저렇게 링크를 보기좋게 보여줄까 하고 궁금했습니다. 다른 분께도 이 글이 도움이 되면 좋겠습니다</p>]]></content:encoded>
      
      <comments>https://jeongmin.github.io/2016/03/30/web/web-ogtag/#disqus_thread</comments>
    </item>
    
    <item>
      <title>안드로이드 개발 시 유용한 툴 소개(ChromeADB, Vysor)</title>
      <link>https://jeongmin.github.io/2016/03/19/android/android-tools/</link>
      <guid>https://jeongmin.github.io/2016/03/19/android/android-tools/</guid>
      <pubDate>Fri, 18 Mar 2016 15:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;안녕하세요. 오늘은 안드로이드 개발 시 유용한 툴 두가지를 소개드리려고 합니다. 기술적인 내용이 아니니 가볍게 봐주시면 좋겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;ChromeADB&quot;&gt;&lt;a href=&quot;https://chrome.google.com/webst
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>안녕하세요. 오늘은 안드로이드 개발 시 유용한 툴 두가지를 소개드리려고 합니다. 기술적인 내용이 아니니 가볍게 봐주시면 좋겠습니다.</p><h2 id="ChromeADB"><a href="https://chrome.google.com/webstore/detail/chromeadb/fhdoijgfljahinnpbolfdimpcfoicmnm?hl=ko">ChromeADB</a></h2><p>첫번째로 소개드릴 툴은 ChromeADB입니다. 이 툴은 ADB 주요 기능들에 GUI를 입혀서 만든 크롬앱입니다. 사용해보시면 굳이 설명이 필요없을 정도로 UI도 단순하고 직관적인데요.<br>그래도 간단히 소개해 드리도록 하겠습니다. 먼저 아래 화면은 패키지 관리 화면입니다. 앱 삭제 및 설치, 데이터 삭제, 강제 종료를 쉽게 할 수 있습니다. 보통은 단말의 설정 -&gt; 앱관리에 들어가 원하는 앱을 찾고 위의 작업들을 하는데요. 제조사나 안드로이드 버전에 따라 메뉴 구성이 달라서 은근히 많은 시간이 들고 자주하게 되면 매우 귀찮은 작업입니다. 하지만 ChromeADB를 사용하면 매우 쉽고 빠르게 이런 작업들을 할 수 있습니다.</p><p><img src="chromeadb_look.png" alt="chromeadb_look.png"></p><p>두번째로는 컨트롤러 화면입니다. 텍스트 입력, 전원, 볼륨 등의 사용자 입력을 이용한 테스트를 할 수 있습니다. 저는 글쓰기 에디터를 만들때 유용하게 사용했던 기능입니다.</p><p><img src="/assets/img/tool/chromeadb_controller.png" alt="chromeadb_controller.png"></p><p>마지막으로 보여드릴 기능은 메모리 관리 기능인데요. 그래프를 통해서 실시간으로 메모리 사용량을 볼 수 있습니다. 사실 이 기능은 안드로이드 스튜디오에서 이제 메모리 사용량을 예쁘게 보여주기 때문에 별로 의미가 없어지긴 했는데요. 예전에 이클립스를 사용할때는 정말 유용했던 기능입니다. 프로세스 탭에 들어간 후 메모리 사용량을 보고 싶은 앱을 선택하면 됩니다.</p><p><img src="/assets/img/tool/chromeadb_memory.png" alt="chromeadb_memory.png"></p><h2 id="Vysor"><a href="https://chrome.google.com/webstore/detail/vysor-beta/gidgenkbbabolejbgbpnhbimgjbffefm?hl=ko">Vysor</a></h2><p>두번째로 소개드릴 앱은 바로 Vysor라는 앱으로 ChromeADB와 마찬가지로 크롬앱입니다. 실제 안드로이드 단말의 화면을 컴퓨터 화면으로 미러링해주는 앱으로 정말 강력하게 추천하는 앱입니다. 그 이유는 다음과 같습니다. 일반적으로 테스트를 하다보면 에물레이터를 쓰거나 단말을 직접 연결해서 단말을 통해 테스트를 하는데요. 이 두가지 방법은 모두 장단점이 있습니다. 에뮬레이터를 쓰는 경우엔 보통 네트워크나 카메라, GPS 등의 테스트가 제한적이고 각종 앱들의 계정 관련 설정을 하기가 까다롭습니다. 가령 카카오톡 공유하기 기능 같은 걸 테스트하기 위해서는 카카오톡 계정을 연동하는 등의 작업을 해야하는데 이런 부분이 어렵죠. 실제 단말을 사용하는 경우엔 위의 단점들을 극복할 수 있지만 매번 모니터를 보고 코드를 작성하다가 다시 단말을 확인하는 작업이 여간 불편한게 아닙니다. 하지만 이 앱을 쓰면 이런 단점들은 커버하고 장점만 취할 수가 있습니다. 회의때 프리젠테이션 용도로 사용해도 아주 좋구요. 사용법도 너무 간단합니다. Vysor를 실행하고 PC와 안드로이드 단말을 연결하면 Vysor에 연결된 단말이 나오고 Connect 버튼을 누르면 바로 미러링이 시작됩니다.</p><p><img src="/assets/img/tool/vysor_look.png" alt="vysor_look.png"></p><p>아래 화면은 미러링이 시작된 화면입니다.</p><p><img src="/assets/img/tool/vysor_mirror1.png" alt="vysor_mirror1.png"><br><img src="/assets/img/tool/vysor_mirror2.png" alt="vysor_mirror2.png"></p><p>아래 이미지는 실제 단말에서 카메라를 켠 화면인데요. 미러링된 화면에서도 잘 보이는걸 알 수 있습니다.<br><img src="/assets/img/tool/vysor_mirror3.png" alt="vysor_mirror3.png"></p><p>개발을 하다보면 키보드에서 마우스로 손 한번 가는것도 귀찮게 느껴질때가 있는데요. 코드를 짜고 빌드 버튼을 누르고 키보드에서 손을 떼고 단말을 손에 쥐고 테스트하는 작업은 말할것도 없죠.<br>이런것들이 상당히 많이 해소되기 때문에 정말 좋습니다. (살짝 화면상에 딜레이가 있거나 화질이 떨어지기도 하는데요 크게 불편한 정도는 아닌거 같습니다.)</p><p>마지막으로 위에 소개드린 두 앱은 모두 크롬앱으로 만들어졌기 때문에 맥이든 윈도우든 리눅스든 다 사용이 가능하고 설치고 크롬 앱스토어에서 쉽게 설치가 가능하구요. 일반 앱처럼 런처를 통해서도 바로 실행 시킬 수 있는것도 큰 장점인것 같습니다. 장인은 연장을 가리지 않는다고 하지만 좋은 툴들을 사용하면 개발이나 테스트 시간을 많이 줄여주기 때문에 이런 툴들을 적절히 잘 사용하면 좋을 것 같습니다!</p>]]></content:encoded>
      
      <comments>https://jeongmin.github.io/2016/03/19/android/android-tools/#disqus_thread</comments>
    </item>
    
    <item>
      <title>뷰페이저(ViewPager)</title>
      <link>https://jeongmin.github.io/2015/12/30/android/android-get-current-fragment/</link>
      <guid>https://jeongmin.github.io/2015/12/30/android/android-get-current-fragment/</guid>
      <pubDate>Tue, 29 Dec 2015 15:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;ViewPager는 좌우 스와이핑 제스처를 통해 뷰를 전환하는 레이아웃관리자로 볼 수 있다. 뷰페이저의 페이지는 전환될 레이아웃을 말하기 때문에 당연히 뷰도 될 수 있고 뷰그룹도 될 수 있다. 보통 가장많이 쓰이는건 프래그먼트와 함께 많이 쓰이게
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>ViewPager는 좌우 스와이핑 제스처를 통해 뷰를 전환하는 레이아웃관리자로 볼 수 있다. 뷰페이저의 페이지는 전환될 레이아웃을 말하기 때문에 당연히 뷰도 될 수 있고 뷰그룹도 될 수 있다. 보통 가장많이 쓰이는건 프래그먼트와 함께 많이 쓰이게 된다.</p><h2 id="특징">특징</h2><p>뷰페이저는 항상 현재 위치의 좌우 아이템을 미리 로드한다. 즉 현재 3번 페이지를 보여주고 있다면 이미 2, 4번 페이지에 대한 getItem이 호출된다. 0번에 있다면 우측의 1번 페이지까지 해서 2개가 로드된다. 그리고 현재 위치를 기준으로 좌우에 있는 페이지까지만 유지하고 그 밖에 있는 것들은 버린다.</p><h2 id="뷰페이저의-현재-아이템-가져오기">뷰페이저의 현재 아이템 가져오기</h2><p>뷰페이저는 페이지들의 전환을 쉽게 해준다. 당연히 뷰페이저를 통해 UX를 구성할때는 현재 페이지를 가져와서 원하는 작업을 하고 싶은 경우가 많다. 그래서 당연히 뷰페이저나 뷰페이저어댑터를 통해 현재 페이지를 가져올 수 있는 API가 있을 것 같다. 그…그런데…없다…그런거…-_-; 만들어야한다.</p><p><a href="http://stackoverflow.com/questions/8785221/retrieve-a-fragment-from-a-viewpager">참고자료 stackOverFlow…</a></p><p>어떻게 할까 한 10초 고민하다가 바로 android viewpager get current fragment로 구글링을 해보니 바로 어떤 똘똘한 아저씨가 친절하게 해결책을 올려주셨다. 요새는 검색하면 어지간한 문제는 다 해결이 되는데 그만큼 내 머리를 쓸일은 적어지는 것 같다. 쩝…</p><p>아이디어는 간단하다.</p><ol><li>프래그먼트가 생성되면 리스트에 담는다</li><li>프래그먼트가 소멸되면 리스트에서 버린다</li><li>필요할때마다 리스트에서 꺼낸다</li></ol><p>주의점은 아까 특징에서 언급했듯이 뷰페이저는 현재 위치를 기준으로 좌우의 페이지까지만 가지고 있는다. 즉 현재 위치나 내 좌우 페이지가 아닌 위치의 페이지를 가져오려고 하면 오류가 발생한다.</p><p>이정도 개념을 머리에 두고 아래 코드를 보면 바로 이해가 갈 것 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPagerAdapter</span> <span class="keyword">extends</span> <span class="title">FragmentStatePagerAdapter</span> </span>&#123;</span><br><span class="line">    SparseArray&lt;Fragment&gt; registeredFragments = <span class="keyword">new</span> SparseArray&lt;Fragment&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyPagerAdapter</span><span class="params">(FragmentManager fm)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(fm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ...;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fragment <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MyFragment.newInstance(...); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">instantiateItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        Fragment fragment = (Fragment) <span class="keyword">super</span>.instantiateItem(container, position);</span><br><span class="line">        registeredFragments.put(position, fragment);</span><br><span class="line">        <span class="keyword">return</span> fragment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position, Object object)</span> </span>&#123;</span><br><span class="line">        registeredFragments.remove(position);</span><br><span class="line">        <span class="keyword">super</span>.destroyItem(container, position, object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fragment <span class="title">getRegisteredFragment</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> registeredFragments.get(position);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드는 아까 위에서 링크를 걸어뒀던 스택오버플로우에 있는 코드이다. 코드를 보면 아래와 같다.</p><ol><li>프래그먼트가 생성되면 리스트에 담는다<ul><li>instantiateItem()</li></ul></li><li>프래그먼트가 소멸되면 리스트에서 버린다<ul><li>destroyItem()</li></ul></li><li>필요할때마다 리스트에서 꺼낸다<ul><li>getRegisteredFragment()</li></ul></li></ol><p>실제 사용할때는 아래와 같이 사용하게 될 것 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> mCurrentPosition;</span><br><span class="line">ViewPager mViewPager;</span><br><span class="line">MyPagerAdapter mAdapter;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initViewPager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mViewPager = ...;</span><br><span class="line">mAdapter = <span class="keyword">new</span> MyPagerAdapter(......);</span><br><span class="line"></span><br><span class="line">mViewPager.setAdapter(mAdapter);</span><br><span class="line">mViewPager.setOnPageChangeListener(<span class="keyword">new</span> ViewPager.OnPageChangeListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrolled</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">float</span> positionOffset, <span class="keyword">int</span> positionOffsetPixels)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageSelected</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">                mCurrentPosition = position;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrollStateChanged</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomethingWithCurrentFragment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Fragment fragment = mAdapter.getRegisteredFragment(mCurrentPosition);</span><br><span class="line">        <span class="keyword">if</span> (fragment == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// do something with current fragment..</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>먼저 뷰페이저의 현재 위치를 알기 위해 onPageChangeListener를 뷰페이저에 달아준다. 이 리스너의 onPageSelected는 뷰페이저의 페이지가 바뀔때마다 호출된다. 이걸 통해 현재 뷰패이저의 위치를 가지고 있다가 필요할 때 뷰페이저어댑터를 통해 현재 프래그먼트를 가져온다. 끝!!!</p>]]></content:encoded>
      
      <comments>https://jeongmin.github.io/2015/12/30/android/android-get-current-fragment/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
